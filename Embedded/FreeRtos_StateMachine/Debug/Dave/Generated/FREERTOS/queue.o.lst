   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "queue.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .comm xQueueRegistry,64,4
  20              	 .section .text.xQueueGenericReset,"ax",%progbits
  21              	 .align 2
  22              	 .global xQueueGenericReset
  23              	 .thumb
  24              	 .thumb_func
  26              	xQueueGenericReset:
  27              	.LFB135:
  28              	 .file 1 "../Dave/Generated/FREERTOS/queue.c"
   1:../Dave/Generated/FREERTOS/queue.c **** /*
   2:../Dave/Generated/FREERTOS/queue.c ****  * FreeRTOS Kernel V10.0.1
   3:../Dave/Generated/FREERTOS/queue.c ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../Dave/Generated/FREERTOS/queue.c ****  *
   5:../Dave/Generated/FREERTOS/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../Dave/Generated/FREERTOS/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../Dave/Generated/FREERTOS/queue.c ****  * the Software without restriction, including without limitation the rights to
   8:../Dave/Generated/FREERTOS/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../Dave/Generated/FREERTOS/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../Dave/Generated/FREERTOS/queue.c ****  * subject to the following conditions:
  11:../Dave/Generated/FREERTOS/queue.c ****  *
  12:../Dave/Generated/FREERTOS/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../Dave/Generated/FREERTOS/queue.c ****  * copies or substantial portions of the Software.
  14:../Dave/Generated/FREERTOS/queue.c ****  *
  15:../Dave/Generated/FREERTOS/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../Dave/Generated/FREERTOS/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../Dave/Generated/FREERTOS/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../Dave/Generated/FREERTOS/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../Dave/Generated/FREERTOS/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../Dave/Generated/FREERTOS/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../Dave/Generated/FREERTOS/queue.c ****  *
  22:../Dave/Generated/FREERTOS/queue.c ****  * http://www.FreeRTOS.org
  23:../Dave/Generated/FREERTOS/queue.c ****  * http://aws.amazon.com/freertos
  24:../Dave/Generated/FREERTOS/queue.c ****  *
  25:../Dave/Generated/FREERTOS/queue.c ****  * 1 tab == 4 spaces!
  26:../Dave/Generated/FREERTOS/queue.c ****  */
  27:../Dave/Generated/FREERTOS/queue.c **** 
  28:../Dave/Generated/FREERTOS/queue.c **** #include <stdlib.h>
  29:../Dave/Generated/FREERTOS/queue.c **** #include <string.h>
  30:../Dave/Generated/FREERTOS/queue.c **** 
  31:../Dave/Generated/FREERTOS/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  32:../Dave/Generated/FREERTOS/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  33:../Dave/Generated/FREERTOS/queue.c **** task.h is included from an application file. */
  34:../Dave/Generated/FREERTOS/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  35:../Dave/Generated/FREERTOS/queue.c **** 
  36:../Dave/Generated/FREERTOS/queue.c **** #include "FreeRTOS.h"
  37:../Dave/Generated/FREERTOS/queue.c **** #include "task.h"
  38:../Dave/Generated/FREERTOS/queue.c **** #include "queue.h"
  39:../Dave/Generated/FREERTOS/queue.c **** 
  40:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  41:../Dave/Generated/FREERTOS/queue.c **** 	#include "croutine.h"
  42:../Dave/Generated/FREERTOS/queue.c **** #endif
  43:../Dave/Generated/FREERTOS/queue.c **** 
  44:../Dave/Generated/FREERTOS/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  45:../Dave/Generated/FREERTOS/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  46:../Dave/Generated/FREERTOS/queue.c **** header files above, but not in this file, in order to generate the correct
  47:../Dave/Generated/FREERTOS/queue.c **** privileged Vs unprivileged linkage and placement. */
  48:../Dave/Generated/FREERTOS/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  49:../Dave/Generated/FREERTOS/queue.c **** 
  50:../Dave/Generated/FREERTOS/queue.c **** 
  51:../Dave/Generated/FREERTOS/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  52:../Dave/Generated/FREERTOS/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  53:../Dave/Generated/FREERTOS/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  54:../Dave/Generated/FREERTOS/queue.c **** 
  55:../Dave/Generated/FREERTOS/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  56:../Dave/Generated/FREERTOS/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  57:../Dave/Generated/FREERTOS/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  58:../Dave/Generated/FREERTOS/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  59:../Dave/Generated/FREERTOS/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
  60:../Dave/Generated/FREERTOS/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
  61:../Dave/Generated/FREERTOS/queue.c **** the code is maintained despite this dual use of two structure members.  An
  62:../Dave/Generated/FREERTOS/queue.c **** alternative implementation would be to use a union, but use of a union is
  63:../Dave/Generated/FREERTOS/queue.c **** against the coding standard (although an exception to the standard has been
  64:../Dave/Generated/FREERTOS/queue.c **** permitted where the dual use also significantly changes the type of the
  65:../Dave/Generated/FREERTOS/queue.c **** structure member). */
  66:../Dave/Generated/FREERTOS/queue.c **** #define pxMutexHolder					pcTail
  67:../Dave/Generated/FREERTOS/queue.c **** #define uxQueueType						pcHead
  68:../Dave/Generated/FREERTOS/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  69:../Dave/Generated/FREERTOS/queue.c **** 
  70:../Dave/Generated/FREERTOS/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  71:../Dave/Generated/FREERTOS/queue.c **** zero. */
  72:../Dave/Generated/FREERTOS/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
  73:../Dave/Generated/FREERTOS/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
  74:../Dave/Generated/FREERTOS/queue.c **** 
  75:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_PREEMPTION == 0 )
  76:../Dave/Generated/FREERTOS/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  77:../Dave/Generated/FREERTOS/queue.c **** 	performed just because a higher priority task has been woken. */
  78:../Dave/Generated/FREERTOS/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
  79:../Dave/Generated/FREERTOS/queue.c **** #else
  80:../Dave/Generated/FREERTOS/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  81:../Dave/Generated/FREERTOS/queue.c **** #endif
  82:../Dave/Generated/FREERTOS/queue.c **** 
  83:../Dave/Generated/FREERTOS/queue.c **** /*
  84:../Dave/Generated/FREERTOS/queue.c ****  * Definition of the queue used by the scheduler.
  85:../Dave/Generated/FREERTOS/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  86:../Dave/Generated/FREERTOS/queue.c ****  * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
  87:../Dave/Generated/FREERTOS/queue.c ****  */
  88:../Dave/Generated/FREERTOS/queue.c **** typedef struct QueueDefinition
  89:../Dave/Generated/FREERTOS/queue.c **** {
  90:../Dave/Generated/FREERTOS/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
  91:../Dave/Generated/FREERTOS/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
  92:../Dave/Generated/FREERTOS/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
  93:../Dave/Generated/FREERTOS/queue.c **** 
  94:../Dave/Generated/FREERTOS/queue.c **** 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclus
  95:../Dave/Generated/FREERTOS/queue.c **** 	{
  96:../Dave/Generated/FREERTOS/queue.c **** 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the stru
  97:../Dave/Generated/FREERTOS/queue.c **** 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex h
  98:../Dave/Generated/FREERTOS/queue.c **** 	} u;
  99:../Dave/Generated/FREERTOS/queue.c **** 
 100:../Dave/Generated/FREERTOS/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 101:../Dave/Generated/FREERTOS/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 102:../Dave/Generated/FREERTOS/queue.c **** 
 103:../Dave/Generated/FREERTOS/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 104:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 105:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 106:../Dave/Generated/FREERTOS/queue.c **** 
 107:../Dave/Generated/FREERTOS/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 108:../Dave/Generated/FREERTOS/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 109:../Dave/Generated/FREERTOS/queue.c **** 
 110:../Dave/Generated/FREERTOS/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 111:../Dave/Generated/FREERTOS/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 112:../Dave/Generated/FREERTOS/queue.c **** 	#endif
 113:../Dave/Generated/FREERTOS/queue.c **** 
 114:../Dave/Generated/FREERTOS/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 115:../Dave/Generated/FREERTOS/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 116:../Dave/Generated/FREERTOS/queue.c **** 	#endif
 117:../Dave/Generated/FREERTOS/queue.c **** 
 118:../Dave/Generated/FREERTOS/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 119:../Dave/Generated/FREERTOS/queue.c **** 		UBaseType_t uxQueueNumber;
 120:../Dave/Generated/FREERTOS/queue.c **** 		uint8_t ucQueueType;
 121:../Dave/Generated/FREERTOS/queue.c **** 	#endif
 122:../Dave/Generated/FREERTOS/queue.c **** 
 123:../Dave/Generated/FREERTOS/queue.c **** } xQUEUE;
 124:../Dave/Generated/FREERTOS/queue.c **** 
 125:../Dave/Generated/FREERTOS/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 126:../Dave/Generated/FREERTOS/queue.c **** name below to enable the use of older kernel aware debuggers. */
 127:../Dave/Generated/FREERTOS/queue.c **** typedef xQUEUE Queue_t;
 128:../Dave/Generated/FREERTOS/queue.c **** 
 129:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 130:../Dave/Generated/FREERTOS/queue.c **** 
 131:../Dave/Generated/FREERTOS/queue.c **** /*
 132:../Dave/Generated/FREERTOS/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 133:../Dave/Generated/FREERTOS/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 134:../Dave/Generated/FREERTOS/queue.c ****  */
 135:../Dave/Generated/FREERTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 136:../Dave/Generated/FREERTOS/queue.c **** 
 137:../Dave/Generated/FREERTOS/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 138:../Dave/Generated/FREERTOS/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 139:../Dave/Generated/FREERTOS/queue.c **** 	more user friendly. */
 140:../Dave/Generated/FREERTOS/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 141:../Dave/Generated/FREERTOS/queue.c **** 	{
 142:../Dave/Generated/FREERTOS/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 143:../Dave/Generated/FREERTOS/queue.c **** 		QueueHandle_t xHandle;
 144:../Dave/Generated/FREERTOS/queue.c **** 	} xQueueRegistryItem;
 145:../Dave/Generated/FREERTOS/queue.c **** 
 146:../Dave/Generated/FREERTOS/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 147:../Dave/Generated/FREERTOS/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 148:../Dave/Generated/FREERTOS/queue.c **** 	debuggers. */
 149:../Dave/Generated/FREERTOS/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 150:../Dave/Generated/FREERTOS/queue.c **** 
 151:../Dave/Generated/FREERTOS/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 152:../Dave/Generated/FREERTOS/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 153:../Dave/Generated/FREERTOS/queue.c **** 	array position being vacant. */
 154:../Dave/Generated/FREERTOS/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 155:../Dave/Generated/FREERTOS/queue.c **** 
 156:../Dave/Generated/FREERTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 157:../Dave/Generated/FREERTOS/queue.c **** 
 158:../Dave/Generated/FREERTOS/queue.c **** /*
 159:../Dave/Generated/FREERTOS/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 160:../Dave/Generated/FREERTOS/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 161:../Dave/Generated/FREERTOS/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 162:../Dave/Generated/FREERTOS/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 163:../Dave/Generated/FREERTOS/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 164:../Dave/Generated/FREERTOS/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 165:../Dave/Generated/FREERTOS/queue.c ****  */
 166:../Dave/Generated/FREERTOS/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 167:../Dave/Generated/FREERTOS/queue.c **** 
 168:../Dave/Generated/FREERTOS/queue.c **** /*
 169:../Dave/Generated/FREERTOS/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 170:../Dave/Generated/FREERTOS/queue.c ****  *
 171:../Dave/Generated/FREERTOS/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 172:../Dave/Generated/FREERTOS/queue.c ****  */
 173:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 174:../Dave/Generated/FREERTOS/queue.c **** 
 175:../Dave/Generated/FREERTOS/queue.c **** /*
 176:../Dave/Generated/FREERTOS/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 177:../Dave/Generated/FREERTOS/queue.c ****  *
 178:../Dave/Generated/FREERTOS/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 179:../Dave/Generated/FREERTOS/queue.c ****  */
 180:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 181:../Dave/Generated/FREERTOS/queue.c **** 
 182:../Dave/Generated/FREERTOS/queue.c **** /*
 183:../Dave/Generated/FREERTOS/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 184:../Dave/Generated/FREERTOS/queue.c ****  * back of the queue.
 185:../Dave/Generated/FREERTOS/queue.c ****  */
 186:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 187:../Dave/Generated/FREERTOS/queue.c **** 
 188:../Dave/Generated/FREERTOS/queue.c **** /*
 189:../Dave/Generated/FREERTOS/queue.c ****  * Copies an item out of a queue.
 190:../Dave/Generated/FREERTOS/queue.c ****  */
 191:../Dave/Generated/FREERTOS/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 192:../Dave/Generated/FREERTOS/queue.c **** 
 193:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 194:../Dave/Generated/FREERTOS/queue.c **** 	/*
 195:../Dave/Generated/FREERTOS/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 196:../Dave/Generated/FREERTOS/queue.c **** 	 * the queue set that the queue contains data.
 197:../Dave/Generated/FREERTOS/queue.c **** 	 */
 198:../Dave/Generated/FREERTOS/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 199:../Dave/Generated/FREERTOS/queue.c **** #endif
 200:../Dave/Generated/FREERTOS/queue.c **** 
 201:../Dave/Generated/FREERTOS/queue.c **** /*
 202:../Dave/Generated/FREERTOS/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 203:../Dave/Generated/FREERTOS/queue.c ****  * dynamically to fill in the structure's members.
 204:../Dave/Generated/FREERTOS/queue.c ****  */
 205:../Dave/Generated/FREERTOS/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 206:../Dave/Generated/FREERTOS/queue.c **** 
 207:../Dave/Generated/FREERTOS/queue.c **** /*
 208:../Dave/Generated/FREERTOS/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 209:../Dave/Generated/FREERTOS/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 210:../Dave/Generated/FREERTOS/queue.c ****  * as a mutex.
 211:../Dave/Generated/FREERTOS/queue.c ****  */
 212:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_MUTEXES == 1 )
 213:../Dave/Generated/FREERTOS/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
 214:../Dave/Generated/FREERTOS/queue.c **** #endif
 215:../Dave/Generated/FREERTOS/queue.c **** 
 216:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_MUTEXES == 1 )
 217:../Dave/Generated/FREERTOS/queue.c **** 	/*
 218:../Dave/Generated/FREERTOS/queue.c **** 	 * If a task waiting for a mutex causes the mutex holder to inherit a
 219:../Dave/Generated/FREERTOS/queue.c **** 	 * priority, but the waiting task times out, then the holder should
 220:../Dave/Generated/FREERTOS/queue.c **** 	 * disinherit the priority - but only down to the highest priority of any
 221:../Dave/Generated/FREERTOS/queue.c **** 	 * other tasks that are waiting for the same mutex.  This function returns
 222:../Dave/Generated/FREERTOS/queue.c **** 	 * that priority.
 223:../Dave/Generated/FREERTOS/queue.c **** 	 */
 224:../Dave/Generated/FREERTOS/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGE
 225:../Dave/Generated/FREERTOS/queue.c **** #endif
 226:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 227:../Dave/Generated/FREERTOS/queue.c **** 
 228:../Dave/Generated/FREERTOS/queue.c **** /*
 229:../Dave/Generated/FREERTOS/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 230:../Dave/Generated/FREERTOS/queue.c ****  * accessing the queue event lists.
 231:../Dave/Generated/FREERTOS/queue.c ****  */
 232:../Dave/Generated/FREERTOS/queue.c **** #define prvLockQueue( pxQueue )								\
 233:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();									\
 234:../Dave/Generated/FREERTOS/queue.c **** 	{														\
 235:../Dave/Generated/FREERTOS/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 236:../Dave/Generated/FREERTOS/queue.c **** 		{													\
 237:../Dave/Generated/FREERTOS/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 238:../Dave/Generated/FREERTOS/queue.c **** 		}													\
 239:../Dave/Generated/FREERTOS/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 240:../Dave/Generated/FREERTOS/queue.c **** 		{													\
 241:../Dave/Generated/FREERTOS/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 242:../Dave/Generated/FREERTOS/queue.c **** 		}													\
 243:../Dave/Generated/FREERTOS/queue.c **** 	}														\
 244:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL()
 245:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 246:../Dave/Generated/FREERTOS/queue.c **** 
 247:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 248:../Dave/Generated/FREERTOS/queue.c **** {
  29              	 .loc 1 248 0
  30              	 .cfi_startproc
  31              	 
  32              	 
  33 0000 80B5     	 push {r7,lr}
  34              	.LCFI0:
  35              	 .cfi_def_cfa_offset 8
  36              	 .cfi_offset 7,-8
  37              	 .cfi_offset 14,-4
  38 0002 84B0     	 sub sp,sp,#16
  39              	.LCFI1:
  40              	 .cfi_def_cfa_offset 24
  41 0004 00AF     	 add r7,sp,#0
  42              	.LCFI2:
  43              	 .cfi_def_cfa_register 7
  44 0006 7860     	 str r0,[r7,#4]
  45 0008 3960     	 str r1,[r7]
 249:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  46              	 .loc 1 249 0
  47 000a 7B68     	 ldr r3,[r7,#4]
  48 000c FB60     	 str r3,[r7,#12]
 250:../Dave/Generated/FREERTOS/queue.c **** 
 251:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
  49              	 .loc 1 251 0
  50 000e FB68     	 ldr r3,[r7,#12]
  51 0010 002B     	 cmp r3,#0
  52 0012 09D1     	 bne .L2
  53              	.LBB108:
  54              	.LBB109:
  55              	 .file 2 "../Dave/Generated/FREERTOS/portable/GCC/portmacro.h"
   1:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*
   2:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * FreeRTOS Kernel V10.0.1
   3:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
   5:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * subject to the following conditions:
  11:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  12:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * copies or substantial portions of the Software.
  14:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  15:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  22:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * http://www.FreeRTOS.org
  23:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * http://aws.amazon.com/freertos
  24:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  25:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * 1 tab == 4 spaces!
  26:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  */
  27:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  28:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  29:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifndef PORTMACRO_H
  30:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define PORTMACRO_H
  31:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  32:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifdef __cplusplus
  33:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** extern "C" {
  34:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
  35:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  36:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------
  37:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * Port specific definitions.
  38:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  39:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * given hardware and compiler.
  41:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  42:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * These settings should not be altered.
  43:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *-----------------------------------------------------------
  44:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  */
  45:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  46:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Type definitions. */
  47:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portCHAR		char
  48:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portFLOAT		float
  49:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portDOUBLE		double
  50:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portLONG		long
  51:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portSHORT		short
  52:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portSTACK_TYPE	uint32_t
  53:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portBASE_TYPE	long
  54:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  55:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** typedef portSTACK_TYPE StackType_t;
  56:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** typedef long BaseType_t;
  57:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** typedef unsigned long UBaseType_t;
  58:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  59:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
  60:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	typedef uint16_t TickType_t;
  61:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
  62:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #else
  63:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	typedef uint32_t TickType_t;
  64:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
  65:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  66:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	not need to be guarded with a critical section. */
  68:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
  69:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
  70:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
  71:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  72:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Architecture specifics. */
  73:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portSTACK_GROWTH			( -1 )
  74:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portBYTE_ALIGNMENT			8
  76:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
  77:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  78:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Scheduler utilities. */
  79:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portYIELD() 															\
  80:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** {																				\
  81:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
  82:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
  83:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 																				\
  84:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
  85:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	within the specified behaviour for the architecture. */						\
  86:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile( "dsb" ::: "memory" );										\
  87:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile( "isb" );													\
  88:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
  89:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  90:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
  91:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
  92:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
  93:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
  94:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
  95:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  96:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Critical section management. */
  97:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** extern void vPortEnterCritical( void );
  98:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** extern void vPortExitCritical( void );
  99:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 100:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 101:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 102:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 103:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 104:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 105:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 106:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 107:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 108:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 109:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 110:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** (which build with all the ports) will build. */
 111:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 112:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 113:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 114:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 115:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Tickless idle/low power functionality. */
 116:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 117:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 118:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 119:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
 120:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 121:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 122:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Architecture specific optimisations. */
 123:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 124:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 125:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
 126:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 127:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 128:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 129:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Generic helper function. */
 130:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 131:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	{
 132:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	uint8_t ucReturn;
 133:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 134:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 135:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		return ucReturn;
 136:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	}
 137:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 138:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Check the configuration. */
 139:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 140:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 141:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#endif
 142:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 143:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
 144:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 145:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
 146:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 147:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/*-----------------------------------------------------------*/
 148:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 149:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ui
 150:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 151:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 152:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 153:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 154:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 155:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifdef configASSERT
 156:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	void vPortValidateInterruptPriority( void );
 157:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 158:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
 159:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 160:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* portNOP() is not required by this port. */
 161:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portNOP()
 162:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 163:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portINLINE	__inline
 164:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 165:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifndef portFORCE_INLINE
 166:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
 167:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
 168:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 169:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 170:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** {
 171:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** uint32_t ulCurrentInterrupt;
 172:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** BaseType_t xReturn;
 173:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 174:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Obtain the number of the currently executing interrupt. */
 175:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 176:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 177:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	if( ulCurrentInterrupt == 0 )
 178:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	{
 179:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		xReturn = pdFALSE;
 180:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	}
 181:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	else
 182:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	{
 183:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		xReturn = pdTRUE;
 184:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	}
 185:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 186:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	return xReturn;
 187:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 188:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 189:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 190:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 191:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 192:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** {
 193:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** uint32_t ulNewBASEPRI;
 194:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile
  56              	 .loc 2 195 0 discriminator 1
  57              	
  58 0014 4FF0FC03 	 mov r3,#252
  59 0018 83F31188 	 msr basepri,r3
  60 001c BFF36F8F 	 isb 
  61 0020 BFF34F8F 	 dsb 
  62              	
  63              	
  64              	 .thumb
  65 0024 BB60     	 str r3,[r7,#8]
  66              	.L3:
  67              	.LBE109:
  68              	.LBE108:
  69              	 .loc 1 251 0 discriminator 1
  70 0026 FEE7     	 b .L3
  71              	.L2:
 252:../Dave/Generated/FREERTOS/queue.c **** 
 253:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
  72              	 .loc 1 253 0
  73 0028 FFF7FEFF 	 bl vPortEnterCritical
 254:../Dave/Generated/FREERTOS/queue.c **** 	{
 255:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  74              	 .loc 1 255 0
  75 002c FB68     	 ldr r3,[r7,#12]
  76 002e 1A68     	 ldr r2,[r3]
  77 0030 FB68     	 ldr r3,[r7,#12]
  78 0032 DB6B     	 ldr r3,[r3,#60]
  79 0034 F968     	 ldr r1,[r7,#12]
  80 0036 096C     	 ldr r1,[r1,#64]
  81 0038 01FB03F3 	 mul r3,r1,r3
  82 003c 1A44     	 add r2,r2,r3
  83 003e FB68     	 ldr r3,[r7,#12]
  84 0040 5A60     	 str r2,[r3,#4]
 256:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  85              	 .loc 1 256 0
  86 0042 FB68     	 ldr r3,[r7,#12]
  87 0044 0022     	 movs r2,#0
  88 0046 9A63     	 str r2,[r3,#56]
 257:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
  89              	 .loc 1 257 0
  90 0048 FB68     	 ldr r3,[r7,#12]
  91 004a 1A68     	 ldr r2,[r3]
  92 004c FB68     	 ldr r3,[r7,#12]
  93 004e 9A60     	 str r2,[r3,#8]
 258:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
  94              	 .loc 1 258 0
  95 0050 FB68     	 ldr r3,[r7,#12]
  96 0052 1A68     	 ldr r2,[r3]
  97 0054 FB68     	 ldr r3,[r7,#12]
  98 0056 DB6B     	 ldr r3,[r3,#60]
  99 0058 013B     	 subs r3,r3,#1
 100 005a F968     	 ldr r1,[r7,#12]
 101 005c 096C     	 ldr r1,[r1,#64]
 102 005e 01FB03F3 	 mul r3,r1,r3
 103 0062 1A44     	 add r2,r2,r3
 104 0064 FB68     	 ldr r3,[r7,#12]
 105 0066 DA60     	 str r2,[r3,#12]
 259:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 106              	 .loc 1 259 0
 107 0068 FB68     	 ldr r3,[r7,#12]
 108 006a FF22     	 movs r2,#255
 109 006c 83F84420 	 strb r2,[r3,#68]
 260:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 110              	 .loc 1 260 0
 111 0070 FB68     	 ldr r3,[r7,#12]
 112 0072 FF22     	 movs r2,#255
 113 0074 83F84520 	 strb r2,[r3,#69]
 261:../Dave/Generated/FREERTOS/queue.c **** 
 262:../Dave/Generated/FREERTOS/queue.c **** 		if( xNewQueue == pdFALSE )
 114              	 .loc 1 262 0
 115 0078 3B68     	 ldr r3,[r7]
 116 007a 002B     	 cmp r3,#0
 117 007c 14D1     	 bne .L4
 263:../Dave/Generated/FREERTOS/queue.c **** 		{
 264:../Dave/Generated/FREERTOS/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 265:../Dave/Generated/FREERTOS/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 266:../Dave/Generated/FREERTOS/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 267:../Dave/Generated/FREERTOS/queue.c **** 			the queue, then one should be unblocked as after this function exits
 268:../Dave/Generated/FREERTOS/queue.c **** 			it will be possible to write to it. */
 269:../Dave/Generated/FREERTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 118              	 .loc 1 269 0
 119 007e FB68     	 ldr r3,[r7,#12]
 120 0080 1B69     	 ldr r3,[r3,#16]
 121 0082 002B     	 cmp r3,#0
 122 0084 1AD0     	 beq .L5
 270:../Dave/Generated/FREERTOS/queue.c **** 			{
 271:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 123              	 .loc 1 271 0
 124 0086 FB68     	 ldr r3,[r7,#12]
 125 0088 1033     	 adds r3,r3,#16
 126 008a 1846     	 mov r0,r3
 127 008c FFF7FEFF 	 bl xTaskRemoveFromEventList
 128 0090 0346     	 mov r3,r0
 129 0092 002B     	 cmp r3,#0
 130 0094 12D0     	 beq .L5
 272:../Dave/Generated/FREERTOS/queue.c **** 				{
 273:../Dave/Generated/FREERTOS/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 131              	 .loc 1 273 0
 132 0096 0D4B     	 ldr r3,.L7
 133 0098 4FF08052 	 mov r2,#268435456
 134 009c 1A60     	 str r2,[r3]
 135              	
 136 009e BFF34F8F 	 dsb
 137              	
 138              	
 139 00a2 BFF36F8F 	 isb
 140              	
 141              	 .thumb
 142 00a6 09E0     	 b .L5
 143              	.L4:
 274:../Dave/Generated/FREERTOS/queue.c **** 				}
 275:../Dave/Generated/FREERTOS/queue.c **** 				else
 276:../Dave/Generated/FREERTOS/queue.c **** 				{
 277:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 278:../Dave/Generated/FREERTOS/queue.c **** 				}
 279:../Dave/Generated/FREERTOS/queue.c **** 			}
 280:../Dave/Generated/FREERTOS/queue.c **** 			else
 281:../Dave/Generated/FREERTOS/queue.c **** 			{
 282:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 283:../Dave/Generated/FREERTOS/queue.c **** 			}
 284:../Dave/Generated/FREERTOS/queue.c **** 		}
 285:../Dave/Generated/FREERTOS/queue.c **** 		else
 286:../Dave/Generated/FREERTOS/queue.c **** 		{
 287:../Dave/Generated/FREERTOS/queue.c **** 			/* Ensure the event queues start in the correct state. */
 288:../Dave/Generated/FREERTOS/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 144              	 .loc 1 288 0
 145 00a8 FB68     	 ldr r3,[r7,#12]
 146 00aa 1033     	 adds r3,r3,#16
 147 00ac 1846     	 mov r0,r3
 148 00ae FFF7FEFF 	 bl vListInitialise
 289:../Dave/Generated/FREERTOS/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 149              	 .loc 1 289 0
 150 00b2 FB68     	 ldr r3,[r7,#12]
 151 00b4 2433     	 adds r3,r3,#36
 152 00b6 1846     	 mov r0,r3
 153 00b8 FFF7FEFF 	 bl vListInitialise
 154              	.L5:
 290:../Dave/Generated/FREERTOS/queue.c **** 		}
 291:../Dave/Generated/FREERTOS/queue.c **** 	}
 292:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 155              	 .loc 1 292 0
 156 00bc FFF7FEFF 	 bl vPortExitCritical
 293:../Dave/Generated/FREERTOS/queue.c **** 
 294:../Dave/Generated/FREERTOS/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 295:../Dave/Generated/FREERTOS/queue.c **** 	versions. */
 296:../Dave/Generated/FREERTOS/queue.c **** 	return pdPASS;
 157              	 .loc 1 296 0
 158 00c0 0123     	 movs r3,#1
 297:../Dave/Generated/FREERTOS/queue.c **** }
 159              	 .loc 1 297 0
 160 00c2 1846     	 mov r0,r3
 161 00c4 1037     	 adds r7,r7,#16
 162              	.LCFI3:
 163              	 .cfi_def_cfa_offset 8
 164 00c6 BD46     	 mov sp,r7
 165              	.LCFI4:
 166              	 .cfi_def_cfa_register 13
 167              	 
 168 00c8 80BD     	 pop {r7,pc}
 169              	.L8:
 170 00ca 00BF     	 .align 2
 171              	.L7:
 172 00cc 04ED00E0 	 .word -536810236
 173              	 .cfi_endproc
 174              	.LFE135:
 176              	 .section .text.xQueueGenericCreate,"ax",%progbits
 177              	 .align 2
 178              	 .global xQueueGenericCreate
 179              	 .thumb
 180              	 .thumb_func
 182              	xQueueGenericCreate:
 183              	.LFB136:
 298:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 299:../Dave/Generated/FREERTOS/queue.c **** 
 300:../Dave/Generated/FREERTOS/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 301:../Dave/Generated/FREERTOS/queue.c **** 
 302:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 303:../Dave/Generated/FREERTOS/queue.c **** 	{
 304:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t *pxNewQueue;
 305:../Dave/Generated/FREERTOS/queue.c **** 
 306:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 307:../Dave/Generated/FREERTOS/queue.c **** 
 308:../Dave/Generated/FREERTOS/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 309:../Dave/Generated/FREERTOS/queue.c **** 		supplied. */
 310:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 311:../Dave/Generated/FREERTOS/queue.c **** 
 312:../Dave/Generated/FREERTOS/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 313:../Dave/Generated/FREERTOS/queue.c **** 		should not be provided if the item size is 0. */
 314:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 315:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 316:../Dave/Generated/FREERTOS/queue.c **** 
 317:../Dave/Generated/FREERTOS/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 318:../Dave/Generated/FREERTOS/queue.c **** 		{
 319:../Dave/Generated/FREERTOS/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 320:../Dave/Generated/FREERTOS/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 321:../Dave/Generated/FREERTOS/queue.c **** 			the real queue and semaphore structures. */
 322:../Dave/Generated/FREERTOS/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 323:../Dave/Generated/FREERTOS/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 324:../Dave/Generated/FREERTOS/queue.c **** 		}
 325:../Dave/Generated/FREERTOS/queue.c **** 		#endif /* configASSERT_DEFINED */
 326:../Dave/Generated/FREERTOS/queue.c **** 
 327:../Dave/Generated/FREERTOS/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
 328:../Dave/Generated/FREERTOS/queue.c **** 		The address of a statically allocated storage area was also passed in
 329:../Dave/Generated/FREERTOS/queue.c **** 		but is already set. */
 330:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 Unusual cast is ok as the structures are d
 331:../Dave/Generated/FREERTOS/queue.c **** 
 332:../Dave/Generated/FREERTOS/queue.c **** 		if( pxNewQueue != NULL )
 333:../Dave/Generated/FREERTOS/queue.c **** 		{
 334:../Dave/Generated/FREERTOS/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 335:../Dave/Generated/FREERTOS/queue.c **** 			{
 336:../Dave/Generated/FREERTOS/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 337:../Dave/Generated/FREERTOS/queue.c **** 				note this queue was allocated statically in case the queue is
 338:../Dave/Generated/FREERTOS/queue.c **** 				later deleted. */
 339:../Dave/Generated/FREERTOS/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 340:../Dave/Generated/FREERTOS/queue.c **** 			}
 341:../Dave/Generated/FREERTOS/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 342:../Dave/Generated/FREERTOS/queue.c **** 
 343:../Dave/Generated/FREERTOS/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 344:../Dave/Generated/FREERTOS/queue.c **** 		}
 345:../Dave/Generated/FREERTOS/queue.c **** 		else
 346:../Dave/Generated/FREERTOS/queue.c **** 		{
 347:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 348:../Dave/Generated/FREERTOS/queue.c **** 		}
 349:../Dave/Generated/FREERTOS/queue.c **** 
 350:../Dave/Generated/FREERTOS/queue.c **** 		return pxNewQueue;
 351:../Dave/Generated/FREERTOS/queue.c **** 	}
 352:../Dave/Generated/FREERTOS/queue.c **** 
 353:../Dave/Generated/FREERTOS/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 354:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 355:../Dave/Generated/FREERTOS/queue.c **** 
 356:../Dave/Generated/FREERTOS/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 357:../Dave/Generated/FREERTOS/queue.c **** 
 358:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 359:../Dave/Generated/FREERTOS/queue.c **** 	{
 184              	 .loc 1 359 0
 185              	 .cfi_startproc
 186              	 
 187              	 
 188 0000 90B5     	 push {r4,r7,lr}
 189              	.LCFI5:
 190              	 .cfi_def_cfa_offset 12
 191              	 .cfi_offset 4,-12
 192              	 .cfi_offset 7,-8
 193              	 .cfi_offset 14,-4
 194 0002 8BB0     	 sub sp,sp,#44
 195              	.LCFI6:
 196              	 .cfi_def_cfa_offset 56
 197 0004 02AF     	 add r7,sp,#8
 198              	.LCFI7:
 199              	 .cfi_def_cfa 7,48
 200 0006 F860     	 str r0,[r7,#12]
 201 0008 B960     	 str r1,[r7,#8]
 202 000a 1346     	 mov r3,r2
 203 000c FB71     	 strb r3,[r7,#7]
 360:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t *pxNewQueue;
 361:../Dave/Generated/FREERTOS/queue.c **** 	size_t xQueueSizeInBytes;
 362:../Dave/Generated/FREERTOS/queue.c **** 	uint8_t *pucQueueStorage;
 363:../Dave/Generated/FREERTOS/queue.c **** 
 364:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 204              	 .loc 1 364 0
 205 000e FB68     	 ldr r3,[r7,#12]
 206 0010 002B     	 cmp r3,#0
 207 0012 09D1     	 bne .L10
 208              	.LBB110:
 209              	.LBB111:
 210              	 .loc 2 195 0 discriminator 1
 211              	
 212 0014 4FF0FC03 	 mov r3,#252
 213 0018 83F31188 	 msr basepri,r3
 214 001c BFF36F8F 	 isb 
 215 0020 BFF34F8F 	 dsb 
 216              	
 217              	
 218              	 .thumb
 219 0024 3B61     	 str r3,[r7,#16]
 220              	.L11:
 221              	.LBE111:
 222              	.LBE110:
 223              	 .loc 1 364 0 discriminator 1
 224 0026 FEE7     	 b .L11
 225              	.L10:
 365:../Dave/Generated/FREERTOS/queue.c **** 
 366:../Dave/Generated/FREERTOS/queue.c **** 		if( uxItemSize == ( UBaseType_t ) 0 )
 226              	 .loc 1 366 0
 227 0028 BB68     	 ldr r3,[r7,#8]
 228 002a 002B     	 cmp r3,#0
 229 002c 02D1     	 bne .L12
 367:../Dave/Generated/FREERTOS/queue.c **** 		{
 368:../Dave/Generated/FREERTOS/queue.c **** 			/* There is not going to be a queue storage area. */
 369:../Dave/Generated/FREERTOS/queue.c **** 			xQueueSizeInBytes = ( size_t ) 0;
 230              	 .loc 1 369 0
 231 002e 0023     	 movs r3,#0
 232 0030 FB61     	 str r3,[r7,#28]
 233 0032 04E0     	 b .L13
 234              	.L12:
 370:../Dave/Generated/FREERTOS/queue.c **** 		}
 371:../Dave/Generated/FREERTOS/queue.c **** 		else
 372:../Dave/Generated/FREERTOS/queue.c **** 		{
 373:../Dave/Generated/FREERTOS/queue.c **** 			/* Allocate enough space to hold the maximum number of items that
 374:../Dave/Generated/FREERTOS/queue.c **** 			can be in the queue at any time. */
 375:../Dave/Generated/FREERTOS/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as t
 235              	 .loc 1 375 0
 236 0034 FB68     	 ldr r3,[r7,#12]
 237 0036 BA68     	 ldr r2,[r7,#8]
 238 0038 02FB03F3 	 mul r3,r2,r3
 239 003c FB61     	 str r3,[r7,#28]
 240              	.L13:
 376:../Dave/Generated/FREERTOS/queue.c **** 		}
 377:../Dave/Generated/FREERTOS/queue.c **** 
 378:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 241              	 .loc 1 378 0
 242 003e FB69     	 ldr r3,[r7,#28]
 243 0040 5433     	 adds r3,r3,#84
 244 0042 1846     	 mov r0,r3
 245 0044 FFF7FEFF 	 bl pvPortMalloc
 246 0048 B861     	 str r0,[r7,#24]
 379:../Dave/Generated/FREERTOS/queue.c **** 
 380:../Dave/Generated/FREERTOS/queue.c **** 		if( pxNewQueue != NULL )
 247              	 .loc 1 380 0
 248 004a BB69     	 ldr r3,[r7,#24]
 249 004c 002B     	 cmp r3,#0
 250 004e 0BD0     	 beq .L14
 381:../Dave/Generated/FREERTOS/queue.c **** 		{
 382:../Dave/Generated/FREERTOS/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 383:../Dave/Generated/FREERTOS/queue.c **** 			storage area. */
 384:../Dave/Generated/FREERTOS/queue.c **** 			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 251              	 .loc 1 384 0
 252 0050 BB69     	 ldr r3,[r7,#24]
 253 0052 5433     	 adds r3,r3,#84
 254 0054 7B61     	 str r3,[r7,#20]
 385:../Dave/Generated/FREERTOS/queue.c **** 
 386:../Dave/Generated/FREERTOS/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 387:../Dave/Generated/FREERTOS/queue.c **** 			{
 388:../Dave/Generated/FREERTOS/queue.c **** 				/* Queues can be created either statically or dynamically, so
 389:../Dave/Generated/FREERTOS/queue.c **** 				note this task was created dynamically in case it is later
 390:../Dave/Generated/FREERTOS/queue.c **** 				deleted. */
 391:../Dave/Generated/FREERTOS/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 392:../Dave/Generated/FREERTOS/queue.c **** 			}
 393:../Dave/Generated/FREERTOS/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 394:../Dave/Generated/FREERTOS/queue.c **** 
 395:../Dave/Generated/FREERTOS/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 255              	 .loc 1 395 0
 256 0056 FC79     	 ldrb r4,[r7,#7]
 257 0058 BB69     	 ldr r3,[r7,#24]
 258 005a 0093     	 str r3,[sp]
 259 005c F868     	 ldr r0,[r7,#12]
 260 005e B968     	 ldr r1,[r7,#8]
 261 0060 7A69     	 ldr r2,[r7,#20]
 262 0062 2346     	 mov r3,r4
 263 0064 FFF7FEFF 	 bl prvInitialiseNewQueue
 264              	.L14:
 396:../Dave/Generated/FREERTOS/queue.c **** 		}
 397:../Dave/Generated/FREERTOS/queue.c **** 		else
 398:../Dave/Generated/FREERTOS/queue.c **** 		{
 399:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 400:../Dave/Generated/FREERTOS/queue.c **** 		}
 401:../Dave/Generated/FREERTOS/queue.c **** 
 402:../Dave/Generated/FREERTOS/queue.c **** 		return pxNewQueue;
 265              	 .loc 1 402 0
 266 0068 BB69     	 ldr r3,[r7,#24]
 403:../Dave/Generated/FREERTOS/queue.c **** 	}
 267              	 .loc 1 403 0
 268 006a 1846     	 mov r0,r3
 269 006c 2437     	 adds r7,r7,#36
 270              	.LCFI8:
 271              	 .cfi_def_cfa_offset 12
 272 006e BD46     	 mov sp,r7
 273              	.LCFI9:
 274              	 .cfi_def_cfa_register 13
 275              	 
 276 0070 90BD     	 pop {r4,r7,pc}
 277              	 .cfi_endproc
 278              	.LFE136:
 280 0072 00BF     	 .section .text.prvInitialiseNewQueue,"ax",%progbits
 281              	 .align 2
 282              	 .thumb
 283              	 .thumb_func
 285              	prvInitialiseNewQueue:
 286              	.LFB137:
 404:../Dave/Generated/FREERTOS/queue.c **** 
 405:../Dave/Generated/FREERTOS/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 406:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 407:../Dave/Generated/FREERTOS/queue.c **** 
 408:../Dave/Generated/FREERTOS/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 409:../Dave/Generated/FREERTOS/queue.c **** {
 287              	 .loc 1 409 0
 288              	 .cfi_startproc
 289              	 
 290              	 
 291 0000 80B5     	 push {r7,lr}
 292              	.LCFI10:
 293              	 .cfi_def_cfa_offset 8
 294              	 .cfi_offset 7,-8
 295              	 .cfi_offset 14,-4
 296 0002 84B0     	 sub sp,sp,#16
 297              	.LCFI11:
 298              	 .cfi_def_cfa_offset 24
 299 0004 00AF     	 add r7,sp,#0
 300              	.LCFI12:
 301              	 .cfi_def_cfa_register 7
 302 0006 F860     	 str r0,[r7,#12]
 303 0008 B960     	 str r1,[r7,#8]
 304 000a 7A60     	 str r2,[r7,#4]
 305 000c FB70     	 strb r3,[r7,#3]
 410:../Dave/Generated/FREERTOS/queue.c **** 	/* Remove compiler warnings about unused parameters should
 411:../Dave/Generated/FREERTOS/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 412:../Dave/Generated/FREERTOS/queue.c **** 	( void ) ucQueueType;
 413:../Dave/Generated/FREERTOS/queue.c **** 
 414:../Dave/Generated/FREERTOS/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 306              	 .loc 1 414 0
 307 000e BB68     	 ldr r3,[r7,#8]
 308 0010 002B     	 cmp r3,#0
 309 0012 03D1     	 bne .L17
 415:../Dave/Generated/FREERTOS/queue.c **** 	{
 416:../Dave/Generated/FREERTOS/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 417:../Dave/Generated/FREERTOS/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 418:../Dave/Generated/FREERTOS/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 419:../Dave/Generated/FREERTOS/queue.c **** 		value that is known to be within the memory map. */
 420:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 310              	 .loc 1 420 0
 311 0014 BB69     	 ldr r3,[r7,#24]
 312 0016 BA69     	 ldr r2,[r7,#24]
 313 0018 1A60     	 str r2,[r3]
 314 001a 02E0     	 b .L18
 315              	.L17:
 421:../Dave/Generated/FREERTOS/queue.c **** 	}
 422:../Dave/Generated/FREERTOS/queue.c **** 	else
 423:../Dave/Generated/FREERTOS/queue.c **** 	{
 424:../Dave/Generated/FREERTOS/queue.c **** 		/* Set the head to the start of the queue storage area. */
 425:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 316              	 .loc 1 425 0
 317 001c BB69     	 ldr r3,[r7,#24]
 318 001e 7A68     	 ldr r2,[r7,#4]
 319 0020 1A60     	 str r2,[r3]
 320              	.L18:
 426:../Dave/Generated/FREERTOS/queue.c **** 	}
 427:../Dave/Generated/FREERTOS/queue.c **** 
 428:../Dave/Generated/FREERTOS/queue.c **** 	/* Initialise the queue members as described where the queue type is
 429:../Dave/Generated/FREERTOS/queue.c **** 	defined. */
 430:../Dave/Generated/FREERTOS/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 321              	 .loc 1 430 0
 322 0022 BB69     	 ldr r3,[r7,#24]
 323 0024 FA68     	 ldr r2,[r7,#12]
 324 0026 DA63     	 str r2,[r3,#60]
 431:../Dave/Generated/FREERTOS/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 325              	 .loc 1 431 0
 326 0028 BB69     	 ldr r3,[r7,#24]
 327 002a BA68     	 ldr r2,[r7,#8]
 328 002c 1A64     	 str r2,[r3,#64]
 432:../Dave/Generated/FREERTOS/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 329              	 .loc 1 432 0
 330 002e B869     	 ldr r0,[r7,#24]
 331 0030 0121     	 movs r1,#1
 332 0032 FFF7FEFF 	 bl xQueueGenericReset
 433:../Dave/Generated/FREERTOS/queue.c **** 
 434:../Dave/Generated/FREERTOS/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 435:../Dave/Generated/FREERTOS/queue.c **** 	{
 436:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 333              	 .loc 1 436 0
 334 0036 BB69     	 ldr r3,[r7,#24]
 335 0038 FA78     	 ldrb r2,[r7,#3]
 336 003a 83F85020 	 strb r2,[r3,#80]
 437:../Dave/Generated/FREERTOS/queue.c **** 	}
 438:../Dave/Generated/FREERTOS/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 439:../Dave/Generated/FREERTOS/queue.c **** 
 440:../Dave/Generated/FREERTOS/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 441:../Dave/Generated/FREERTOS/queue.c **** 	{
 442:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 337              	 .loc 1 442 0
 338 003e BB69     	 ldr r3,[r7,#24]
 339 0040 0022     	 movs r2,#0
 340 0042 9A64     	 str r2,[r3,#72]
 443:../Dave/Generated/FREERTOS/queue.c **** 	}
 444:../Dave/Generated/FREERTOS/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
 445:../Dave/Generated/FREERTOS/queue.c **** 
 446:../Dave/Generated/FREERTOS/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 447:../Dave/Generated/FREERTOS/queue.c **** }
 341              	 .loc 1 447 0
 342 0044 1037     	 adds r7,r7,#16
 343              	.LCFI13:
 344              	 .cfi_def_cfa_offset 8
 345 0046 BD46     	 mov sp,r7
 346              	.LCFI14:
 347              	 .cfi_def_cfa_register 13
 348              	 
 349 0048 80BD     	 pop {r7,pc}
 350              	 .cfi_endproc
 351              	.LFE137:
 353 004a 00BF     	 .section .text.prvInitialiseMutex,"ax",%progbits
 354              	 .align 2
 355              	 .thumb
 356              	 .thumb_func
 358              	prvInitialiseMutex:
 359              	.LFB138:
 448:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 449:../Dave/Generated/FREERTOS/queue.c **** 
 450:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_MUTEXES == 1 )
 451:../Dave/Generated/FREERTOS/queue.c **** 
 452:../Dave/Generated/FREERTOS/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 453:../Dave/Generated/FREERTOS/queue.c **** 	{
 360              	 .loc 1 453 0
 361              	 .cfi_startproc
 362              	 
 363              	 
 364 0000 80B5     	 push {r7,lr}
 365              	.LCFI15:
 366              	 .cfi_def_cfa_offset 8
 367              	 .cfi_offset 7,-8
 368              	 .cfi_offset 14,-4
 369 0002 82B0     	 sub sp,sp,#8
 370              	.LCFI16:
 371              	 .cfi_def_cfa_offset 16
 372 0004 00AF     	 add r7,sp,#0
 373              	.LCFI17:
 374              	 .cfi_def_cfa_register 7
 375 0006 7860     	 str r0,[r7,#4]
 454:../Dave/Generated/FREERTOS/queue.c **** 		if( pxNewQueue != NULL )
 376              	 .loc 1 454 0
 377 0008 7B68     	 ldr r3,[r7,#4]
 378 000a 002B     	 cmp r3,#0
 379 000c 0ED0     	 beq .L19
 455:../Dave/Generated/FREERTOS/queue.c **** 		{
 456:../Dave/Generated/FREERTOS/queue.c **** 			/* The queue create function will set all the queue structure members
 457:../Dave/Generated/FREERTOS/queue.c **** 			correctly for a generic queue, but this function is creating a
 458:../Dave/Generated/FREERTOS/queue.c **** 			mutex.  Overwrite those members that need to be set differently -
 459:../Dave/Generated/FREERTOS/queue.c **** 			in particular the information required for priority inheritance. */
 460:../Dave/Generated/FREERTOS/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 380              	 .loc 1 460 0
 381 000e 7B68     	 ldr r3,[r7,#4]
 382 0010 0022     	 movs r2,#0
 383 0012 5A60     	 str r2,[r3,#4]
 461:../Dave/Generated/FREERTOS/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 384              	 .loc 1 461 0
 385 0014 7B68     	 ldr r3,[r7,#4]
 386 0016 0022     	 movs r2,#0
 387 0018 1A60     	 str r2,[r3]
 462:../Dave/Generated/FREERTOS/queue.c **** 
 463:../Dave/Generated/FREERTOS/queue.c **** 			/* In case this is a recursive mutex. */
 464:../Dave/Generated/FREERTOS/queue.c **** 			pxNewQueue->u.uxRecursiveCallCount = 0;
 388              	 .loc 1 464 0
 389 001a 7B68     	 ldr r3,[r7,#4]
 390 001c 0022     	 movs r2,#0
 391 001e DA60     	 str r2,[r3,#12]
 465:../Dave/Generated/FREERTOS/queue.c **** 
 466:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 467:../Dave/Generated/FREERTOS/queue.c **** 
 468:../Dave/Generated/FREERTOS/queue.c **** 			/* Start with the semaphore in the expected state. */
 469:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 392              	 .loc 1 469 0
 393 0020 7868     	 ldr r0,[r7,#4]
 394 0022 0021     	 movs r1,#0
 395 0024 0022     	 movs r2,#0
 396 0026 0023     	 movs r3,#0
 397 0028 FFF7FEFF 	 bl xQueueGenericSend
 398              	.L19:
 470:../Dave/Generated/FREERTOS/queue.c **** 		}
 471:../Dave/Generated/FREERTOS/queue.c **** 		else
 472:../Dave/Generated/FREERTOS/queue.c **** 		{
 473:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_MUTEX_FAILED();
 474:../Dave/Generated/FREERTOS/queue.c **** 		}
 475:../Dave/Generated/FREERTOS/queue.c **** 	}
 399              	 .loc 1 475 0
 400 002c 0837     	 adds r7,r7,#8
 401              	.LCFI18:
 402              	 .cfi_def_cfa_offset 8
 403 002e BD46     	 mov sp,r7
 404              	.LCFI19:
 405              	 .cfi_def_cfa_register 13
 406              	 
 407 0030 80BD     	 pop {r7,pc}
 408              	 .cfi_endproc
 409              	.LFE138:
 411 0032 00BF     	 .section .text.xQueueCreateMutex,"ax",%progbits
 412              	 .align 2
 413              	 .global xQueueCreateMutex
 414              	 .thumb
 415              	 .thumb_func
 417              	xQueueCreateMutex:
 418              	.LFB139:
 476:../Dave/Generated/FREERTOS/queue.c **** 
 477:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_MUTEXES */
 478:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 479:../Dave/Generated/FREERTOS/queue.c **** 
 480:../Dave/Generated/FREERTOS/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 481:../Dave/Generated/FREERTOS/queue.c **** 
 482:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 483:../Dave/Generated/FREERTOS/queue.c **** 	{
 419              	 .loc 1 483 0
 420              	 .cfi_startproc
 421              	 
 422              	 
 423 0000 80B5     	 push {r7,lr}
 424              	.LCFI20:
 425              	 .cfi_def_cfa_offset 8
 426              	 .cfi_offset 7,-8
 427              	 .cfi_offset 14,-4
 428 0002 86B0     	 sub sp,sp,#24
 429              	.LCFI21:
 430              	 .cfi_def_cfa_offset 32
 431 0004 00AF     	 add r7,sp,#0
 432              	.LCFI22:
 433              	 .cfi_def_cfa_register 7
 434 0006 0346     	 mov r3,r0
 435 0008 FB71     	 strb r3,[r7,#7]
 484:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t *pxNewQueue;
 485:../Dave/Generated/FREERTOS/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 436              	 .loc 1 485 0
 437 000a 0123     	 movs r3,#1
 438 000c 7B61     	 str r3,[r7,#20]
 439 000e 0023     	 movs r3,#0
 440 0010 3B61     	 str r3,[r7,#16]
 486:../Dave/Generated/FREERTOS/queue.c **** 
 487:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 441              	 .loc 1 487 0
 442 0012 FB79     	 ldrb r3,[r7,#7]
 443 0014 7869     	 ldr r0,[r7,#20]
 444 0016 3969     	 ldr r1,[r7,#16]
 445 0018 1A46     	 mov r2,r3
 446 001a FFF7FEFF 	 bl xQueueGenericCreate
 447 001e F860     	 str r0,[r7,#12]
 488:../Dave/Generated/FREERTOS/queue.c **** 		prvInitialiseMutex( pxNewQueue );
 448              	 .loc 1 488 0
 449 0020 F868     	 ldr r0,[r7,#12]
 450 0022 FFF7FEFF 	 bl prvInitialiseMutex
 489:../Dave/Generated/FREERTOS/queue.c **** 
 490:../Dave/Generated/FREERTOS/queue.c **** 		return pxNewQueue;
 451              	 .loc 1 490 0
 452 0026 FB68     	 ldr r3,[r7,#12]
 491:../Dave/Generated/FREERTOS/queue.c **** 	}
 453              	 .loc 1 491 0
 454 0028 1846     	 mov r0,r3
 455 002a 1837     	 adds r7,r7,#24
 456              	.LCFI23:
 457              	 .cfi_def_cfa_offset 8
 458 002c BD46     	 mov sp,r7
 459              	.LCFI24:
 460              	 .cfi_def_cfa_register 13
 461              	 
 462 002e 80BD     	 pop {r7,pc}
 463              	 .cfi_endproc
 464              	.LFE139:
 466              	 .section .text.xQueueGetMutexHolder,"ax",%progbits
 467              	 .align 2
 468              	 .global xQueueGetMutexHolder
 469              	 .thumb
 470              	 .thumb_func
 472              	xQueueGetMutexHolder:
 473              	.LFB140:
 492:../Dave/Generated/FREERTOS/queue.c **** 
 493:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_MUTEXES */
 494:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 495:../Dave/Generated/FREERTOS/queue.c **** 
 496:../Dave/Generated/FREERTOS/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 497:../Dave/Generated/FREERTOS/queue.c **** 
 498:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
 499:../Dave/Generated/FREERTOS/queue.c **** 	{
 500:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t *pxNewQueue;
 501:../Dave/Generated/FREERTOS/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 502:../Dave/Generated/FREERTOS/queue.c **** 
 503:../Dave/Generated/FREERTOS/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 504:../Dave/Generated/FREERTOS/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 505:../Dave/Generated/FREERTOS/queue.c **** 		( void ) ucQueueType;
 506:../Dave/Generated/FREERTOS/queue.c **** 
 507:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQ
 508:../Dave/Generated/FREERTOS/queue.c **** 		prvInitialiseMutex( pxNewQueue );
 509:../Dave/Generated/FREERTOS/queue.c **** 
 510:../Dave/Generated/FREERTOS/queue.c **** 		return pxNewQueue;
 511:../Dave/Generated/FREERTOS/queue.c **** 	}
 512:../Dave/Generated/FREERTOS/queue.c **** 
 513:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_MUTEXES */
 514:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 515:../Dave/Generated/FREERTOS/queue.c **** 
 516:../Dave/Generated/FREERTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 517:../Dave/Generated/FREERTOS/queue.c **** 
 518:../Dave/Generated/FREERTOS/queue.c **** 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 519:../Dave/Generated/FREERTOS/queue.c **** 	{
 474              	 .loc 1 519 0
 475              	 .cfi_startproc
 476              	 
 477              	 
 478 0000 80B5     	 push {r7,lr}
 479              	.LCFI25:
 480              	 .cfi_def_cfa_offset 8
 481              	 .cfi_offset 7,-8
 482              	 .cfi_offset 14,-4
 483 0002 84B0     	 sub sp,sp,#16
 484              	.LCFI26:
 485              	 .cfi_def_cfa_offset 24
 486 0004 00AF     	 add r7,sp,#0
 487              	.LCFI27:
 488              	 .cfi_def_cfa_register 7
 489 0006 7860     	 str r0,[r7,#4]
 520:../Dave/Generated/FREERTOS/queue.c **** 	void *pxReturn;
 521:../Dave/Generated/FREERTOS/queue.c **** 
 522:../Dave/Generated/FREERTOS/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 523:../Dave/Generated/FREERTOS/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 524:../Dave/Generated/FREERTOS/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 525:../Dave/Generated/FREERTOS/queue.c **** 		identity of the mutex holder, as the holder may change between the
 526:../Dave/Generated/FREERTOS/queue.c **** 		following critical section exiting and the function returning. */
 527:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 490              	 .loc 1 527 0
 491 0008 FFF7FEFF 	 bl vPortEnterCritical
 528:../Dave/Generated/FREERTOS/queue.c **** 		{
 529:../Dave/Generated/FREERTOS/queue.c **** 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 492              	 .loc 1 529 0
 493 000c 7B68     	 ldr r3,[r7,#4]
 494 000e 1B68     	 ldr r3,[r3]
 495 0010 002B     	 cmp r3,#0
 496 0012 03D1     	 bne .L24
 530:../Dave/Generated/FREERTOS/queue.c **** 			{
 531:../Dave/Generated/FREERTOS/queue.c **** 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 497              	 .loc 1 531 0
 498 0014 7B68     	 ldr r3,[r7,#4]
 499 0016 5B68     	 ldr r3,[r3,#4]
 500 0018 FB60     	 str r3,[r7,#12]
 501 001a 01E0     	 b .L25
 502              	.L24:
 532:../Dave/Generated/FREERTOS/queue.c **** 			}
 533:../Dave/Generated/FREERTOS/queue.c **** 			else
 534:../Dave/Generated/FREERTOS/queue.c **** 			{
 535:../Dave/Generated/FREERTOS/queue.c **** 				pxReturn = NULL;
 503              	 .loc 1 535 0
 504 001c 0023     	 movs r3,#0
 505 001e FB60     	 str r3,[r7,#12]
 506              	.L25:
 536:../Dave/Generated/FREERTOS/queue.c **** 			}
 537:../Dave/Generated/FREERTOS/queue.c **** 		}
 538:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 507              	 .loc 1 538 0
 508 0020 FFF7FEFF 	 bl vPortExitCritical
 539:../Dave/Generated/FREERTOS/queue.c **** 
 540:../Dave/Generated/FREERTOS/queue.c **** 		return pxReturn;
 509              	 .loc 1 540 0
 510 0024 FB68     	 ldr r3,[r7,#12]
 541:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 511              	 .loc 1 541 0
 512 0026 1846     	 mov r0,r3
 513 0028 1037     	 adds r7,r7,#16
 514              	.LCFI28:
 515              	 .cfi_def_cfa_offset 8
 516 002a BD46     	 mov sp,r7
 517              	.LCFI29:
 518              	 .cfi_def_cfa_register 13
 519              	 
 520 002c 80BD     	 pop {r7,pc}
 521              	 .cfi_endproc
 522              	.LFE140:
 524 002e 00BF     	 .section .text.xQueueGetMutexHolderFromISR,"ax",%progbits
 525              	 .align 2
 526              	 .global xQueueGetMutexHolderFromISR
 527              	 .thumb
 528              	 .thumb_func
 530              	xQueueGetMutexHolderFromISR:
 531              	.LFB141:
 542:../Dave/Generated/FREERTOS/queue.c **** 
 543:../Dave/Generated/FREERTOS/queue.c **** #endif
 544:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 545:../Dave/Generated/FREERTOS/queue.c **** 
 546:../Dave/Generated/FREERTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 547:../Dave/Generated/FREERTOS/queue.c **** 
 548:../Dave/Generated/FREERTOS/queue.c **** 	void* xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 549:../Dave/Generated/FREERTOS/queue.c **** 	{
 532              	 .loc 1 549 0
 533              	 .cfi_startproc
 534              	 
 535              	 
 536              	 
 537 0000 80B4     	 push {r7}
 538              	.LCFI30:
 539              	 .cfi_def_cfa_offset 4
 540              	 .cfi_offset 7,-4
 541 0002 85B0     	 sub sp,sp,#20
 542              	.LCFI31:
 543              	 .cfi_def_cfa_offset 24
 544 0004 00AF     	 add r7,sp,#0
 545              	.LCFI32:
 546              	 .cfi_def_cfa_register 7
 547 0006 7860     	 str r0,[r7,#4]
 550:../Dave/Generated/FREERTOS/queue.c **** 	void *pxReturn;
 551:../Dave/Generated/FREERTOS/queue.c **** 
 552:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( xSemaphore );
 548              	 .loc 1 552 0
 549 0008 7B68     	 ldr r3,[r7,#4]
 550 000a 002B     	 cmp r3,#0
 551 000c 09D1     	 bne .L28
 552              	.LBB112:
 553              	.LBB113:
 554              	 .loc 2 195 0 discriminator 1
 555              	
 556 000e 4FF0FC03 	 mov r3,#252
 557 0012 83F31188 	 msr basepri,r3
 558 0016 BFF36F8F 	 isb 
 559 001a BFF34F8F 	 dsb 
 560              	
 561              	
 562              	 .thumb
 563 001e BB60     	 str r3,[r7,#8]
 564              	.L29:
 565              	.LBE113:
 566              	.LBE112:
 567              	 .loc 1 552 0 discriminator 1
 568 0020 FEE7     	 b .L29
 569              	.L28:
 553:../Dave/Generated/FREERTOS/queue.c **** 
 554:../Dave/Generated/FREERTOS/queue.c **** 		/* Mutexes cannot be used in interrupt service routines, so the mutex
 555:../Dave/Generated/FREERTOS/queue.c **** 		holder should not change in an ISR, and therefore a critical section is
 556:../Dave/Generated/FREERTOS/queue.c **** 		not required here. */
 557:../Dave/Generated/FREERTOS/queue.c **** 		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 570              	 .loc 1 557 0
 571 0022 7B68     	 ldr r3,[r7,#4]
 572 0024 1B68     	 ldr r3,[r3]
 573 0026 002B     	 cmp r3,#0
 574 0028 03D1     	 bne .L30
 558:../Dave/Generated/FREERTOS/queue.c **** 		{
 559:../Dave/Generated/FREERTOS/queue.c **** 			pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 575              	 .loc 1 559 0
 576 002a 7B68     	 ldr r3,[r7,#4]
 577 002c 5B68     	 ldr r3,[r3,#4]
 578 002e FB60     	 str r3,[r7,#12]
 579 0030 01E0     	 b .L31
 580              	.L30:
 560:../Dave/Generated/FREERTOS/queue.c **** 		}
 561:../Dave/Generated/FREERTOS/queue.c **** 		else
 562:../Dave/Generated/FREERTOS/queue.c **** 		{
 563:../Dave/Generated/FREERTOS/queue.c **** 			pxReturn = NULL;
 581              	 .loc 1 563 0
 582 0032 0023     	 movs r3,#0
 583 0034 FB60     	 str r3,[r7,#12]
 584              	.L31:
 564:../Dave/Generated/FREERTOS/queue.c **** 		}
 565:../Dave/Generated/FREERTOS/queue.c **** 
 566:../Dave/Generated/FREERTOS/queue.c **** 		return pxReturn;
 585              	 .loc 1 566 0
 586 0036 FB68     	 ldr r3,[r7,#12]
 567:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 587              	 .loc 1 567 0
 588 0038 1846     	 mov r0,r3
 589 003a 1437     	 adds r7,r7,#20
 590              	.LCFI33:
 591              	 .cfi_def_cfa_offset 4
 592 003c BD46     	 mov sp,r7
 593              	.LCFI34:
 594              	 .cfi_def_cfa_register 13
 595              	 
 596 003e 5DF8047B 	 ldr r7,[sp],#4
 597              	.LCFI35:
 598              	 .cfi_restore 7
 599              	 .cfi_def_cfa_offset 0
 600 0042 7047     	 bx lr
 601              	 .cfi_endproc
 602              	.LFE141:
 604              	 .section .text.xQueueGiveMutexRecursive,"ax",%progbits
 605              	 .align 2
 606              	 .global xQueueGiveMutexRecursive
 607              	 .thumb
 608              	 .thumb_func
 610              	xQueueGiveMutexRecursive:
 611              	.LFB142:
 568:../Dave/Generated/FREERTOS/queue.c **** 
 569:../Dave/Generated/FREERTOS/queue.c **** #endif
 570:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 571:../Dave/Generated/FREERTOS/queue.c **** 
 572:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 573:../Dave/Generated/FREERTOS/queue.c **** 
 574:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 575:../Dave/Generated/FREERTOS/queue.c **** 	{
 612              	 .loc 1 575 0
 613              	 .cfi_startproc
 614              	 
 615              	 
 616 0000 90B5     	 push {r4,r7,lr}
 617              	.LCFI36:
 618              	 .cfi_def_cfa_offset 12
 619              	 .cfi_offset 4,-12
 620              	 .cfi_offset 7,-8
 621              	 .cfi_offset 14,-4
 622 0002 87B0     	 sub sp,sp,#28
 623              	.LCFI37:
 624              	 .cfi_def_cfa_offset 40
 625 0004 00AF     	 add r7,sp,#0
 626              	.LCFI38:
 627              	 .cfi_def_cfa_register 7
 628 0006 7860     	 str r0,[r7,#4]
 576:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
 577:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 629              	 .loc 1 577 0
 630 0008 7B68     	 ldr r3,[r7,#4]
 631 000a 3B61     	 str r3,[r7,#16]
 578:../Dave/Generated/FREERTOS/queue.c **** 
 579:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( pxMutex );
 632              	 .loc 1 579 0
 633 000c 3B69     	 ldr r3,[r7,#16]
 634 000e 002B     	 cmp r3,#0
 635 0010 09D1     	 bne .L34
 636              	.LBB114:
 637              	.LBB115:
 638              	 .loc 2 195 0 discriminator 1
 639              	
 640 0012 4FF0FC03 	 mov r3,#252
 641 0016 83F31188 	 msr basepri,r3
 642 001a BFF36F8F 	 isb 
 643 001e BFF34F8F 	 dsb 
 644              	
 645              	
 646              	 .thumb
 647 0022 FB60     	 str r3,[r7,#12]
 648              	.L35:
 649              	.LBE115:
 650              	.LBE114:
 651              	 .loc 1 579 0 discriminator 1
 652 0024 FEE7     	 b .L35
 653              	.L34:
 580:../Dave/Generated/FREERTOS/queue.c **** 
 581:../Dave/Generated/FREERTOS/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 582:../Dave/Generated/FREERTOS/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 583:../Dave/Generated/FREERTOS/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 584:../Dave/Generated/FREERTOS/queue.c **** 		this is the only condition we are interested in it does not matter if
 585:../Dave/Generated/FREERTOS/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 586:../Dave/Generated/FREERTOS/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 587:../Dave/Generated/FREERTOS/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redunda
 654              	 .loc 1 587 0
 655 0026 3B69     	 ldr r3,[r7,#16]
 656 0028 5C68     	 ldr r4,[r3,#4]
 657 002a FFF7FEFF 	 bl xTaskGetCurrentTaskHandle
 658 002e 0346     	 mov r3,r0
 659 0030 9C42     	 cmp r4,r3
 660 0032 11D1     	 bne .L36
 588:../Dave/Generated/FREERTOS/queue.c **** 		{
 589:../Dave/Generated/FREERTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 590:../Dave/Generated/FREERTOS/queue.c **** 
 591:../Dave/Generated/FREERTOS/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 592:../Dave/Generated/FREERTOS/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 593:../Dave/Generated/FREERTOS/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 594:../Dave/Generated/FREERTOS/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 595:../Dave/Generated/FREERTOS/queue.c **** 			uxRecursiveCallCount member. */
 596:../Dave/Generated/FREERTOS/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )--;
 661              	 .loc 1 596 0
 662 0034 3B69     	 ldr r3,[r7,#16]
 663 0036 DB68     	 ldr r3,[r3,#12]
 664 0038 5A1E     	 subs r2,r3,#1
 665 003a 3B69     	 ldr r3,[r7,#16]
 666 003c DA60     	 str r2,[r3,#12]
 597:../Dave/Generated/FREERTOS/queue.c **** 
 598:../Dave/Generated/FREERTOS/queue.c **** 			/* Has the recursive call count unwound to 0? */
 599:../Dave/Generated/FREERTOS/queue.c **** 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 667              	 .loc 1 599 0
 668 003e 3B69     	 ldr r3,[r7,#16]
 669 0040 DB68     	 ldr r3,[r3,#12]
 670 0042 002B     	 cmp r3,#0
 671 0044 05D1     	 bne .L37
 600:../Dave/Generated/FREERTOS/queue.c **** 			{
 601:../Dave/Generated/FREERTOS/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 602:../Dave/Generated/FREERTOS/queue.c **** 				task that might be waiting to access the mutex. */
 603:../Dave/Generated/FREERTOS/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 672              	 .loc 1 603 0
 673 0046 3869     	 ldr r0,[r7,#16]
 674 0048 0021     	 movs r1,#0
 675 004a 0022     	 movs r2,#0
 676 004c 0023     	 movs r3,#0
 677 004e FFF7FEFF 	 bl xQueueGenericSend
 678              	.L37:
 604:../Dave/Generated/FREERTOS/queue.c **** 			}
 605:../Dave/Generated/FREERTOS/queue.c **** 			else
 606:../Dave/Generated/FREERTOS/queue.c **** 			{
 607:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 608:../Dave/Generated/FREERTOS/queue.c **** 			}
 609:../Dave/Generated/FREERTOS/queue.c **** 
 610:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 679              	 .loc 1 610 0
 680 0052 0123     	 movs r3,#1
 681 0054 7B61     	 str r3,[r7,#20]
 682 0056 01E0     	 b .L38
 683              	.L36:
 611:../Dave/Generated/FREERTOS/queue.c **** 		}
 612:../Dave/Generated/FREERTOS/queue.c **** 		else
 613:../Dave/Generated/FREERTOS/queue.c **** 		{
 614:../Dave/Generated/FREERTOS/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 615:../Dave/Generated/FREERTOS/queue.c **** 			holder. */
 616:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
 684              	 .loc 1 616 0
 685 0058 0023     	 movs r3,#0
 686 005a 7B61     	 str r3,[r7,#20]
 687              	.L38:
 617:../Dave/Generated/FREERTOS/queue.c **** 
 618:../Dave/Generated/FREERTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 619:../Dave/Generated/FREERTOS/queue.c **** 		}
 620:../Dave/Generated/FREERTOS/queue.c **** 
 621:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 688              	 .loc 1 621 0
 689 005c 7B69     	 ldr r3,[r7,#20]
 622:../Dave/Generated/FREERTOS/queue.c **** 	}
 690              	 .loc 1 622 0
 691 005e 1846     	 mov r0,r3
 692 0060 1C37     	 adds r7,r7,#28
 693              	.LCFI39:
 694              	 .cfi_def_cfa_offset 12
 695 0062 BD46     	 mov sp,r7
 696              	.LCFI40:
 697              	 .cfi_def_cfa_register 13
 698              	 
 699 0064 90BD     	 pop {r4,r7,pc}
 700              	 .cfi_endproc
 701              	.LFE142:
 703 0066 00BF     	 .section .text.xQueueTakeMutexRecursive,"ax",%progbits
 704              	 .align 2
 705              	 .global xQueueTakeMutexRecursive
 706              	 .thumb
 707              	 .thumb_func
 709              	xQueueTakeMutexRecursive:
 710              	.LFB143:
 623:../Dave/Generated/FREERTOS/queue.c **** 
 624:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 625:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 626:../Dave/Generated/FREERTOS/queue.c **** 
 627:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 628:../Dave/Generated/FREERTOS/queue.c **** 
 629:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 630:../Dave/Generated/FREERTOS/queue.c **** 	{
 711              	 .loc 1 630 0
 712              	 .cfi_startproc
 713              	 
 714              	 
 715 0000 90B5     	 push {r4,r7,lr}
 716              	.LCFI41:
 717              	 .cfi_def_cfa_offset 12
 718              	 .cfi_offset 4,-12
 719              	 .cfi_offset 7,-8
 720              	 .cfi_offset 14,-4
 721 0002 87B0     	 sub sp,sp,#28
 722              	.LCFI42:
 723              	 .cfi_def_cfa_offset 40
 724 0004 00AF     	 add r7,sp,#0
 725              	.LCFI43:
 726              	 .cfi_def_cfa_register 7
 727 0006 7860     	 str r0,[r7,#4]
 728 0008 3960     	 str r1,[r7]
 631:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
 632:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 729              	 .loc 1 632 0
 730 000a 7B68     	 ldr r3,[r7,#4]
 731 000c 3B61     	 str r3,[r7,#16]
 633:../Dave/Generated/FREERTOS/queue.c **** 
 634:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( pxMutex );
 732              	 .loc 1 634 0
 733 000e 3B69     	 ldr r3,[r7,#16]
 734 0010 002B     	 cmp r3,#0
 735 0012 09D1     	 bne .L41
 736              	.LBB116:
 737              	.LBB117:
 738              	 .loc 2 195 0 discriminator 1
 739              	
 740 0014 4FF0FC03 	 mov r3,#252
 741 0018 83F31188 	 msr basepri,r3
 742 001c BFF36F8F 	 isb 
 743 0020 BFF34F8F 	 dsb 
 744              	
 745              	
 746              	 .thumb
 747 0024 FB60     	 str r3,[r7,#12]
 748              	.L42:
 749              	.LBE117:
 750              	.LBE116:
 751              	 .loc 1 634 0 discriminator 1
 752 0026 FEE7     	 b .L42
 753              	.L41:
 635:../Dave/Generated/FREERTOS/queue.c **** 
 636:../Dave/Generated/FREERTOS/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 637:../Dave/Generated/FREERTOS/queue.c **** 		xQueueGiveMutexRecursive(). */
 638:../Dave/Generated/FREERTOS/queue.c **** 
 639:../Dave/Generated/FREERTOS/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 640:../Dave/Generated/FREERTOS/queue.c **** 
 641:../Dave/Generated/FREERTOS/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not r
 754              	 .loc 1 641 0
 755 0028 3B69     	 ldr r3,[r7,#16]
 756 002a 5C68     	 ldr r4,[r3,#4]
 757 002c FFF7FEFF 	 bl xTaskGetCurrentTaskHandle
 758 0030 0346     	 mov r3,r0
 759 0032 9C42     	 cmp r4,r3
 760 0034 07D1     	 bne .L43
 642:../Dave/Generated/FREERTOS/queue.c **** 		{
 643:../Dave/Generated/FREERTOS/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )++;
 761              	 .loc 1 643 0
 762 0036 3B69     	 ldr r3,[r7,#16]
 763 0038 DB68     	 ldr r3,[r3,#12]
 764 003a 5A1C     	 adds r2,r3,#1
 765 003c 3B69     	 ldr r3,[r7,#16]
 766 003e DA60     	 str r2,[r3,#12]
 644:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 767              	 .loc 1 644 0
 768 0040 0123     	 movs r3,#1
 769 0042 7B61     	 str r3,[r7,#20]
 770 0044 0CE0     	 b .L44
 771              	.L43:
 645:../Dave/Generated/FREERTOS/queue.c **** 		}
 646:../Dave/Generated/FREERTOS/queue.c **** 		else
 647:../Dave/Generated/FREERTOS/queue.c **** 		{
 648:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 772              	 .loc 1 648 0
 773 0046 3869     	 ldr r0,[r7,#16]
 774 0048 3968     	 ldr r1,[r7]
 775 004a FFF7FEFF 	 bl xQueueSemaphoreTake
 776 004e 7861     	 str r0,[r7,#20]
 649:../Dave/Generated/FREERTOS/queue.c **** 
 650:../Dave/Generated/FREERTOS/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 651:../Dave/Generated/FREERTOS/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 652:../Dave/Generated/FREERTOS/queue.c **** 			before reaching here. */
 653:../Dave/Generated/FREERTOS/queue.c **** 			if( xReturn != pdFAIL )
 777              	 .loc 1 653 0
 778 0050 7B69     	 ldr r3,[r7,#20]
 779 0052 002B     	 cmp r3,#0
 780 0054 04D0     	 beq .L44
 654:../Dave/Generated/FREERTOS/queue.c **** 			{
 655:../Dave/Generated/FREERTOS/queue.c **** 				( pxMutex->u.uxRecursiveCallCount )++;
 781              	 .loc 1 655 0
 782 0056 3B69     	 ldr r3,[r7,#16]
 783 0058 DB68     	 ldr r3,[r3,#12]
 784 005a 5A1C     	 adds r2,r3,#1
 785 005c 3B69     	 ldr r3,[r7,#16]
 786 005e DA60     	 str r2,[r3,#12]
 787              	.L44:
 656:../Dave/Generated/FREERTOS/queue.c **** 			}
 657:../Dave/Generated/FREERTOS/queue.c **** 			else
 658:../Dave/Generated/FREERTOS/queue.c **** 			{
 659:../Dave/Generated/FREERTOS/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 660:../Dave/Generated/FREERTOS/queue.c **** 			}
 661:../Dave/Generated/FREERTOS/queue.c **** 		}
 662:../Dave/Generated/FREERTOS/queue.c **** 
 663:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 788              	 .loc 1 663 0
 789 0060 7B69     	 ldr r3,[r7,#20]
 664:../Dave/Generated/FREERTOS/queue.c **** 	}
 790              	 .loc 1 664 0
 791 0062 1846     	 mov r0,r3
 792 0064 1C37     	 adds r7,r7,#28
 793              	.LCFI44:
 794              	 .cfi_def_cfa_offset 12
 795 0066 BD46     	 mov sp,r7
 796              	.LCFI45:
 797              	 .cfi_def_cfa_register 13
 798              	 
 799 0068 90BD     	 pop {r4,r7,pc}
 800              	 .cfi_endproc
 801              	.LFE143:
 803 006a 00BF     	 .section .text.xQueueCreateCountingSemaphore,"ax",%progbits
 804              	 .align 2
 805              	 .global xQueueCreateCountingSemaphore
 806              	 .thumb
 807              	 .thumb_func
 809              	xQueueCreateCountingSemaphore:
 810              	.LFB144:
 665:../Dave/Generated/FREERTOS/queue.c **** 
 666:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 667:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 668:../Dave/Generated/FREERTOS/queue.c **** 
 669:../Dave/Generated/FREERTOS/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 670:../Dave/Generated/FREERTOS/queue.c **** 
 671:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 672:../Dave/Generated/FREERTOS/queue.c **** 	{
 673:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xHandle;
 674:../Dave/Generated/FREERTOS/queue.c **** 
 675:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxMaxCount != 0 );
 676:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 677:../Dave/Generated/FREERTOS/queue.c **** 
 678:../Dave/Generated/FREERTOS/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 679:../Dave/Generated/FREERTOS/queue.c **** 
 680:../Dave/Generated/FREERTOS/queue.c **** 		if( xHandle != NULL )
 681:../Dave/Generated/FREERTOS/queue.c **** 		{
 682:../Dave/Generated/FREERTOS/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 683:../Dave/Generated/FREERTOS/queue.c **** 
 684:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 685:../Dave/Generated/FREERTOS/queue.c **** 		}
 686:../Dave/Generated/FREERTOS/queue.c **** 		else
 687:../Dave/Generated/FREERTOS/queue.c **** 		{
 688:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 689:../Dave/Generated/FREERTOS/queue.c **** 		}
 690:../Dave/Generated/FREERTOS/queue.c **** 
 691:../Dave/Generated/FREERTOS/queue.c **** 		return xHandle;
 692:../Dave/Generated/FREERTOS/queue.c **** 	}
 693:../Dave/Generated/FREERTOS/queue.c **** 
 694:../Dave/Generated/FREERTOS/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 695:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 696:../Dave/Generated/FREERTOS/queue.c **** 
 697:../Dave/Generated/FREERTOS/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 698:../Dave/Generated/FREERTOS/queue.c **** 
 699:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 700:../Dave/Generated/FREERTOS/queue.c **** 	{
 811              	 .loc 1 700 0
 812              	 .cfi_startproc
 813              	 
 814              	 
 815 0000 80B5     	 push {r7,lr}
 816              	.LCFI46:
 817              	 .cfi_def_cfa_offset 8
 818              	 .cfi_offset 7,-8
 819              	 .cfi_offset 14,-4
 820 0002 86B0     	 sub sp,sp,#24
 821              	.LCFI47:
 822              	 .cfi_def_cfa_offset 32
 823 0004 00AF     	 add r7,sp,#0
 824              	.LCFI48:
 825              	 .cfi_def_cfa_register 7
 826 0006 7860     	 str r0,[r7,#4]
 827 0008 3960     	 str r1,[r7]
 701:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xHandle;
 702:../Dave/Generated/FREERTOS/queue.c **** 
 703:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxMaxCount != 0 );
 828              	 .loc 1 703 0
 829 000a 7B68     	 ldr r3,[r7,#4]
 830 000c 002B     	 cmp r3,#0
 831 000e 09D1     	 bne .L47
 832              	.LBB118:
 833              	.LBB119:
 834              	 .loc 2 195 0 discriminator 1
 835              	
 836 0010 4FF0FC03 	 mov r3,#252
 837 0014 83F31188 	 msr basepri,r3
 838 0018 BFF36F8F 	 isb 
 839 001c BFF34F8F 	 dsb 
 840              	
 841              	
 842              	 .thumb
 843 0020 3B61     	 str r3,[r7,#16]
 844              	.L48:
 845              	.LBE119:
 846              	.LBE118:
 847              	 .loc 1 703 0 discriminator 1
 848 0022 FEE7     	 b .L48
 849              	.L47:
 704:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 850              	 .loc 1 704 0
 851 0024 3A68     	 ldr r2,[r7]
 852 0026 7B68     	 ldr r3,[r7,#4]
 853 0028 9A42     	 cmp r2,r3
 854 002a 09D9     	 bls .L49
 855              	.LBB120:
 856              	.LBB121:
 857              	 .loc 2 195 0 discriminator 1
 858              	
 859 002c 4FF0FC03 	 mov r3,#252
 860 0030 83F31188 	 msr basepri,r3
 861 0034 BFF36F8F 	 isb 
 862 0038 BFF34F8F 	 dsb 
 863              	
 864              	
 865              	 .thumb
 866 003c FB60     	 str r3,[r7,#12]
 867              	.L50:
 868              	.LBE121:
 869              	.LBE120:
 870              	 .loc 1 704 0 discriminator 2
 871 003e FEE7     	 b .L50
 872              	.L49:
 705:../Dave/Generated/FREERTOS/queue.c **** 
 706:../Dave/Generated/FREERTOS/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 873              	 .loc 1 706 0
 874 0040 7868     	 ldr r0,[r7,#4]
 875 0042 0021     	 movs r1,#0
 876 0044 0222     	 movs r2,#2
 877 0046 FFF7FEFF 	 bl xQueueGenericCreate
 878 004a 7861     	 str r0,[r7,#20]
 707:../Dave/Generated/FREERTOS/queue.c **** 
 708:../Dave/Generated/FREERTOS/queue.c **** 		if( xHandle != NULL )
 879              	 .loc 1 708 0
 880 004c 7B69     	 ldr r3,[r7,#20]
 881 004e 002B     	 cmp r3,#0
 882 0050 02D0     	 beq .L51
 709:../Dave/Generated/FREERTOS/queue.c **** 		{
 710:../Dave/Generated/FREERTOS/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 883              	 .loc 1 710 0
 884 0052 7B69     	 ldr r3,[r7,#20]
 885 0054 3A68     	 ldr r2,[r7]
 886 0056 9A63     	 str r2,[r3,#56]
 887              	.L51:
 711:../Dave/Generated/FREERTOS/queue.c **** 
 712:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 713:../Dave/Generated/FREERTOS/queue.c **** 		}
 714:../Dave/Generated/FREERTOS/queue.c **** 		else
 715:../Dave/Generated/FREERTOS/queue.c **** 		{
 716:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 717:../Dave/Generated/FREERTOS/queue.c **** 		}
 718:../Dave/Generated/FREERTOS/queue.c **** 
 719:../Dave/Generated/FREERTOS/queue.c **** 		return xHandle;
 888              	 .loc 1 719 0
 889 0058 7B69     	 ldr r3,[r7,#20]
 720:../Dave/Generated/FREERTOS/queue.c **** 	}
 890              	 .loc 1 720 0
 891 005a 1846     	 mov r0,r3
 892 005c 1837     	 adds r7,r7,#24
 893              	.LCFI49:
 894              	 .cfi_def_cfa_offset 8
 895 005e BD46     	 mov sp,r7
 896              	.LCFI50:
 897              	 .cfi_def_cfa_register 13
 898              	 
 899 0060 80BD     	 pop {r7,pc}
 900              	 .cfi_endproc
 901              	.LFE144:
 903 0062 00BF     	 .section .text.xQueueGenericSend,"ax",%progbits
 904              	 .align 2
 905              	 .global xQueueGenericSend
 906              	 .thumb
 907              	 .thumb_func
 909              	xQueueGenericSend:
 910              	.LFB145:
 721:../Dave/Generated/FREERTOS/queue.c **** 
 722:../Dave/Generated/FREERTOS/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 723:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 724:../Dave/Generated/FREERTOS/queue.c **** 
 725:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 726:../Dave/Generated/FREERTOS/queue.c **** {
 911              	 .loc 1 726 0
 912              	 .cfi_startproc
 913              	 
 914              	 
 915 0000 80B5     	 push {r7,lr}
 916              	.LCFI51:
 917              	 .cfi_def_cfa_offset 8
 918              	 .cfi_offset 7,-8
 919              	 .cfi_offset 14,-4
 920 0002 8EB0     	 sub sp,sp,#56
 921              	.LCFI52:
 922              	 .cfi_def_cfa_offset 64
 923 0004 00AF     	 add r7,sp,#0
 924              	.LCFI53:
 925              	 .cfi_def_cfa_register 7
 926 0006 F860     	 str r0,[r7,#12]
 927 0008 B960     	 str r1,[r7,#8]
 928 000a 7A60     	 str r2,[r7,#4]
 929 000c 3B60     	 str r3,[r7]
 727:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 930              	 .loc 1 727 0
 931 000e 0023     	 movs r3,#0
 932 0010 7B63     	 str r3,[r7,#52]
 728:../Dave/Generated/FREERTOS/queue.c **** TimeOut_t xTimeOut;
 729:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 933              	 .loc 1 729 0
 934 0012 FB68     	 ldr r3,[r7,#12]
 935 0014 3B63     	 str r3,[r7,#48]
 730:../Dave/Generated/FREERTOS/queue.c **** 
 731:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 936              	 .loc 1 731 0
 937 0016 3B6B     	 ldr r3,[r7,#48]
 938 0018 002B     	 cmp r3,#0
 939 001a 09D1     	 bne .L54
 940              	.LBB122:
 941              	.LBB123:
 942              	 .loc 2 195 0 discriminator 1
 943              	
 944 001c 4FF0FC03 	 mov r3,#252
 945 0020 83F31188 	 msr basepri,r3
 946 0024 BFF36F8F 	 isb 
 947 0028 BFF34F8F 	 dsb 
 948              	
 949              	
 950              	 .thumb
 951 002c BB62     	 str r3,[r7,#40]
 952              	.L55:
 953              	.LBE123:
 954              	.LBE122:
 955              	 .loc 1 731 0 discriminator 1
 956 002e FEE7     	 b .L55
 957              	.L54:
 732:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 958              	 .loc 1 732 0
 959 0030 BB68     	 ldr r3,[r7,#8]
 960 0032 002B     	 cmp r3,#0
 961 0034 03D1     	 bne .L56
 962              	 .loc 1 732 0 is_stmt 0 discriminator 2
 963 0036 3B6B     	 ldr r3,[r7,#48]
 964 0038 1B6C     	 ldr r3,[r3,#64]
 965 003a 002B     	 cmp r3,#0
 966 003c 01D1     	 bne .L57
 967              	.L56:
 968              	 .loc 1 732 0 discriminator 3
 969 003e 0123     	 movs r3,#1
 970 0040 00E0     	 b .L58
 971              	.L57:
 972              	 .loc 1 732 0 discriminator 4
 973 0042 0023     	 movs r3,#0
 974              	.L58:
 975              	 .loc 1 732 0 discriminator 6
 976 0044 002B     	 cmp r3,#0
 977 0046 09D1     	 bne .L59
 978              	.LBB124:
 979              	.LBB125:
 980              	 .loc 2 195 0 is_stmt 1 discriminator 7
 981              	
 982 0048 4FF0FC03 	 mov r3,#252
 983 004c 83F31188 	 msr basepri,r3
 984 0050 BFF36F8F 	 isb 
 985 0054 BFF34F8F 	 dsb 
 986              	
 987              	
 988              	 .thumb
 989 0058 7B62     	 str r3,[r7,#36]
 990              	.L60:
 991              	.LBE125:
 992              	.LBE124:
 993              	 .loc 1 732 0 discriminator 2
 994 005a FEE7     	 b .L60
 995              	.L59:
 733:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 996              	 .loc 1 733 0
 997 005c 3B68     	 ldr r3,[r7]
 998 005e 022B     	 cmp r3,#2
 999 0060 03D1     	 bne .L61
 1000              	 .loc 1 733 0 is_stmt 0 discriminator 2
 1001 0062 3B6B     	 ldr r3,[r7,#48]
 1002 0064 DB6B     	 ldr r3,[r3,#60]
 1003 0066 012B     	 cmp r3,#1
 1004 0068 01D1     	 bne .L62
 1005              	.L61:
 1006              	 .loc 1 733 0 discriminator 3
 1007 006a 0123     	 movs r3,#1
 1008 006c 00E0     	 b .L63
 1009              	.L62:
 1010              	 .loc 1 733 0 discriminator 4
 1011 006e 0023     	 movs r3,#0
 1012              	.L63:
 1013              	 .loc 1 733 0 discriminator 6
 1014 0070 002B     	 cmp r3,#0
 1015 0072 09D1     	 bne .L64
 1016              	.LBB126:
 1017              	.LBB127:
 1018              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1019              	
 1020 0074 4FF0FC03 	 mov r3,#252
 1021 0078 83F31188 	 msr basepri,r3
 1022 007c BFF36F8F 	 isb 
 1023 0080 BFF34F8F 	 dsb 
 1024              	
 1025              	
 1026              	 .thumb
 1027 0084 3B62     	 str r3,[r7,#32]
 1028              	.L65:
 1029              	.LBE127:
 1030              	.LBE126:
 1031              	 .loc 1 733 0 discriminator 3
 1032 0086 FEE7     	 b .L65
 1033              	.L64:
 734:../Dave/Generated/FREERTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 735:../Dave/Generated/FREERTOS/queue.c **** 	{
 736:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 1034              	 .loc 1 736 0
 1035 0088 FFF7FEFF 	 bl xTaskGetSchedulerState
 1036 008c 0346     	 mov r3,r0
 1037 008e 002B     	 cmp r3,#0
 1038 0090 02D1     	 bne .L66
 1039              	 .loc 1 736 0 is_stmt 0 discriminator 2
 1040 0092 7B68     	 ldr r3,[r7,#4]
 1041 0094 002B     	 cmp r3,#0
 1042 0096 01D1     	 bne .L67
 1043              	.L66:
 1044              	 .loc 1 736 0 discriminator 3
 1045 0098 0123     	 movs r3,#1
 1046 009a 00E0     	 b .L68
 1047              	.L67:
 1048              	 .loc 1 736 0 discriminator 4
 1049 009c 0023     	 movs r3,#0
 1050              	.L68:
 1051              	 .loc 1 736 0 discriminator 6
 1052 009e 002B     	 cmp r3,#0
 1053 00a0 09D1     	 bne .L69
 1054              	.LBB128:
 1055              	.LBB129:
 1056              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1057              	
 1058 00a2 4FF0FC03 	 mov r3,#252
 1059 00a6 83F31188 	 msr basepri,r3
 1060 00aa BFF36F8F 	 isb 
 1061 00ae BFF34F8F 	 dsb 
 1062              	
 1063              	
 1064              	 .thumb
 1065 00b2 FB61     	 str r3,[r7,#28]
 1066              	.L70:
 1067              	.LBE129:
 1068              	.LBE128:
 1069              	 .loc 1 736 0 discriminator 4
 1070 00b4 FEE7     	 b .L70
 1071              	.L69:
 737:../Dave/Generated/FREERTOS/queue.c **** 	}
 738:../Dave/Generated/FREERTOS/queue.c **** 	#endif
 739:../Dave/Generated/FREERTOS/queue.c **** 
 740:../Dave/Generated/FREERTOS/queue.c **** 
 741:../Dave/Generated/FREERTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 742:../Dave/Generated/FREERTOS/queue.c **** 	statements within the function itself.  This is done in the interest
 743:../Dave/Generated/FREERTOS/queue.c **** 	of execution time efficiency. */
 744:../Dave/Generated/FREERTOS/queue.c **** 	for( ;; )
 745:../Dave/Generated/FREERTOS/queue.c **** 	{
 746:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 1072              	 .loc 1 746 0
 1073 00b6 FFF7FEFF 	 bl vPortEnterCritical
 747:../Dave/Generated/FREERTOS/queue.c **** 		{
 748:../Dave/Generated/FREERTOS/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 749:../Dave/Generated/FREERTOS/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 750:../Dave/Generated/FREERTOS/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 751:../Dave/Generated/FREERTOS/queue.c **** 			queue is full. */
 752:../Dave/Generated/FREERTOS/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 1074              	 .loc 1 752 0
 1075 00ba 3B6B     	 ldr r3,[r7,#48]
 1076 00bc 9A6B     	 ldr r2,[r3,#56]
 1077 00be 3B6B     	 ldr r3,[r7,#48]
 1078 00c0 DB6B     	 ldr r3,[r3,#60]
 1079 00c2 9A42     	 cmp r2,r3
 1080 00c4 02D3     	 bcc .L71
 1081              	 .loc 1 752 0 is_stmt 0 discriminator 1
 1082 00c6 3B68     	 ldr r3,[r7]
 1083 00c8 022B     	 cmp r3,#2
 1084 00ca 3DD1     	 bne .L72
 1085              	.L71:
 753:../Dave/Generated/FREERTOS/queue.c **** 			{
 754:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_SEND( pxQueue );
 755:../Dave/Generated/FREERTOS/queue.c **** 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1086              	 .loc 1 755 0 is_stmt 1
 1087 00cc 386B     	 ldr r0,[r7,#48]
 1088 00ce B968     	 ldr r1,[r7,#8]
 1089 00d0 3A68     	 ldr r2,[r7]
 1090 00d2 FFF7FEFF 	 bl prvCopyDataToQueue
 1091 00d6 F862     	 str r0,[r7,#44]
 756:../Dave/Generated/FREERTOS/queue.c **** 
 757:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 758:../Dave/Generated/FREERTOS/queue.c **** 				{
 759:../Dave/Generated/FREERTOS/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 1092              	 .loc 1 759 0
 1093 00d8 3B6B     	 ldr r3,[r7,#48]
 1094 00da 9B6C     	 ldr r3,[r3,#72]
 1095 00dc 002B     	 cmp r3,#0
 1096 00de 0FD0     	 beq .L73
 760:../Dave/Generated/FREERTOS/queue.c **** 					{
 761:../Dave/Generated/FREERTOS/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 1097              	 .loc 1 761 0
 1098 00e0 386B     	 ldr r0,[r7,#48]
 1099 00e2 3968     	 ldr r1,[r7]
 1100 00e4 FFF7FEFF 	 bl prvNotifyQueueSetContainer
 1101 00e8 0346     	 mov r3,r0
 1102 00ea 002B     	 cmp r3,#0
 1103 00ec 28D0     	 beq .L74
 762:../Dave/Generated/FREERTOS/queue.c **** 						{
 763:../Dave/Generated/FREERTOS/queue.c **** 							/* The queue is a member of a queue set, and posting
 764:../Dave/Generated/FREERTOS/queue.c **** 							to the queue set caused a higher priority task to
 765:../Dave/Generated/FREERTOS/queue.c **** 							unblock. A context switch is required. */
 766:../Dave/Generated/FREERTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1104              	 .loc 1 766 0
 1105 00ee 4C4B     	 ldr r3,.L87
 1106 00f0 4FF08052 	 mov r2,#268435456
 1107 00f4 1A60     	 str r2,[r3]
 1108              	
 1109 00f6 BFF34F8F 	 dsb
 1110              	
 1111              	
 1112 00fa BFF36F8F 	 isb
 1113              	
 1114              	 .thumb
 1115 00fe 1FE0     	 b .L74
 1116              	.L73:
 767:../Dave/Generated/FREERTOS/queue.c **** 						}
 768:../Dave/Generated/FREERTOS/queue.c **** 						else
 769:../Dave/Generated/FREERTOS/queue.c **** 						{
 770:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 771:../Dave/Generated/FREERTOS/queue.c **** 						}
 772:../Dave/Generated/FREERTOS/queue.c **** 					}
 773:../Dave/Generated/FREERTOS/queue.c **** 					else
 774:../Dave/Generated/FREERTOS/queue.c **** 					{
 775:../Dave/Generated/FREERTOS/queue.c **** 						/* If there was a task waiting for data to arrive on the
 776:../Dave/Generated/FREERTOS/queue.c **** 						queue then unblock it now. */
 777:../Dave/Generated/FREERTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1117              	 .loc 1 777 0
 1118 0100 3B6B     	 ldr r3,[r7,#48]
 1119 0102 5B6A     	 ldr r3,[r3,#36]
 1120 0104 002B     	 cmp r3,#0
 1121 0106 10D0     	 beq .L75
 778:../Dave/Generated/FREERTOS/queue.c **** 						{
 779:../Dave/Generated/FREERTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1122              	 .loc 1 779 0
 1123 0108 3B6B     	 ldr r3,[r7,#48]
 1124 010a 2433     	 adds r3,r3,#36
 1125 010c 1846     	 mov r0,r3
 1126 010e FFF7FEFF 	 bl xTaskRemoveFromEventList
 1127 0112 0346     	 mov r3,r0
 1128 0114 002B     	 cmp r3,#0
 1129 0116 13D0     	 beq .L74
 780:../Dave/Generated/FREERTOS/queue.c **** 							{
 781:../Dave/Generated/FREERTOS/queue.c **** 								/* The unblocked task has a priority higher than
 782:../Dave/Generated/FREERTOS/queue.c **** 								our own so yield immediately.  Yes it is ok to
 783:../Dave/Generated/FREERTOS/queue.c **** 								do this from within the critical section - the
 784:../Dave/Generated/FREERTOS/queue.c **** 								kernel takes care of that. */
 785:../Dave/Generated/FREERTOS/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 1130              	 .loc 1 785 0
 1131 0118 414B     	 ldr r3,.L87
 1132 011a 4FF08052 	 mov r2,#268435456
 1133 011e 1A60     	 str r2,[r3]
 1134              	
 1135 0120 BFF34F8F 	 dsb
 1136              	
 1137              	
 1138 0124 BFF36F8F 	 isb
 1139              	
 1140              	 .thumb
 1141 0128 0AE0     	 b .L74
 1142              	.L75:
 786:../Dave/Generated/FREERTOS/queue.c **** 							}
 787:../Dave/Generated/FREERTOS/queue.c **** 							else
 788:../Dave/Generated/FREERTOS/queue.c **** 							{
 789:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 790:../Dave/Generated/FREERTOS/queue.c **** 							}
 791:../Dave/Generated/FREERTOS/queue.c **** 						}
 792:../Dave/Generated/FREERTOS/queue.c **** 						else if( xYieldRequired != pdFALSE )
 1143              	 .loc 1 792 0
 1144 012a FB6A     	 ldr r3,[r7,#44]
 1145 012c 002B     	 cmp r3,#0
 1146 012e 07D0     	 beq .L74
 793:../Dave/Generated/FREERTOS/queue.c **** 						{
 794:../Dave/Generated/FREERTOS/queue.c **** 							/* This path is a special case that will only get
 795:../Dave/Generated/FREERTOS/queue.c **** 							executed if the task was holding multiple mutexes
 796:../Dave/Generated/FREERTOS/queue.c **** 							and the mutexes were given back in an order that is
 797:../Dave/Generated/FREERTOS/queue.c **** 							different to that in which they were taken. */
 798:../Dave/Generated/FREERTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1147              	 .loc 1 798 0
 1148 0130 3B4B     	 ldr r3,.L87
 1149 0132 4FF08052 	 mov r2,#268435456
 1150 0136 1A60     	 str r2,[r3]
 1151              	
 1152 0138 BFF34F8F 	 dsb
 1153              	
 1154              	
 1155 013c BFF36F8F 	 isb
 1156              	
 1157              	 .thumb
 1158              	.L74:
 799:../Dave/Generated/FREERTOS/queue.c **** 						}
 800:../Dave/Generated/FREERTOS/queue.c **** 						else
 801:../Dave/Generated/FREERTOS/queue.c **** 						{
 802:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 803:../Dave/Generated/FREERTOS/queue.c **** 						}
 804:../Dave/Generated/FREERTOS/queue.c **** 					}
 805:../Dave/Generated/FREERTOS/queue.c **** 				}
 806:../Dave/Generated/FREERTOS/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 807:../Dave/Generated/FREERTOS/queue.c **** 				{
 808:../Dave/Generated/FREERTOS/queue.c **** 					/* If there was a task waiting for data to arrive on the
 809:../Dave/Generated/FREERTOS/queue.c **** 					queue then unblock it now. */
 810:../Dave/Generated/FREERTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 811:../Dave/Generated/FREERTOS/queue.c **** 					{
 812:../Dave/Generated/FREERTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 813:../Dave/Generated/FREERTOS/queue.c **** 						{
 814:../Dave/Generated/FREERTOS/queue.c **** 							/* The unblocked task has a priority higher than
 815:../Dave/Generated/FREERTOS/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 816:../Dave/Generated/FREERTOS/queue.c **** 							this from within the critical section - the kernel
 817:../Dave/Generated/FREERTOS/queue.c **** 							takes care of that. */
 818:../Dave/Generated/FREERTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 819:../Dave/Generated/FREERTOS/queue.c **** 						}
 820:../Dave/Generated/FREERTOS/queue.c **** 						else
 821:../Dave/Generated/FREERTOS/queue.c **** 						{
 822:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 823:../Dave/Generated/FREERTOS/queue.c **** 						}
 824:../Dave/Generated/FREERTOS/queue.c **** 					}
 825:../Dave/Generated/FREERTOS/queue.c **** 					else if( xYieldRequired != pdFALSE )
 826:../Dave/Generated/FREERTOS/queue.c **** 					{
 827:../Dave/Generated/FREERTOS/queue.c **** 						/* This path is a special case that will only get
 828:../Dave/Generated/FREERTOS/queue.c **** 						executed if the task was holding multiple mutexes and
 829:../Dave/Generated/FREERTOS/queue.c **** 						the mutexes were given back in an order that is
 830:../Dave/Generated/FREERTOS/queue.c **** 						different to that in which they were taken. */
 831:../Dave/Generated/FREERTOS/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 832:../Dave/Generated/FREERTOS/queue.c **** 					}
 833:../Dave/Generated/FREERTOS/queue.c **** 					else
 834:../Dave/Generated/FREERTOS/queue.c **** 					{
 835:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 836:../Dave/Generated/FREERTOS/queue.c **** 					}
 837:../Dave/Generated/FREERTOS/queue.c **** 				}
 838:../Dave/Generated/FREERTOS/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 839:../Dave/Generated/FREERTOS/queue.c **** 
 840:../Dave/Generated/FREERTOS/queue.c **** 				taskEXIT_CRITICAL();
 1159              	 .loc 1 840 0
 1160 0140 FFF7FEFF 	 bl vPortExitCritical
 841:../Dave/Generated/FREERTOS/queue.c **** 				return pdPASS;
 1161              	 .loc 1 841 0
 1162 0144 0123     	 movs r3,#1
 1163 0146 67E0     	 b .L86
 1164              	.L72:
 842:../Dave/Generated/FREERTOS/queue.c **** 			}
 843:../Dave/Generated/FREERTOS/queue.c **** 			else
 844:../Dave/Generated/FREERTOS/queue.c **** 			{
 845:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1165              	 .loc 1 845 0
 1166 0148 7B68     	 ldr r3,[r7,#4]
 1167 014a 002B     	 cmp r3,#0
 1168 014c 03D1     	 bne .L77
 846:../Dave/Generated/FREERTOS/queue.c **** 				{
 847:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was full and no block time is specified (or
 848:../Dave/Generated/FREERTOS/queue.c **** 					the block time has expired) so leave now. */
 849:../Dave/Generated/FREERTOS/queue.c **** 					taskEXIT_CRITICAL();
 1169              	 .loc 1 849 0
 1170 014e FFF7FEFF 	 bl vPortExitCritical
 850:../Dave/Generated/FREERTOS/queue.c **** 
 851:../Dave/Generated/FREERTOS/queue.c **** 					/* Return to the original privilege level before exiting
 852:../Dave/Generated/FREERTOS/queue.c **** 					the function. */
 853:../Dave/Generated/FREERTOS/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 854:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_FULL;
 1171              	 .loc 1 854 0
 1172 0152 0023     	 movs r3,#0
 1173 0154 60E0     	 b .L86
 1174              	.L77:
 855:../Dave/Generated/FREERTOS/queue.c **** 				}
 856:../Dave/Generated/FREERTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1175              	 .loc 1 856 0
 1176 0156 7B6B     	 ldr r3,[r7,#52]
 1177 0158 002B     	 cmp r3,#0
 1178 015a 06D1     	 bne .L78
 857:../Dave/Generated/FREERTOS/queue.c **** 				{
 858:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was full and a block time was specified so
 859:../Dave/Generated/FREERTOS/queue.c **** 					configure the timeout structure. */
 860:../Dave/Generated/FREERTOS/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 1179              	 .loc 1 860 0
 1180 015c 07F11403 	 add r3,r7,#20
 1181 0160 1846     	 mov r0,r3
 1182 0162 FFF7FEFF 	 bl vTaskInternalSetTimeOutState
 861:../Dave/Generated/FREERTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 1183              	 .loc 1 861 0
 1184 0166 0123     	 movs r3,#1
 1185 0168 7B63     	 str r3,[r7,#52]
 1186              	.L78:
 862:../Dave/Generated/FREERTOS/queue.c **** 				}
 863:../Dave/Generated/FREERTOS/queue.c **** 				else
 864:../Dave/Generated/FREERTOS/queue.c **** 				{
 865:../Dave/Generated/FREERTOS/queue.c **** 					/* Entry time was already set. */
 866:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 867:../Dave/Generated/FREERTOS/queue.c **** 				}
 868:../Dave/Generated/FREERTOS/queue.c **** 			}
 869:../Dave/Generated/FREERTOS/queue.c **** 		}
 870:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 1187              	 .loc 1 870 0
 1188 016a FFF7FEFF 	 bl vPortExitCritical
 871:../Dave/Generated/FREERTOS/queue.c **** 
 872:../Dave/Generated/FREERTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 873:../Dave/Generated/FREERTOS/queue.c **** 		now the critical section has been exited. */
 874:../Dave/Generated/FREERTOS/queue.c **** 
 875:../Dave/Generated/FREERTOS/queue.c **** 		vTaskSuspendAll();
 1189              	 .loc 1 875 0
 1190 016e FFF7FEFF 	 bl vTaskSuspendAll
 876:../Dave/Generated/FREERTOS/queue.c **** 		prvLockQueue( pxQueue );
 1191              	 .loc 1 876 0
 1192 0172 FFF7FEFF 	 bl vPortEnterCritical
 1193 0176 3B6B     	 ldr r3,[r7,#48]
 1194 0178 93F84430 	 ldrb r3,[r3,#68]
 1195 017c DBB2     	 uxtb r3,r3
 1196 017e 5BB2     	 sxtb r3,r3
 1197 0180 B3F1FF3F 	 cmp r3,#-1
 1198 0184 03D1     	 bne .L79
 1199              	 .loc 1 876 0 is_stmt 0 discriminator 1
 1200 0186 3B6B     	 ldr r3,[r7,#48]
 1201 0188 0022     	 movs r2,#0
 1202 018a 83F84420 	 strb r2,[r3,#68]
 1203              	.L79:
 1204              	 .loc 1 876 0 discriminator 3
 1205 018e 3B6B     	 ldr r3,[r7,#48]
 1206 0190 93F84530 	 ldrb r3,[r3,#69]
 1207 0194 DBB2     	 uxtb r3,r3
 1208 0196 5BB2     	 sxtb r3,r3
 1209 0198 B3F1FF3F 	 cmp r3,#-1
 1210 019c 03D1     	 bne .L80
 1211              	 .loc 1 876 0 discriminator 4
 1212 019e 3B6B     	 ldr r3,[r7,#48]
 1213 01a0 0022     	 movs r2,#0
 1214 01a2 83F84520 	 strb r2,[r3,#69]
 1215              	.L80:
 1216              	 .loc 1 876 0 discriminator 6
 1217 01a6 FFF7FEFF 	 bl vPortExitCritical
 877:../Dave/Generated/FREERTOS/queue.c **** 
 878:../Dave/Generated/FREERTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 879:../Dave/Generated/FREERTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1218              	 .loc 1 879 0 is_stmt 1 discriminator 6
 1219 01aa 07F11402 	 add r2,r7,#20
 1220 01ae 3B1D     	 adds r3,r7,#4
 1221 01b0 1046     	 mov r0,r2
 1222 01b2 1946     	 mov r1,r3
 1223 01b4 FFF7FEFF 	 bl xTaskCheckForTimeOut
 1224 01b8 0346     	 mov r3,r0
 1225 01ba 002B     	 cmp r3,#0
 1226 01bc 24D1     	 bne .L81
 880:../Dave/Generated/FREERTOS/queue.c **** 		{
 881:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 1227              	 .loc 1 881 0
 1228 01be 386B     	 ldr r0,[r7,#48]
 1229 01c0 FFF7FEFF 	 bl prvIsQueueFull
 1230 01c4 0346     	 mov r3,r0
 1231 01c6 002B     	 cmp r3,#0
 1232 01c8 18D0     	 beq .L82
 882:../Dave/Generated/FREERTOS/queue.c **** 			{
 883:../Dave/Generated/FREERTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 884:../Dave/Generated/FREERTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 1233              	 .loc 1 884 0
 1234 01ca 3B6B     	 ldr r3,[r7,#48]
 1235 01cc 03F11002 	 add r2,r3,#16
 1236 01d0 7B68     	 ldr r3,[r7,#4]
 1237 01d2 1046     	 mov r0,r2
 1238 01d4 1946     	 mov r1,r3
 1239 01d6 FFF7FEFF 	 bl vTaskPlaceOnEventList
 885:../Dave/Generated/FREERTOS/queue.c **** 
 886:../Dave/Generated/FREERTOS/queue.c **** 				/* Unlocking the queue means queue events can effect the
 887:../Dave/Generated/FREERTOS/queue.c **** 				event list.  It is possible that interrupts occurring now
 888:../Dave/Generated/FREERTOS/queue.c **** 				remove this task from the event list again - but as the
 889:../Dave/Generated/FREERTOS/queue.c **** 				scheduler is suspended the task will go onto the pending
 890:../Dave/Generated/FREERTOS/queue.c **** 				ready last instead of the actual ready list. */
 891:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 1240              	 .loc 1 891 0
 1241 01da 386B     	 ldr r0,[r7,#48]
 1242 01dc FFF7FEFF 	 bl prvUnlockQueue
 892:../Dave/Generated/FREERTOS/queue.c **** 
 893:../Dave/Generated/FREERTOS/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 894:../Dave/Generated/FREERTOS/queue.c **** 				ready list into the ready list - so it is feasible that this
 895:../Dave/Generated/FREERTOS/queue.c **** 				task is already in a ready list before it yields - in which
 896:../Dave/Generated/FREERTOS/queue.c **** 				case the yield will not cause a context switch unless there
 897:../Dave/Generated/FREERTOS/queue.c **** 				is also a higher priority task in the pending ready list. */
 898:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1243              	 .loc 1 898 0
 1244 01e0 FFF7FEFF 	 bl xTaskResumeAll
 1245 01e4 0346     	 mov r3,r0
 1246 01e6 002B     	 cmp r3,#0
 1247 01e8 15D1     	 bne .L85
 899:../Dave/Generated/FREERTOS/queue.c **** 				{
 900:../Dave/Generated/FREERTOS/queue.c **** 					portYIELD_WITHIN_API();
 1248              	 .loc 1 900 0
 1249 01ea 0D4B     	 ldr r3,.L87
 1250 01ec 4FF08052 	 mov r2,#268435456
 1251 01f0 1A60     	 str r2,[r3]
 1252              	
 1253 01f2 BFF34F8F 	 dsb
 1254              	
 1255              	
 1256 01f6 BFF36F8F 	 isb
 1257              	
 1258              	 .thumb
 1259 01fa 0CE0     	 b .L85
 1260              	.L82:
 901:../Dave/Generated/FREERTOS/queue.c **** 				}
 902:../Dave/Generated/FREERTOS/queue.c **** 			}
 903:../Dave/Generated/FREERTOS/queue.c **** 			else
 904:../Dave/Generated/FREERTOS/queue.c **** 			{
 905:../Dave/Generated/FREERTOS/queue.c **** 				/* Try again. */
 906:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 1261              	 .loc 1 906 0
 1262 01fc 386B     	 ldr r0,[r7,#48]
 1263 01fe FFF7FEFF 	 bl prvUnlockQueue
 907:../Dave/Generated/FREERTOS/queue.c **** 				( void ) xTaskResumeAll();
 1264              	 .loc 1 907 0
 1265 0202 FFF7FEFF 	 bl xTaskResumeAll
 1266 0206 56E7     	 b .L69
 1267              	.L81:
 908:../Dave/Generated/FREERTOS/queue.c **** 			}
 909:../Dave/Generated/FREERTOS/queue.c **** 		}
 910:../Dave/Generated/FREERTOS/queue.c **** 		else
 911:../Dave/Generated/FREERTOS/queue.c **** 		{
 912:../Dave/Generated/FREERTOS/queue.c **** 			/* The timeout has expired. */
 913:../Dave/Generated/FREERTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 1268              	 .loc 1 913 0
 1269 0208 386B     	 ldr r0,[r7,#48]
 1270 020a FFF7FEFF 	 bl prvUnlockQueue
 914:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xTaskResumeAll();
 1271              	 .loc 1 914 0
 1272 020e FFF7FEFF 	 bl xTaskResumeAll
 915:../Dave/Generated/FREERTOS/queue.c **** 
 916:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 917:../Dave/Generated/FREERTOS/queue.c **** 			return errQUEUE_FULL;
 1273              	 .loc 1 917 0
 1274 0212 0023     	 movs r3,#0
 1275 0214 00E0     	 b .L86
 1276              	.L85:
 918:../Dave/Generated/FREERTOS/queue.c **** 		}
 919:../Dave/Generated/FREERTOS/queue.c **** 	}
 1277              	 .loc 1 919 0 discriminator 6
 1278 0216 4EE7     	 b .L69
 1279              	.L86:
 920:../Dave/Generated/FREERTOS/queue.c **** }
 1280              	 .loc 1 920 0 discriminator 7
 1281 0218 1846     	 mov r0,r3
 1282 021a 3837     	 adds r7,r7,#56
 1283              	.LCFI54:
 1284              	 .cfi_def_cfa_offset 8
 1285 021c BD46     	 mov sp,r7
 1286              	.LCFI55:
 1287              	 .cfi_def_cfa_register 13
 1288              	 
 1289 021e 80BD     	 pop {r7,pc}
 1290              	.L88:
 1291              	 .align 2
 1292              	.L87:
 1293 0220 04ED00E0 	 .word -536810236
 1294              	 .cfi_endproc
 1295              	.LFE145:
 1297              	 .section .text.xQueueGenericSendFromISR,"ax",%progbits
 1298              	 .align 2
 1299              	 .global xQueueGenericSendFromISR
 1300              	 .thumb
 1301              	 .thumb_func
 1303              	xQueueGenericSendFromISR:
 1304              	.LFB146:
 921:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 922:../Dave/Generated/FREERTOS/queue.c **** 
 923:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
 924:../Dave/Generated/FREERTOS/queue.c **** {
 1305              	 .loc 1 924 0
 1306              	 .cfi_startproc
 1307              	 
 1308              	 
 1309 0000 80B5     	 push {r7,lr}
 1310              	.LCFI56:
 1311              	 .cfi_def_cfa_offset 8
 1312              	 .cfi_offset 7,-8
 1313              	 .cfi_offset 14,-4
 1314 0002 8EB0     	 sub sp,sp,#56
 1315              	.LCFI57:
 1316              	 .cfi_def_cfa_offset 64
 1317 0004 00AF     	 add r7,sp,#0
 1318              	.LCFI58:
 1319              	 .cfi_def_cfa_register 7
 1320 0006 F860     	 str r0,[r7,#12]
 1321 0008 B960     	 str r1,[r7,#8]
 1322 000a 7A60     	 str r2,[r7,#4]
 1323 000c 3B60     	 str r3,[r7]
 925:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
 926:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
 927:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1324              	 .loc 1 927 0
 1325 000e FB68     	 ldr r3,[r7,#12]
 1326 0010 3B63     	 str r3,[r7,#48]
 928:../Dave/Generated/FREERTOS/queue.c **** 
 929:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 1327              	 .loc 1 929 0
 1328 0012 3B6B     	 ldr r3,[r7,#48]
 1329 0014 002B     	 cmp r3,#0
 1330 0016 09D1     	 bne .L90
 1331              	.LBB130:
 1332              	.LBB131:
 1333              	 .loc 2 195 0 discriminator 1
 1334              	
 1335 0018 4FF0FC03 	 mov r3,#252
 1336 001c 83F31188 	 msr basepri,r3
 1337 0020 BFF36F8F 	 isb 
 1338 0024 BFF34F8F 	 dsb 
 1339              	
 1340              	
 1341              	 .thumb
 1342 0028 7B62     	 str r3,[r7,#36]
 1343              	.L91:
 1344              	.LBE131:
 1345              	.LBE130:
 1346              	 .loc 1 929 0 discriminator 1
 1347 002a FEE7     	 b .L91
 1348              	.L90:
 930:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1349              	 .loc 1 930 0
 1350 002c BB68     	 ldr r3,[r7,#8]
 1351 002e 002B     	 cmp r3,#0
 1352 0030 03D1     	 bne .L92
 1353              	 .loc 1 930 0 is_stmt 0 discriminator 2
 1354 0032 3B6B     	 ldr r3,[r7,#48]
 1355 0034 1B6C     	 ldr r3,[r3,#64]
 1356 0036 002B     	 cmp r3,#0
 1357 0038 01D1     	 bne .L93
 1358              	.L92:
 1359              	 .loc 1 930 0 discriminator 3
 1360 003a 0123     	 movs r3,#1
 1361 003c 00E0     	 b .L94
 1362              	.L93:
 1363              	 .loc 1 930 0 discriminator 4
 1364 003e 0023     	 movs r3,#0
 1365              	.L94:
 1366              	 .loc 1 930 0 discriminator 6
 1367 0040 002B     	 cmp r3,#0
 1368 0042 09D1     	 bne .L95
 1369              	.LBB132:
 1370              	.LBB133:
 1371              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1372              	
 1373 0044 4FF0FC03 	 mov r3,#252
 1374 0048 83F31188 	 msr basepri,r3
 1375 004c BFF36F8F 	 isb 
 1376 0050 BFF34F8F 	 dsb 
 1377              	
 1378              	
 1379              	 .thumb
 1380 0054 3B62     	 str r3,[r7,#32]
 1381              	.L96:
 1382              	.LBE133:
 1383              	.LBE132:
 1384              	 .loc 1 930 0 discriminator 2
 1385 0056 FEE7     	 b .L96
 1386              	.L95:
 931:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1387              	 .loc 1 931 0
 1388 0058 3B68     	 ldr r3,[r7]
 1389 005a 022B     	 cmp r3,#2
 1390 005c 03D1     	 bne .L97
 1391              	 .loc 1 931 0 is_stmt 0 discriminator 2
 1392 005e 3B6B     	 ldr r3,[r7,#48]
 1393 0060 DB6B     	 ldr r3,[r3,#60]
 1394 0062 012B     	 cmp r3,#1
 1395 0064 01D1     	 bne .L98
 1396              	.L97:
 1397              	 .loc 1 931 0 discriminator 3
 1398 0066 0123     	 movs r3,#1
 1399 0068 00E0     	 b .L99
 1400              	.L98:
 1401              	 .loc 1 931 0 discriminator 4
 1402 006a 0023     	 movs r3,#0
 1403              	.L99:
 1404              	 .loc 1 931 0 discriminator 6
 1405 006c 002B     	 cmp r3,#0
 1406 006e 09D1     	 bne .L100
 1407              	.LBB134:
 1408              	.LBB135:
 1409              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1410              	
 1411 0070 4FF0FC03 	 mov r3,#252
 1412 0074 83F31188 	 msr basepri,r3
 1413 0078 BFF36F8F 	 isb 
 1414 007c BFF34F8F 	 dsb 
 1415              	
 1416              	
 1417              	 .thumb
 1418 0080 FB61     	 str r3,[r7,#28]
 1419              	.L101:
 1420              	.LBE135:
 1421              	.LBE134:
 1422              	 .loc 1 931 0 discriminator 3
 1423 0082 FEE7     	 b .L101
 1424              	.L100:
 932:../Dave/Generated/FREERTOS/queue.c **** 
 933:../Dave/Generated/FREERTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 934:../Dave/Generated/FREERTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 935:../Dave/Generated/FREERTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 936:../Dave/Generated/FREERTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 937:../Dave/Generated/FREERTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 938:../Dave/Generated/FREERTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 939:../Dave/Generated/FREERTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 940:../Dave/Generated/FREERTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
 941:../Dave/Generated/FREERTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 942:../Dave/Generated/FREERTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 943:../Dave/Generated/FREERTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 944:../Dave/Generated/FREERTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 945:../Dave/Generated/FREERTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 946:../Dave/Generated/FREERTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 947:../Dave/Generated/FREERTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1425              	 .loc 1 947 0
 1426 0084 FFF7FEFF 	 bl vPortValidateInterruptPriority
 1427              	.LBB136:
 1428              	.LBB137:
 196:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 197:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	mov %0, %1												\n"	\
 198:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	msr basepri, %0											\n" \
 199:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	isb														\n" \
 200:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	dsb														\n" \
 201:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
 202:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	);
 203:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 204:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 205:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 206:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 207:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 208:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** {
 209:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 210:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 211:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile
 1429              	 .loc 2 211 0
 1430              	
 1431 0088 EFF31182 	 mrs r2,basepri
 1432 008c 4FF0FC03 	 mov r3,#252
 1433 0090 83F31188 	 msr basepri,r3
 1434 0094 BFF36F8F 	 isb 
 1435 0098 BFF34F8F 	 dsb 
 1436              	
 1437              	
 1438              	 .thumb
 1439 009c BA61     	 str r2,[r7,#24]
 1440 009e 7B61     	 str r3,[r7,#20]
 212:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 213:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	mrs %0, basepri											\n" \
 214:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	mov %1, %2												\n"	\
 215:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	msr basepri, %1											\n" \
 216:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	isb														\n" \
 217:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	dsb														\n" \
 218:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "
 219:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	);
 220:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 221:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 222:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	warnings. */
 223:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	return ulOriginalBASEPRI;
 1441              	 .loc 2 223 0
 1442 00a0 BB69     	 ldr r3,[r7,#24]
 1443              	.LBE137:
 1444              	.LBE136:
 948:../Dave/Generated/FREERTOS/queue.c **** 
 949:../Dave/Generated/FREERTOS/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 950:../Dave/Generated/FREERTOS/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 951:../Dave/Generated/FREERTOS/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 952:../Dave/Generated/FREERTOS/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 953:../Dave/Generated/FREERTOS/queue.c **** 	post). */
 954:../Dave/Generated/FREERTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1445              	 .loc 1 954 0
 1446 00a2 FB62     	 str r3,[r7,#44]
 955:../Dave/Generated/FREERTOS/queue.c **** 	{
 956:../Dave/Generated/FREERTOS/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 1447              	 .loc 1 956 0
 1448 00a4 3B6B     	 ldr r3,[r7,#48]
 1449 00a6 9A6B     	 ldr r2,[r3,#56]
 1450 00a8 3B6B     	 ldr r3,[r7,#48]
 1451 00aa DB6B     	 ldr r3,[r3,#60]
 1452 00ac 9A42     	 cmp r2,r3
 1453 00ae 02D3     	 bcc .L103
 1454              	 .loc 1 956 0 is_stmt 0 discriminator 1
 1455 00b0 3B68     	 ldr r3,[r7]
 1456 00b2 022B     	 cmp r3,#2
 1457 00b4 3ED1     	 bne .L104
 1458              	.L103:
 1459              	.LBB138:
 957:../Dave/Generated/FREERTOS/queue.c **** 		{
 958:../Dave/Generated/FREERTOS/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1460              	 .loc 1 958 0 is_stmt 1
 1461 00b6 3B6B     	 ldr r3,[r7,#48]
 1462 00b8 93F84530 	 ldrb r3,[r3,#69]
 1463 00bc 87F82B30 	 strb r3,[r7,#43]
 959:../Dave/Generated/FREERTOS/queue.c **** 
 960:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 961:../Dave/Generated/FREERTOS/queue.c **** 
 962:../Dave/Generated/FREERTOS/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 963:../Dave/Generated/FREERTOS/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 964:../Dave/Generated/FREERTOS/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 965:../Dave/Generated/FREERTOS/queue.c **** 			called here even though the disinherit function does not check if
 966:../Dave/Generated/FREERTOS/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
 967:../Dave/Generated/FREERTOS/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1464              	 .loc 1 967 0
 1465 00c0 386B     	 ldr r0,[r7,#48]
 1466 00c2 B968     	 ldr r1,[r7,#8]
 1467 00c4 3A68     	 ldr r2,[r7]
 1468 00c6 FFF7FEFF 	 bl prvCopyDataToQueue
 968:../Dave/Generated/FREERTOS/queue.c **** 
 969:../Dave/Generated/FREERTOS/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
 970:../Dave/Generated/FREERTOS/queue.c **** 			be done when the queue is unlocked later. */
 971:../Dave/Generated/FREERTOS/queue.c **** 			if( cTxLock == queueUNLOCKED )
 1469              	 .loc 1 971 0
 1470 00ca 97F92B30 	 ldrsb r3,[r7,#43]
 1471 00ce B3F1FF3F 	 cmp r3,#-1
 1472 00d2 24D1     	 bne .L105
 972:../Dave/Generated/FREERTOS/queue.c **** 			{
 973:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 974:../Dave/Generated/FREERTOS/queue.c **** 				{
 975:../Dave/Generated/FREERTOS/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 1473              	 .loc 1 975 0
 1474 00d4 3B6B     	 ldr r3,[r7,#48]
 1475 00d6 9B6C     	 ldr r3,[r3,#72]
 1476 00d8 002B     	 cmp r3,#0
 1477 00da 0DD0     	 beq .L106
 976:../Dave/Generated/FREERTOS/queue.c **** 					{
 977:../Dave/Generated/FREERTOS/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 1478              	 .loc 1 977 0
 1479 00dc 386B     	 ldr r0,[r7,#48]
 1480 00de 3968     	 ldr r1,[r7]
 1481 00e0 FFF7FEFF 	 bl prvNotifyQueueSetContainer
 1482 00e4 0346     	 mov r3,r0
 1483 00e6 002B     	 cmp r3,#0
 1484 00e8 21D0     	 beq .L107
 978:../Dave/Generated/FREERTOS/queue.c **** 						{
 979:../Dave/Generated/FREERTOS/queue.c **** 							/* The queue is a member of a queue set, and posting
 980:../Dave/Generated/FREERTOS/queue.c **** 							to the queue set caused a higher priority task to
 981:../Dave/Generated/FREERTOS/queue.c **** 							unblock.  A context switch is required. */
 982:../Dave/Generated/FREERTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1485              	 .loc 1 982 0
 1486 00ea 7B68     	 ldr r3,[r7,#4]
 1487 00ec 002B     	 cmp r3,#0
 1488 00ee 1ED0     	 beq .L107
 983:../Dave/Generated/FREERTOS/queue.c **** 							{
 984:../Dave/Generated/FREERTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1489              	 .loc 1 984 0
 1490 00f0 7B68     	 ldr r3,[r7,#4]
 1491 00f2 0122     	 movs r2,#1
 1492 00f4 1A60     	 str r2,[r3]
 1493 00f6 1AE0     	 b .L107
 1494              	.L106:
 985:../Dave/Generated/FREERTOS/queue.c **** 							}
 986:../Dave/Generated/FREERTOS/queue.c **** 							else
 987:../Dave/Generated/FREERTOS/queue.c **** 							{
 988:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 989:../Dave/Generated/FREERTOS/queue.c **** 							}
 990:../Dave/Generated/FREERTOS/queue.c **** 						}
 991:../Dave/Generated/FREERTOS/queue.c **** 						else
 992:../Dave/Generated/FREERTOS/queue.c **** 						{
 993:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 994:../Dave/Generated/FREERTOS/queue.c **** 						}
 995:../Dave/Generated/FREERTOS/queue.c **** 					}
 996:../Dave/Generated/FREERTOS/queue.c **** 					else
 997:../Dave/Generated/FREERTOS/queue.c **** 					{
 998:../Dave/Generated/FREERTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1495              	 .loc 1 998 0
 1496 00f8 3B6B     	 ldr r3,[r7,#48]
 1497 00fa 5B6A     	 ldr r3,[r3,#36]
 1498 00fc 002B     	 cmp r3,#0
 1499 00fe 16D0     	 beq .L107
 999:../Dave/Generated/FREERTOS/queue.c **** 						{
1000:../Dave/Generated/FREERTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1500              	 .loc 1 1000 0
 1501 0100 3B6B     	 ldr r3,[r7,#48]
 1502 0102 2433     	 adds r3,r3,#36
 1503 0104 1846     	 mov r0,r3
 1504 0106 FFF7FEFF 	 bl xTaskRemoveFromEventList
 1505 010a 0346     	 mov r3,r0
 1506 010c 002B     	 cmp r3,#0
 1507 010e 0ED0     	 beq .L107
1001:../Dave/Generated/FREERTOS/queue.c **** 							{
1002:../Dave/Generated/FREERTOS/queue.c **** 								/* The task waiting has a higher priority so
1003:../Dave/Generated/FREERTOS/queue.c **** 								record that a context switch is required. */
1004:../Dave/Generated/FREERTOS/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
 1508              	 .loc 1 1004 0
 1509 0110 7B68     	 ldr r3,[r7,#4]
 1510 0112 002B     	 cmp r3,#0
 1511 0114 0BD0     	 beq .L107
1005:../Dave/Generated/FREERTOS/queue.c **** 								{
1006:../Dave/Generated/FREERTOS/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
 1512              	 .loc 1 1006 0
 1513 0116 7B68     	 ldr r3,[r7,#4]
 1514 0118 0122     	 movs r2,#1
 1515 011a 1A60     	 str r2,[r3]
 1516 011c 07E0     	 b .L107
 1517              	.L105:
1007:../Dave/Generated/FREERTOS/queue.c **** 								}
1008:../Dave/Generated/FREERTOS/queue.c **** 								else
1009:../Dave/Generated/FREERTOS/queue.c **** 								{
1010:../Dave/Generated/FREERTOS/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1011:../Dave/Generated/FREERTOS/queue.c **** 								}
1012:../Dave/Generated/FREERTOS/queue.c **** 							}
1013:../Dave/Generated/FREERTOS/queue.c **** 							else
1014:../Dave/Generated/FREERTOS/queue.c **** 							{
1015:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1016:../Dave/Generated/FREERTOS/queue.c **** 							}
1017:../Dave/Generated/FREERTOS/queue.c **** 						}
1018:../Dave/Generated/FREERTOS/queue.c **** 						else
1019:../Dave/Generated/FREERTOS/queue.c **** 						{
1020:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1021:../Dave/Generated/FREERTOS/queue.c **** 						}
1022:../Dave/Generated/FREERTOS/queue.c **** 					}
1023:../Dave/Generated/FREERTOS/queue.c **** 				}
1024:../Dave/Generated/FREERTOS/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1025:../Dave/Generated/FREERTOS/queue.c **** 				{
1026:../Dave/Generated/FREERTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1027:../Dave/Generated/FREERTOS/queue.c **** 					{
1028:../Dave/Generated/FREERTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1029:../Dave/Generated/FREERTOS/queue.c **** 						{
1030:../Dave/Generated/FREERTOS/queue.c **** 							/* The task waiting has a higher priority so record that a
1031:../Dave/Generated/FREERTOS/queue.c **** 							context	switch is required. */
1032:../Dave/Generated/FREERTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1033:../Dave/Generated/FREERTOS/queue.c **** 							{
1034:../Dave/Generated/FREERTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1035:../Dave/Generated/FREERTOS/queue.c **** 							}
1036:../Dave/Generated/FREERTOS/queue.c **** 							else
1037:../Dave/Generated/FREERTOS/queue.c **** 							{
1038:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1039:../Dave/Generated/FREERTOS/queue.c **** 							}
1040:../Dave/Generated/FREERTOS/queue.c **** 						}
1041:../Dave/Generated/FREERTOS/queue.c **** 						else
1042:../Dave/Generated/FREERTOS/queue.c **** 						{
1043:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1044:../Dave/Generated/FREERTOS/queue.c **** 						}
1045:../Dave/Generated/FREERTOS/queue.c **** 					}
1046:../Dave/Generated/FREERTOS/queue.c **** 					else
1047:../Dave/Generated/FREERTOS/queue.c **** 					{
1048:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1049:../Dave/Generated/FREERTOS/queue.c **** 					}
1050:../Dave/Generated/FREERTOS/queue.c **** 				}
1051:../Dave/Generated/FREERTOS/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1052:../Dave/Generated/FREERTOS/queue.c **** 			}
1053:../Dave/Generated/FREERTOS/queue.c **** 			else
1054:../Dave/Generated/FREERTOS/queue.c **** 			{
1055:../Dave/Generated/FREERTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1056:../Dave/Generated/FREERTOS/queue.c **** 				knows that data was posted while it was locked. */
1057:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1518              	 .loc 1 1057 0
 1519 011e 97F82B30 	 ldrb r3,[r7,#43]
 1520 0122 0133     	 adds r3,r3,#1
 1521 0124 DBB2     	 uxtb r3,r3
 1522 0126 DAB2     	 uxtb r2,r3
 1523 0128 3B6B     	 ldr r3,[r7,#48]
 1524 012a 83F84520 	 strb r2,[r3,#69]
 1525              	.L107:
1058:../Dave/Generated/FREERTOS/queue.c **** 			}
1059:../Dave/Generated/FREERTOS/queue.c **** 
1060:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 1526              	 .loc 1 1060 0
 1527 012e 0123     	 movs r3,#1
 1528 0130 7B63     	 str r3,[r7,#52]
 1529              	.LBE138:
 957:../Dave/Generated/FREERTOS/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1530              	 .loc 1 957 0
 1531 0132 01E0     	 b .L108
 1532              	.L104:
1061:../Dave/Generated/FREERTOS/queue.c **** 		}
1062:../Dave/Generated/FREERTOS/queue.c **** 		else
1063:../Dave/Generated/FREERTOS/queue.c **** 		{
1064:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1065:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = errQUEUE_FULL;
 1533              	 .loc 1 1065 0
 1534 0134 0023     	 movs r3,#0
 1535 0136 7B63     	 str r3,[r7,#52]
 1536              	.L108:
 1537 0138 FB6A     	 ldr r3,[r7,#44]
 1538 013a 3B61     	 str r3,[r7,#16]
 1539              	.LBB139:
 1540              	.LBB140:
 224:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 225:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 226:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 227:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 228:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** {
 229:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile
 1541              	 .loc 2 229 0
 1542 013c 3B69     	 ldr r3,[r7,#16]
 1543              	
 1544 013e 83F31188 	 msr basepri,r3
 1545              	
 1546              	 .thumb
 1547              	.LBE140:
 1548              	.LBE139:
1066:../Dave/Generated/FREERTOS/queue.c **** 		}
1067:../Dave/Generated/FREERTOS/queue.c **** 	}
1068:../Dave/Generated/FREERTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1069:../Dave/Generated/FREERTOS/queue.c **** 
1070:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 1549              	 .loc 1 1070 0
 1550 0142 7B6B     	 ldr r3,[r7,#52]
1071:../Dave/Generated/FREERTOS/queue.c **** }
 1551              	 .loc 1 1071 0
 1552 0144 1846     	 mov r0,r3
 1553 0146 3837     	 adds r7,r7,#56
 1554              	.LCFI59:
 1555              	 .cfi_def_cfa_offset 8
 1556 0148 BD46     	 mov sp,r7
 1557              	.LCFI60:
 1558              	 .cfi_def_cfa_register 13
 1559              	 
 1560 014a 80BD     	 pop {r7,pc}
 1561              	 .cfi_endproc
 1562              	.LFE146:
 1564              	 .section .text.xQueueGiveFromISR,"ax",%progbits
 1565              	 .align 2
 1566              	 .global xQueueGiveFromISR
 1567              	 .thumb
 1568              	 .thumb_func
 1570              	xQueueGiveFromISR:
 1571              	.LFB147:
1072:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1073:../Dave/Generated/FREERTOS/queue.c **** 
1074:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1075:../Dave/Generated/FREERTOS/queue.c **** {
 1572              	 .loc 1 1075 0
 1573              	 .cfi_startproc
 1574              	 
 1575              	 
 1576 0000 80B5     	 push {r7,lr}
 1577              	.LCFI61:
 1578              	 .cfi_def_cfa_offset 8
 1579              	 .cfi_offset 7,-8
 1580              	 .cfi_offset 14,-4
 1581 0002 8EB0     	 sub sp,sp,#56
 1582              	.LCFI62:
 1583              	 .cfi_def_cfa_offset 64
 1584 0004 00AF     	 add r7,sp,#0
 1585              	.LCFI63:
 1586              	 .cfi_def_cfa_register 7
 1587 0006 7860     	 str r0,[r7,#4]
 1588 0008 3960     	 str r1,[r7]
1076:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
1077:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1078:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1589              	 .loc 1 1078 0
 1590 000a 7B68     	 ldr r3,[r7,#4]
 1591 000c 3B63     	 str r3,[r7,#48]
1079:../Dave/Generated/FREERTOS/queue.c **** 
1080:../Dave/Generated/FREERTOS/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1081:../Dave/Generated/FREERTOS/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1082:../Dave/Generated/FREERTOS/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1083:../Dave/Generated/FREERTOS/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1084:../Dave/Generated/FREERTOS/queue.c **** 	post). */
1085:../Dave/Generated/FREERTOS/queue.c **** 
1086:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 1592              	 .loc 1 1086 0
 1593 000e 3B6B     	 ldr r3,[r7,#48]
 1594 0010 002B     	 cmp r3,#0
 1595 0012 09D1     	 bne .L111
 1596              	.LBB141:
 1597              	.LBB142:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1598              	 .loc 2 195 0 discriminator 1
 1599              	
 1600 0014 4FF0FC03 	 mov r3,#252
 1601 0018 83F31188 	 msr basepri,r3
 1602 001c BFF36F8F 	 isb 
 1603 0020 BFF34F8F 	 dsb 
 1604              	
 1605              	
 1606              	 .thumb
 1607 0024 3B62     	 str r3,[r7,#32]
 1608              	.L112:
 1609              	.LBE142:
 1610              	.LBE141:
 1611              	 .loc 1 1086 0 discriminator 1
 1612 0026 FEE7     	 b .L112
 1613              	.L111:
1087:../Dave/Generated/FREERTOS/queue.c **** 
1088:../Dave/Generated/FREERTOS/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1089:../Dave/Generated/FREERTOS/queue.c **** 	if the item size is not 0. */
1090:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
 1614              	 .loc 1 1090 0
 1615 0028 3B6B     	 ldr r3,[r7,#48]
 1616 002a 1B6C     	 ldr r3,[r3,#64]
 1617 002c 002B     	 cmp r3,#0
 1618 002e 09D0     	 beq .L113
 1619              	.LBB143:
 1620              	.LBB144:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1621              	 .loc 2 195 0 discriminator 1
 1622              	
 1623 0030 4FF0FC03 	 mov r3,#252
 1624 0034 83F31188 	 msr basepri,r3
 1625 0038 BFF36F8F 	 isb 
 1626 003c BFF34F8F 	 dsb 
 1627              	
 1628              	
 1629              	 .thumb
 1630 0040 FB61     	 str r3,[r7,#28]
 1631              	.L114:
 1632              	.LBE144:
 1633              	.LBE143:
 1634              	 .loc 1 1090 0 discriminator 2
 1635 0042 FEE7     	 b .L114
 1636              	.L113:
1091:../Dave/Generated/FREERTOS/queue.c **** 
1092:../Dave/Generated/FREERTOS/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1093:../Dave/Generated/FREERTOS/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1094:../Dave/Generated/FREERTOS/queue.c **** 	interrupts, only tasks. */
1095:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NU
 1637              	 .loc 1 1095 0
 1638 0044 3B6B     	 ldr r3,[r7,#48]
 1639 0046 1B68     	 ldr r3,[r3]
 1640 0048 002B     	 cmp r3,#0
 1641 004a 03D1     	 bne .L115
 1642              	 .loc 1 1095 0 is_stmt 0 discriminator 2
 1643 004c 3B6B     	 ldr r3,[r7,#48]
 1644 004e 5B68     	 ldr r3,[r3,#4]
 1645 0050 002B     	 cmp r3,#0
 1646 0052 01D1     	 bne .L116
 1647              	.L115:
 1648              	 .loc 1 1095 0 discriminator 3
 1649 0054 0123     	 movs r3,#1
 1650 0056 00E0     	 b .L117
 1651              	.L116:
 1652              	 .loc 1 1095 0 discriminator 4
 1653 0058 0023     	 movs r3,#0
 1654              	.L117:
 1655              	 .loc 1 1095 0 discriminator 6
 1656 005a 002B     	 cmp r3,#0
 1657 005c 09D1     	 bne .L118
 1658              	.LBB145:
 1659              	.LBB146:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1660              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1661              	
 1662 005e 4FF0FC03 	 mov r3,#252
 1663 0062 83F31188 	 msr basepri,r3
 1664 0066 BFF36F8F 	 isb 
 1665 006a BFF34F8F 	 dsb 
 1666              	
 1667              	
 1668              	 .thumb
 1669 006e BB61     	 str r3,[r7,#24]
 1670              	.L119:
 1671              	.LBE146:
 1672              	.LBE145:
 1673              	 .loc 1 1095 0 discriminator 3
 1674 0070 FEE7     	 b .L119
 1675              	.L118:
1096:../Dave/Generated/FREERTOS/queue.c **** 
1097:../Dave/Generated/FREERTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1098:../Dave/Generated/FREERTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1099:../Dave/Generated/FREERTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1100:../Dave/Generated/FREERTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1101:../Dave/Generated/FREERTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1102:../Dave/Generated/FREERTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1103:../Dave/Generated/FREERTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1104:../Dave/Generated/FREERTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1105:../Dave/Generated/FREERTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1106:../Dave/Generated/FREERTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1107:../Dave/Generated/FREERTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1108:../Dave/Generated/FREERTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1109:../Dave/Generated/FREERTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1110:../Dave/Generated/FREERTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1111:../Dave/Generated/FREERTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1676              	 .loc 1 1111 0
 1677 0072 FFF7FEFF 	 bl vPortValidateInterruptPriority
 1678              	.LBB147:
 1679              	.LBB148:
 211:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1680              	 .loc 2 211 0
 1681              	
 1682 0076 EFF31182 	 mrs r2,basepri
 1683 007a 4FF0FC03 	 mov r3,#252
 1684 007e 83F31188 	 msr basepri,r3
 1685 0082 BFF36F8F 	 isb 
 1686 0086 BFF34F8F 	 dsb 
 1687              	
 1688              	
 1689              	 .thumb
 1690 008a 7A61     	 str r2,[r7,#20]
 1691 008c 3B61     	 str r3,[r7,#16]
 223:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 1692              	 .loc 2 223 0
 1693 008e 7B69     	 ldr r3,[r7,#20]
 1694              	.LBE148:
 1695              	.LBE147:
1112:../Dave/Generated/FREERTOS/queue.c **** 
1113:../Dave/Generated/FREERTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1696              	 .loc 1 1113 0
 1697 0090 FB62     	 str r3,[r7,#44]
 1698              	.LBB149:
1114:../Dave/Generated/FREERTOS/queue.c **** 	{
1115:../Dave/Generated/FREERTOS/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1699              	 .loc 1 1115 0
 1700 0092 3B6B     	 ldr r3,[r7,#48]
 1701 0094 9B6B     	 ldr r3,[r3,#56]
 1702 0096 BB62     	 str r3,[r7,#40]
1116:../Dave/Generated/FREERTOS/queue.c **** 
1117:../Dave/Generated/FREERTOS/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1118:../Dave/Generated/FREERTOS/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1119:../Dave/Generated/FREERTOS/queue.c **** 		space'. */
1120:../Dave/Generated/FREERTOS/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
 1703              	 .loc 1 1120 0
 1704 0098 3B6B     	 ldr r3,[r7,#48]
 1705 009a DA6B     	 ldr r2,[r3,#60]
 1706 009c BB6A     	 ldr r3,[r7,#40]
 1707 009e 9A42     	 cmp r2,r3
 1708 00a0 3DD9     	 bls .L121
 1709              	.LBB150:
1121:../Dave/Generated/FREERTOS/queue.c **** 		{
1122:../Dave/Generated/FREERTOS/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1710              	 .loc 1 1122 0
 1711 00a2 3B6B     	 ldr r3,[r7,#48]
 1712 00a4 93F84530 	 ldrb r3,[r3,#69]
 1713 00a8 87F82730 	 strb r3,[r7,#39]
1123:../Dave/Generated/FREERTOS/queue.c **** 
1124:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1125:../Dave/Generated/FREERTOS/queue.c **** 
1126:../Dave/Generated/FREERTOS/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1127:../Dave/Generated/FREERTOS/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1128:../Dave/Generated/FREERTOS/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1129:../Dave/Generated/FREERTOS/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1130:../Dave/Generated/FREERTOS/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1131:../Dave/Generated/FREERTOS/queue.c **** 			messages (semaphores) available. */
1132:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 1714              	 .loc 1 1132 0
 1715 00ac BB6A     	 ldr r3,[r7,#40]
 1716 00ae 5A1C     	 adds r2,r3,#1
 1717 00b0 3B6B     	 ldr r3,[r7,#48]
 1718 00b2 9A63     	 str r2,[r3,#56]
1133:../Dave/Generated/FREERTOS/queue.c **** 
1134:../Dave/Generated/FREERTOS/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1135:../Dave/Generated/FREERTOS/queue.c **** 			be done when the queue is unlocked later. */
1136:../Dave/Generated/FREERTOS/queue.c **** 			if( cTxLock == queueUNLOCKED )
 1719              	 .loc 1 1136 0
 1720 00b4 97F92730 	 ldrsb r3,[r7,#39]
 1721 00b8 B3F1FF3F 	 cmp r3,#-1
 1722 00bc 24D1     	 bne .L122
1137:../Dave/Generated/FREERTOS/queue.c **** 			{
1138:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1139:../Dave/Generated/FREERTOS/queue.c **** 				{
1140:../Dave/Generated/FREERTOS/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 1723              	 .loc 1 1140 0
 1724 00be 3B6B     	 ldr r3,[r7,#48]
 1725 00c0 9B6C     	 ldr r3,[r3,#72]
 1726 00c2 002B     	 cmp r3,#0
 1727 00c4 0DD0     	 beq .L123
1141:../Dave/Generated/FREERTOS/queue.c **** 					{
1142:../Dave/Generated/FREERTOS/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
 1728              	 .loc 1 1142 0
 1729 00c6 386B     	 ldr r0,[r7,#48]
 1730 00c8 0021     	 movs r1,#0
 1731 00ca FFF7FEFF 	 bl prvNotifyQueueSetContainer
 1732 00ce 0346     	 mov r3,r0
 1733 00d0 002B     	 cmp r3,#0
 1734 00d2 21D0     	 beq .L124
1143:../Dave/Generated/FREERTOS/queue.c **** 						{
1144:../Dave/Generated/FREERTOS/queue.c **** 							/* The semaphore is a member of a queue set, and
1145:../Dave/Generated/FREERTOS/queue.c **** 							posting	to the queue set caused a higher priority
1146:../Dave/Generated/FREERTOS/queue.c **** 							task to	unblock.  A context switch is required. */
1147:../Dave/Generated/FREERTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1735              	 .loc 1 1147 0
 1736 00d4 3B68     	 ldr r3,[r7]
 1737 00d6 002B     	 cmp r3,#0
 1738 00d8 1ED0     	 beq .L124
1148:../Dave/Generated/FREERTOS/queue.c **** 							{
1149:../Dave/Generated/FREERTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1739              	 .loc 1 1149 0
 1740 00da 3B68     	 ldr r3,[r7]
 1741 00dc 0122     	 movs r2,#1
 1742 00de 1A60     	 str r2,[r3]
 1743 00e0 1AE0     	 b .L124
 1744              	.L123:
1150:../Dave/Generated/FREERTOS/queue.c **** 							}
1151:../Dave/Generated/FREERTOS/queue.c **** 							else
1152:../Dave/Generated/FREERTOS/queue.c **** 							{
1153:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1154:../Dave/Generated/FREERTOS/queue.c **** 							}
1155:../Dave/Generated/FREERTOS/queue.c **** 						}
1156:../Dave/Generated/FREERTOS/queue.c **** 						else
1157:../Dave/Generated/FREERTOS/queue.c **** 						{
1158:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1159:../Dave/Generated/FREERTOS/queue.c **** 						}
1160:../Dave/Generated/FREERTOS/queue.c **** 					}
1161:../Dave/Generated/FREERTOS/queue.c **** 					else
1162:../Dave/Generated/FREERTOS/queue.c **** 					{
1163:../Dave/Generated/FREERTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1745              	 .loc 1 1163 0
 1746 00e2 3B6B     	 ldr r3,[r7,#48]
 1747 00e4 5B6A     	 ldr r3,[r3,#36]
 1748 00e6 002B     	 cmp r3,#0
 1749 00e8 16D0     	 beq .L124
1164:../Dave/Generated/FREERTOS/queue.c **** 						{
1165:../Dave/Generated/FREERTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1750              	 .loc 1 1165 0
 1751 00ea 3B6B     	 ldr r3,[r7,#48]
 1752 00ec 2433     	 adds r3,r3,#36
 1753 00ee 1846     	 mov r0,r3
 1754 00f0 FFF7FEFF 	 bl xTaskRemoveFromEventList
 1755 00f4 0346     	 mov r3,r0
 1756 00f6 002B     	 cmp r3,#0
 1757 00f8 0ED0     	 beq .L124
1166:../Dave/Generated/FREERTOS/queue.c **** 							{
1167:../Dave/Generated/FREERTOS/queue.c **** 								/* The task waiting has a higher priority so
1168:../Dave/Generated/FREERTOS/queue.c **** 								record that a context switch is required. */
1169:../Dave/Generated/FREERTOS/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
 1758              	 .loc 1 1169 0
 1759 00fa 3B68     	 ldr r3,[r7]
 1760 00fc 002B     	 cmp r3,#0
 1761 00fe 0BD0     	 beq .L124
1170:../Dave/Generated/FREERTOS/queue.c **** 								{
1171:../Dave/Generated/FREERTOS/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
 1762              	 .loc 1 1171 0
 1763 0100 3B68     	 ldr r3,[r7]
 1764 0102 0122     	 movs r2,#1
 1765 0104 1A60     	 str r2,[r3]
 1766 0106 07E0     	 b .L124
 1767              	.L122:
1172:../Dave/Generated/FREERTOS/queue.c **** 								}
1173:../Dave/Generated/FREERTOS/queue.c **** 								else
1174:../Dave/Generated/FREERTOS/queue.c **** 								{
1175:../Dave/Generated/FREERTOS/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1176:../Dave/Generated/FREERTOS/queue.c **** 								}
1177:../Dave/Generated/FREERTOS/queue.c **** 							}
1178:../Dave/Generated/FREERTOS/queue.c **** 							else
1179:../Dave/Generated/FREERTOS/queue.c **** 							{
1180:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1181:../Dave/Generated/FREERTOS/queue.c **** 							}
1182:../Dave/Generated/FREERTOS/queue.c **** 						}
1183:../Dave/Generated/FREERTOS/queue.c **** 						else
1184:../Dave/Generated/FREERTOS/queue.c **** 						{
1185:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1186:../Dave/Generated/FREERTOS/queue.c **** 						}
1187:../Dave/Generated/FREERTOS/queue.c **** 					}
1188:../Dave/Generated/FREERTOS/queue.c **** 				}
1189:../Dave/Generated/FREERTOS/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1190:../Dave/Generated/FREERTOS/queue.c **** 				{
1191:../Dave/Generated/FREERTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1192:../Dave/Generated/FREERTOS/queue.c **** 					{
1193:../Dave/Generated/FREERTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1194:../Dave/Generated/FREERTOS/queue.c **** 						{
1195:../Dave/Generated/FREERTOS/queue.c **** 							/* The task waiting has a higher priority so record that a
1196:../Dave/Generated/FREERTOS/queue.c **** 							context	switch is required. */
1197:../Dave/Generated/FREERTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1198:../Dave/Generated/FREERTOS/queue.c **** 							{
1199:../Dave/Generated/FREERTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1200:../Dave/Generated/FREERTOS/queue.c **** 							}
1201:../Dave/Generated/FREERTOS/queue.c **** 							else
1202:../Dave/Generated/FREERTOS/queue.c **** 							{
1203:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1204:../Dave/Generated/FREERTOS/queue.c **** 							}
1205:../Dave/Generated/FREERTOS/queue.c **** 						}
1206:../Dave/Generated/FREERTOS/queue.c **** 						else
1207:../Dave/Generated/FREERTOS/queue.c **** 						{
1208:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1209:../Dave/Generated/FREERTOS/queue.c **** 						}
1210:../Dave/Generated/FREERTOS/queue.c **** 					}
1211:../Dave/Generated/FREERTOS/queue.c **** 					else
1212:../Dave/Generated/FREERTOS/queue.c **** 					{
1213:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1214:../Dave/Generated/FREERTOS/queue.c **** 					}
1215:../Dave/Generated/FREERTOS/queue.c **** 				}
1216:../Dave/Generated/FREERTOS/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1217:../Dave/Generated/FREERTOS/queue.c **** 			}
1218:../Dave/Generated/FREERTOS/queue.c **** 			else
1219:../Dave/Generated/FREERTOS/queue.c **** 			{
1220:../Dave/Generated/FREERTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1221:../Dave/Generated/FREERTOS/queue.c **** 				knows that data was posted while it was locked. */
1222:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1768              	 .loc 1 1222 0
 1769 0108 97F82730 	 ldrb r3,[r7,#39]
 1770 010c 0133     	 adds r3,r3,#1
 1771 010e DBB2     	 uxtb r3,r3
 1772 0110 DAB2     	 uxtb r2,r3
 1773 0112 3B6B     	 ldr r3,[r7,#48]
 1774 0114 83F84520 	 strb r2,[r3,#69]
 1775              	.L124:
1223:../Dave/Generated/FREERTOS/queue.c **** 			}
1224:../Dave/Generated/FREERTOS/queue.c **** 
1225:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 1776              	 .loc 1 1225 0
 1777 0118 0123     	 movs r3,#1
 1778 011a 7B63     	 str r3,[r7,#52]
 1779              	.LBE150:
 1780 011c 01E0     	 b .L125
 1781              	.L121:
1226:../Dave/Generated/FREERTOS/queue.c **** 		}
1227:../Dave/Generated/FREERTOS/queue.c **** 		else
1228:../Dave/Generated/FREERTOS/queue.c **** 		{
1229:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1230:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = errQUEUE_FULL;
 1782              	 .loc 1 1230 0
 1783 011e 0023     	 movs r3,#0
 1784 0120 7B63     	 str r3,[r7,#52]
 1785              	.L125:
 1786 0122 FB6A     	 ldr r3,[r7,#44]
 1787 0124 FB60     	 str r3,[r7,#12]
 1788              	.LBE149:
 1789              	.LBB151:
 1790              	.LBB152:
 1791              	 .loc 2 229 0
 1792 0126 FB68     	 ldr r3,[r7,#12]
 1793              	
 1794 0128 83F31188 	 msr basepri,r3
 1795              	
 1796              	 .thumb
 1797              	.LBE152:
 1798              	.LBE151:
1231:../Dave/Generated/FREERTOS/queue.c **** 		}
1232:../Dave/Generated/FREERTOS/queue.c **** 	}
1233:../Dave/Generated/FREERTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1234:../Dave/Generated/FREERTOS/queue.c **** 
1235:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 1799              	 .loc 1 1235 0
 1800 012c 7B6B     	 ldr r3,[r7,#52]
1236:../Dave/Generated/FREERTOS/queue.c **** }
 1801              	 .loc 1 1236 0
 1802 012e 1846     	 mov r0,r3
 1803 0130 3837     	 adds r7,r7,#56
 1804              	.LCFI64:
 1805              	 .cfi_def_cfa_offset 8
 1806 0132 BD46     	 mov sp,r7
 1807              	.LCFI65:
 1808              	 .cfi_def_cfa_register 13
 1809              	 
 1810 0134 80BD     	 pop {r7,pc}
 1811              	 .cfi_endproc
 1812              	.LFE147:
 1814 0136 00BF     	 .section .text.xQueueReceive,"ax",%progbits
 1815              	 .align 2
 1816              	 .global xQueueReceive
 1817              	 .thumb
 1818              	 .thumb_func
 1820              	xQueueReceive:
 1821              	.LFB148:
1237:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1238:../Dave/Generated/FREERTOS/queue.c **** 
1239:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1240:../Dave/Generated/FREERTOS/queue.c **** {
 1822              	 .loc 1 1240 0
 1823              	 .cfi_startproc
 1824              	 
 1825              	 
 1826 0000 80B5     	 push {r7,lr}
 1827              	.LCFI66:
 1828              	 .cfi_def_cfa_offset 8
 1829              	 .cfi_offset 7,-8
 1830              	 .cfi_offset 14,-4
 1831 0002 8CB0     	 sub sp,sp,#48
 1832              	.LCFI67:
 1833              	 .cfi_def_cfa_offset 56
 1834 0004 00AF     	 add r7,sp,#0
 1835              	.LCFI68:
 1836              	 .cfi_def_cfa_register 7
 1837 0006 F860     	 str r0,[r7,#12]
 1838 0008 B960     	 str r1,[r7,#8]
 1839 000a 7A60     	 str r2,[r7,#4]
1241:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1840              	 .loc 1 1241 0
 1841 000c 0023     	 movs r3,#0
 1842 000e FB62     	 str r3,[r7,#44]
1242:../Dave/Generated/FREERTOS/queue.c **** TimeOut_t xTimeOut;
1243:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1843              	 .loc 1 1243 0
 1844 0010 FB68     	 ldr r3,[r7,#12]
 1845 0012 BB62     	 str r3,[r7,#40]
1244:../Dave/Generated/FREERTOS/queue.c **** 
1245:../Dave/Generated/FREERTOS/queue.c **** 	/* Check the pointer is not NULL. */
1246:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( ( pxQueue ) );
 1846              	 .loc 1 1246 0
 1847 0014 BB6A     	 ldr r3,[r7,#40]
 1848 0016 002B     	 cmp r3,#0
 1849 0018 09D1     	 bne .L128
 1850              	.LBB153:
 1851              	.LBB154:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1852              	 .loc 2 195 0 discriminator 1
 1853              	
 1854 001a 4FF0FC03 	 mov r3,#252
 1855 001e 83F31188 	 msr basepri,r3
 1856 0022 BFF36F8F 	 isb 
 1857 0026 BFF34F8F 	 dsb 
 1858              	
 1859              	
 1860              	 .thumb
 1861 002a 3B62     	 str r3,[r7,#32]
 1862              	.L129:
 1863              	.LBE154:
 1864              	.LBE153:
 1865              	 .loc 1 1246 0 discriminator 1
 1866 002c FEE7     	 b .L129
 1867              	.L128:
1247:../Dave/Generated/FREERTOS/queue.c **** 
1248:../Dave/Generated/FREERTOS/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1249:../Dave/Generated/FREERTOS/queue.c **** 	is zero (so no data is copied into the buffer. */
1250:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1868              	 .loc 1 1250 0
 1869 002e BB68     	 ldr r3,[r7,#8]
 1870 0030 002B     	 cmp r3,#0
 1871 0032 03D1     	 bne .L130
 1872              	 .loc 1 1250 0 is_stmt 0 discriminator 2
 1873 0034 BB6A     	 ldr r3,[r7,#40]
 1874 0036 1B6C     	 ldr r3,[r3,#64]
 1875 0038 002B     	 cmp r3,#0
 1876 003a 01D1     	 bne .L131
 1877              	.L130:
 1878              	 .loc 1 1250 0 discriminator 3
 1879 003c 0123     	 movs r3,#1
 1880 003e 00E0     	 b .L132
 1881              	.L131:
 1882              	 .loc 1 1250 0 discriminator 4
 1883 0040 0023     	 movs r3,#0
 1884              	.L132:
 1885              	 .loc 1 1250 0 discriminator 6
 1886 0042 002B     	 cmp r3,#0
 1887 0044 09D1     	 bne .L133
 1888              	.LBB155:
 1889              	.LBB156:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1890              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1891              	
 1892 0046 4FF0FC03 	 mov r3,#252
 1893 004a 83F31188 	 msr basepri,r3
 1894 004e BFF36F8F 	 isb 
 1895 0052 BFF34F8F 	 dsb 
 1896              	
 1897              	
 1898              	 .thumb
 1899 0056 FB61     	 str r3,[r7,#28]
 1900              	.L134:
 1901              	.LBE156:
 1902              	.LBE155:
 1903              	 .loc 1 1250 0 discriminator 2
 1904 0058 FEE7     	 b .L134
 1905              	.L133:
1251:../Dave/Generated/FREERTOS/queue.c **** 
1252:../Dave/Generated/FREERTOS/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1253:../Dave/Generated/FREERTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1254:../Dave/Generated/FREERTOS/queue.c **** 	{
1255:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 1906              	 .loc 1 1255 0
 1907 005a FFF7FEFF 	 bl xTaskGetSchedulerState
 1908 005e 0346     	 mov r3,r0
 1909 0060 002B     	 cmp r3,#0
 1910 0062 02D1     	 bne .L135
 1911              	 .loc 1 1255 0 is_stmt 0 discriminator 2
 1912 0064 7B68     	 ldr r3,[r7,#4]
 1913 0066 002B     	 cmp r3,#0
 1914 0068 01D1     	 bne .L136
 1915              	.L135:
 1916              	 .loc 1 1255 0 discriminator 3
 1917 006a 0123     	 movs r3,#1
 1918 006c 00E0     	 b .L137
 1919              	.L136:
 1920              	 .loc 1 1255 0 discriminator 4
 1921 006e 0023     	 movs r3,#0
 1922              	.L137:
 1923              	 .loc 1 1255 0 discriminator 6
 1924 0070 002B     	 cmp r3,#0
 1925 0072 09D1     	 bne .L138
 1926              	.LBB157:
 1927              	.LBB158:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1928              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1929              	
 1930 0074 4FF0FC03 	 mov r3,#252
 1931 0078 83F31188 	 msr basepri,r3
 1932 007c BFF36F8F 	 isb 
 1933 0080 BFF34F8F 	 dsb 
 1934              	
 1935              	
 1936              	 .thumb
 1937 0084 BB61     	 str r3,[r7,#24]
 1938              	.L139:
 1939              	.LBE158:
 1940              	.LBE157:
 1941              	 .loc 1 1255 0 discriminator 3
 1942 0086 FEE7     	 b .L139
 1943              	.L138:
1256:../Dave/Generated/FREERTOS/queue.c **** 	}
1257:../Dave/Generated/FREERTOS/queue.c **** 	#endif
1258:../Dave/Generated/FREERTOS/queue.c **** 
1259:../Dave/Generated/FREERTOS/queue.c **** 
1260:../Dave/Generated/FREERTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1261:../Dave/Generated/FREERTOS/queue.c **** 	statements within the function itself.  This is done in the interest
1262:../Dave/Generated/FREERTOS/queue.c **** 	of execution time efficiency. */
1263:../Dave/Generated/FREERTOS/queue.c **** 
1264:../Dave/Generated/FREERTOS/queue.c **** 	for( ;; )
1265:../Dave/Generated/FREERTOS/queue.c **** 	{
1266:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 1944              	 .loc 1 1266 0
 1945 0088 FFF7FEFF 	 bl vPortEnterCritical
 1946              	.LBB159:
1267:../Dave/Generated/FREERTOS/queue.c **** 		{
1268:../Dave/Generated/FREERTOS/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1947              	 .loc 1 1268 0
 1948 008c BB6A     	 ldr r3,[r7,#40]
 1949 008e 9B6B     	 ldr r3,[r3,#56]
 1950 0090 7B62     	 str r3,[r7,#36]
1269:../Dave/Generated/FREERTOS/queue.c **** 
1270:../Dave/Generated/FREERTOS/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1271:../Dave/Generated/FREERTOS/queue.c **** 			must be the highest priority task wanting to access the queue. */
1272:../Dave/Generated/FREERTOS/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1951              	 .loc 1 1272 0
 1952 0092 7B6A     	 ldr r3,[r7,#36]
 1953 0094 002B     	 cmp r3,#0
 1954 0096 1FD0     	 beq .L140
1273:../Dave/Generated/FREERTOS/queue.c **** 			{
1274:../Dave/Generated/FREERTOS/queue.c **** 				/* Data available, remove one item. */
1275:../Dave/Generated/FREERTOS/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1955              	 .loc 1 1275 0
 1956 0098 B86A     	 ldr r0,[r7,#40]
 1957 009a B968     	 ldr r1,[r7,#8]
 1958 009c FFF7FEFF 	 bl prvCopyDataFromQueue
1276:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1277:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 1959              	 .loc 1 1277 0
 1960 00a0 7B6A     	 ldr r3,[r7,#36]
 1961 00a2 5A1E     	 subs r2,r3,#1
 1962 00a4 BB6A     	 ldr r3,[r7,#40]
 1963 00a6 9A63     	 str r2,[r3,#56]
1278:../Dave/Generated/FREERTOS/queue.c **** 
1279:../Dave/Generated/FREERTOS/queue.c **** 				/* There is now space in the queue, were any tasks waiting to
1280:../Dave/Generated/FREERTOS/queue.c **** 				post to the queue?  If so, unblock the highest priority waiting
1281:../Dave/Generated/FREERTOS/queue.c **** 				task. */
1282:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1964              	 .loc 1 1282 0
 1965 00a8 BB6A     	 ldr r3,[r7,#40]
 1966 00aa 1B69     	 ldr r3,[r3,#16]
 1967 00ac 002B     	 cmp r3,#0
 1968 00ae 0FD0     	 beq .L141
1283:../Dave/Generated/FREERTOS/queue.c **** 				{
1284:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1969              	 .loc 1 1284 0
 1970 00b0 BB6A     	 ldr r3,[r7,#40]
 1971 00b2 1033     	 adds r3,r3,#16
 1972 00b4 1846     	 mov r0,r3
 1973 00b6 FFF7FEFF 	 bl xTaskRemoveFromEventList
 1974 00ba 0346     	 mov r3,r0
 1975 00bc 002B     	 cmp r3,#0
 1976 00be 07D0     	 beq .L141
1285:../Dave/Generated/FREERTOS/queue.c **** 					{
1286:../Dave/Generated/FREERTOS/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 1977              	 .loc 1 1286 0
 1978 00c0 3E4B     	 ldr r3,.L152
 1979 00c2 4FF08052 	 mov r2,#268435456
 1980 00c6 1A60     	 str r2,[r3]
 1981              	
 1982 00c8 BFF34F8F 	 dsb
 1983              	
 1984              	
 1985 00cc BFF36F8F 	 isb
 1986              	
 1987              	 .thumb
 1988              	.L141:
1287:../Dave/Generated/FREERTOS/queue.c **** 					}
1288:../Dave/Generated/FREERTOS/queue.c **** 					else
1289:../Dave/Generated/FREERTOS/queue.c **** 					{
1290:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1291:../Dave/Generated/FREERTOS/queue.c **** 					}
1292:../Dave/Generated/FREERTOS/queue.c **** 				}
1293:../Dave/Generated/FREERTOS/queue.c **** 				else
1294:../Dave/Generated/FREERTOS/queue.c **** 				{
1295:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1296:../Dave/Generated/FREERTOS/queue.c **** 				}
1297:../Dave/Generated/FREERTOS/queue.c **** 
1298:../Dave/Generated/FREERTOS/queue.c **** 				taskEXIT_CRITICAL();
 1989              	 .loc 1 1298 0
 1990 00d0 FFF7FEFF 	 bl vPortExitCritical
1299:../Dave/Generated/FREERTOS/queue.c **** 				return pdPASS;
 1991              	 .loc 1 1299 0
 1992 00d4 0123     	 movs r3,#1
 1993 00d6 6DE0     	 b .L151
 1994              	.L140:
1300:../Dave/Generated/FREERTOS/queue.c **** 			}
1301:../Dave/Generated/FREERTOS/queue.c **** 			else
1302:../Dave/Generated/FREERTOS/queue.c **** 			{
1303:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1995              	 .loc 1 1303 0
 1996 00d8 7B68     	 ldr r3,[r7,#4]
 1997 00da 002B     	 cmp r3,#0
 1998 00dc 03D1     	 bne .L143
1304:../Dave/Generated/FREERTOS/queue.c **** 				{
1305:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was empty and no block time is specified (or
1306:../Dave/Generated/FREERTOS/queue.c **** 					the block time has expired) so leave now. */
1307:../Dave/Generated/FREERTOS/queue.c **** 					taskEXIT_CRITICAL();
 1999              	 .loc 1 1307 0
 2000 00de FFF7FEFF 	 bl vPortExitCritical
1308:../Dave/Generated/FREERTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1309:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_EMPTY;
 2001              	 .loc 1 1309 0
 2002 00e2 0023     	 movs r3,#0
 2003 00e4 66E0     	 b .L151
 2004              	.L143:
1310:../Dave/Generated/FREERTOS/queue.c **** 				}
1311:../Dave/Generated/FREERTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 2005              	 .loc 1 1311 0
 2006 00e6 FB6A     	 ldr r3,[r7,#44]
 2007 00e8 002B     	 cmp r3,#0
 2008 00ea 06D1     	 bne .L144
1312:../Dave/Generated/FREERTOS/queue.c **** 				{
1313:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was empty and a block time was specified so
1314:../Dave/Generated/FREERTOS/queue.c **** 					configure the timeout structure. */
1315:../Dave/Generated/FREERTOS/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 2009              	 .loc 1 1315 0
 2010 00ec 07F11003 	 add r3,r7,#16
 2011 00f0 1846     	 mov r0,r3
 2012 00f2 FFF7FEFF 	 bl vTaskInternalSetTimeOutState
1316:../Dave/Generated/FREERTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 2013              	 .loc 1 1316 0
 2014 00f6 0123     	 movs r3,#1
 2015 00f8 FB62     	 str r3,[r7,#44]
 2016              	.L144:
 2017              	.LBE159:
1317:../Dave/Generated/FREERTOS/queue.c **** 				}
1318:../Dave/Generated/FREERTOS/queue.c **** 				else
1319:../Dave/Generated/FREERTOS/queue.c **** 				{
1320:../Dave/Generated/FREERTOS/queue.c **** 					/* Entry time was already set. */
1321:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1322:../Dave/Generated/FREERTOS/queue.c **** 				}
1323:../Dave/Generated/FREERTOS/queue.c **** 			}
1324:../Dave/Generated/FREERTOS/queue.c **** 		}
1325:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 2018              	 .loc 1 1325 0
 2019 00fa FFF7FEFF 	 bl vPortExitCritical
1326:../Dave/Generated/FREERTOS/queue.c **** 
1327:../Dave/Generated/FREERTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1328:../Dave/Generated/FREERTOS/queue.c **** 		now the critical section has been exited. */
1329:../Dave/Generated/FREERTOS/queue.c **** 
1330:../Dave/Generated/FREERTOS/queue.c **** 		vTaskSuspendAll();
 2020              	 .loc 1 1330 0
 2021 00fe FFF7FEFF 	 bl vTaskSuspendAll
1331:../Dave/Generated/FREERTOS/queue.c **** 		prvLockQueue( pxQueue );
 2022              	 .loc 1 1331 0
 2023 0102 FFF7FEFF 	 bl vPortEnterCritical
 2024 0106 BB6A     	 ldr r3,[r7,#40]
 2025 0108 93F84430 	 ldrb r3,[r3,#68]
 2026 010c DBB2     	 uxtb r3,r3
 2027 010e 5BB2     	 sxtb r3,r3
 2028 0110 B3F1FF3F 	 cmp r3,#-1
 2029 0114 03D1     	 bne .L145
 2030              	 .loc 1 1331 0 is_stmt 0 discriminator 1
 2031 0116 BB6A     	 ldr r3,[r7,#40]
 2032 0118 0022     	 movs r2,#0
 2033 011a 83F84420 	 strb r2,[r3,#68]
 2034              	.L145:
 2035              	 .loc 1 1331 0 discriminator 3
 2036 011e BB6A     	 ldr r3,[r7,#40]
 2037 0120 93F84530 	 ldrb r3,[r3,#69]
 2038 0124 DBB2     	 uxtb r3,r3
 2039 0126 5BB2     	 sxtb r3,r3
 2040 0128 B3F1FF3F 	 cmp r3,#-1
 2041 012c 03D1     	 bne .L146
 2042              	 .loc 1 1331 0 discriminator 4
 2043 012e BB6A     	 ldr r3,[r7,#40]
 2044 0130 0022     	 movs r2,#0
 2045 0132 83F84520 	 strb r2,[r3,#69]
 2046              	.L146:
 2047              	 .loc 1 1331 0 discriminator 6
 2048 0136 FFF7FEFF 	 bl vPortExitCritical
1332:../Dave/Generated/FREERTOS/queue.c **** 
1333:../Dave/Generated/FREERTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1334:../Dave/Generated/FREERTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 2049              	 .loc 1 1334 0 is_stmt 1 discriminator 6
 2050 013a 07F11002 	 add r2,r7,#16
 2051 013e 3B1D     	 adds r3,r7,#4
 2052 0140 1046     	 mov r0,r2
 2053 0142 1946     	 mov r1,r3
 2054 0144 FFF7FEFF 	 bl xTaskCheckForTimeOut
 2055 0148 0346     	 mov r3,r0
 2056 014a 002B     	 cmp r3,#0
 2057 014c 24D1     	 bne .L147
1335:../Dave/Generated/FREERTOS/queue.c **** 		{
1336:../Dave/Generated/FREERTOS/queue.c **** 			/* The timeout has not expired.  If the queue is still empty place
1337:../Dave/Generated/FREERTOS/queue.c **** 			the task on the list of tasks waiting to receive from the queue. */
1338:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2058              	 .loc 1 1338 0
 2059 014e B86A     	 ldr r0,[r7,#40]
 2060 0150 FFF7FEFF 	 bl prvIsQueueEmpty
 2061 0154 0346     	 mov r3,r0
 2062 0156 002B     	 cmp r3,#0
 2063 0158 18D0     	 beq .L148
1339:../Dave/Generated/FREERTOS/queue.c **** 			{
1340:../Dave/Generated/FREERTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1341:../Dave/Generated/FREERTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2064              	 .loc 1 1341 0
 2065 015a BB6A     	 ldr r3,[r7,#40]
 2066 015c 03F12402 	 add r2,r3,#36
 2067 0160 7B68     	 ldr r3,[r7,#4]
 2068 0162 1046     	 mov r0,r2
 2069 0164 1946     	 mov r1,r3
 2070 0166 FFF7FEFF 	 bl vTaskPlaceOnEventList
1342:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2071              	 .loc 1 1342 0
 2072 016a B86A     	 ldr r0,[r7,#40]
 2073 016c FFF7FEFF 	 bl prvUnlockQueue
1343:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 2074              	 .loc 1 1343 0
 2075 0170 FFF7FEFF 	 bl xTaskResumeAll
 2076 0174 0346     	 mov r3,r0
 2077 0176 002B     	 cmp r3,#0
 2078 0178 1BD1     	 bne .L150
1344:../Dave/Generated/FREERTOS/queue.c **** 				{
1345:../Dave/Generated/FREERTOS/queue.c **** 					portYIELD_WITHIN_API();
 2079              	 .loc 1 1345 0
 2080 017a 104B     	 ldr r3,.L152
 2081 017c 4FF08052 	 mov r2,#268435456
 2082 0180 1A60     	 str r2,[r3]
 2083              	
 2084 0182 BFF34F8F 	 dsb
 2085              	
 2086              	
 2087 0186 BFF36F8F 	 isb
 2088              	
 2089              	 .thumb
 2090 018a 12E0     	 b .L150
 2091              	.L148:
1346:../Dave/Generated/FREERTOS/queue.c **** 				}
1347:../Dave/Generated/FREERTOS/queue.c **** 				else
1348:../Dave/Generated/FREERTOS/queue.c **** 				{
1349:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1350:../Dave/Generated/FREERTOS/queue.c **** 				}
1351:../Dave/Generated/FREERTOS/queue.c **** 			}
1352:../Dave/Generated/FREERTOS/queue.c **** 			else
1353:../Dave/Generated/FREERTOS/queue.c **** 			{
1354:../Dave/Generated/FREERTOS/queue.c **** 				/* The queue contains data again.  Loop back to try and read the
1355:../Dave/Generated/FREERTOS/queue.c **** 				data. */
1356:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2092              	 .loc 1 1356 0
 2093 018c B86A     	 ldr r0,[r7,#40]
 2094 018e FFF7FEFF 	 bl prvUnlockQueue
1357:../Dave/Generated/FREERTOS/queue.c **** 				( void ) xTaskResumeAll();
 2095              	 .loc 1 1357 0
 2096 0192 FFF7FEFF 	 bl xTaskResumeAll
 2097 0196 77E7     	 b .L138
 2098              	.L147:
1358:../Dave/Generated/FREERTOS/queue.c **** 			}
1359:../Dave/Generated/FREERTOS/queue.c **** 		}
1360:../Dave/Generated/FREERTOS/queue.c **** 		else
1361:../Dave/Generated/FREERTOS/queue.c **** 		{
1362:../Dave/Generated/FREERTOS/queue.c **** 			/* Timed out.  If there is no data in the queue exit, otherwise loop
1363:../Dave/Generated/FREERTOS/queue.c **** 			back and attempt to read the data. */
1364:../Dave/Generated/FREERTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 2099              	 .loc 1 1364 0
 2100 0198 B86A     	 ldr r0,[r7,#40]
 2101 019a FFF7FEFF 	 bl prvUnlockQueue
1365:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xTaskResumeAll();
 2102              	 .loc 1 1365 0
 2103 019e FFF7FEFF 	 bl xTaskResumeAll
1366:../Dave/Generated/FREERTOS/queue.c **** 
1367:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2104              	 .loc 1 1367 0
 2105 01a2 B86A     	 ldr r0,[r7,#40]
 2106 01a4 FFF7FEFF 	 bl prvIsQueueEmpty
 2107 01a8 0346     	 mov r3,r0
 2108 01aa 002B     	 cmp r3,#0
 2109 01ac 01D0     	 beq .L150
1368:../Dave/Generated/FREERTOS/queue.c **** 			{
1369:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1370:../Dave/Generated/FREERTOS/queue.c **** 				return errQUEUE_EMPTY;
 2110              	 .loc 1 1370 0
 2111 01ae 0023     	 movs r3,#0
 2112 01b0 00E0     	 b .L151
 2113              	.L150:
1371:../Dave/Generated/FREERTOS/queue.c **** 			}
1372:../Dave/Generated/FREERTOS/queue.c **** 			else
1373:../Dave/Generated/FREERTOS/queue.c **** 			{
1374:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1375:../Dave/Generated/FREERTOS/queue.c **** 			}
1376:../Dave/Generated/FREERTOS/queue.c **** 		}
1377:../Dave/Generated/FREERTOS/queue.c **** 	}
 2114              	 .loc 1 1377 0 discriminator 5
 2115 01b2 69E7     	 b .L138
 2116              	.L151:
1378:../Dave/Generated/FREERTOS/queue.c **** }
 2117              	 .loc 1 1378 0 discriminator 6
 2118 01b4 1846     	 mov r0,r3
 2119 01b6 3037     	 adds r7,r7,#48
 2120              	.LCFI69:
 2121              	 .cfi_def_cfa_offset 8
 2122 01b8 BD46     	 mov sp,r7
 2123              	.LCFI70:
 2124              	 .cfi_def_cfa_register 13
 2125              	 
 2126 01ba 80BD     	 pop {r7,pc}
 2127              	.L153:
 2128              	 .align 2
 2129              	.L152:
 2130 01bc 04ED00E0 	 .word -536810236
 2131              	 .cfi_endproc
 2132              	.LFE148:
 2134              	 .section .text.xQueueSemaphoreTake,"ax",%progbits
 2135              	 .align 2
 2136              	 .global xQueueSemaphoreTake
 2137              	 .thumb
 2138              	 .thumb_func
 2140              	xQueueSemaphoreTake:
 2141              	.LFB149:
1379:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1380:../Dave/Generated/FREERTOS/queue.c **** 
1381:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
1382:../Dave/Generated/FREERTOS/queue.c **** {
 2142              	 .loc 1 1382 0
 2143              	 .cfi_startproc
 2144              	 
 2145              	 
 2146 0000 80B5     	 push {r7,lr}
 2147              	.LCFI71:
 2148              	 .cfi_def_cfa_offset 8
 2149              	 .cfi_offset 7,-8
 2150              	 .cfi_offset 14,-4
 2151 0002 8EB0     	 sub sp,sp,#56
 2152              	.LCFI72:
 2153              	 .cfi_def_cfa_offset 64
 2154 0004 00AF     	 add r7,sp,#0
 2155              	.LCFI73:
 2156              	 .cfi_def_cfa_register 7
 2157 0006 7860     	 str r0,[r7,#4]
 2158 0008 3960     	 str r1,[r7]
1383:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 2159              	 .loc 1 1383 0
 2160 000a 0023     	 movs r3,#0
 2161 000c 7B63     	 str r3,[r7,#52]
1384:../Dave/Generated/FREERTOS/queue.c **** TimeOut_t xTimeOut;
1385:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2162              	 .loc 1 1385 0
 2163 000e 7B68     	 ldr r3,[r7,#4]
 2164 0010 FB62     	 str r3,[r7,#44]
1386:../Dave/Generated/FREERTOS/queue.c **** 
1387:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_MUTEXES == 1 )
1388:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xInheritanceOccurred = pdFALSE;
 2165              	 .loc 1 1388 0
 2166 0012 0023     	 movs r3,#0
 2167 0014 3B63     	 str r3,[r7,#48]
1389:../Dave/Generated/FREERTOS/queue.c **** #endif
1390:../Dave/Generated/FREERTOS/queue.c **** 
1391:../Dave/Generated/FREERTOS/queue.c **** 	/* Check the queue pointer is not NULL. */
1392:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( ( pxQueue ) );
 2168              	 .loc 1 1392 0
 2169 0016 FB6A     	 ldr r3,[r7,#44]
 2170 0018 002B     	 cmp r3,#0
 2171 001a 09D1     	 bne .L155
 2172              	.LBB160:
 2173              	.LBB161:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2174              	 .loc 2 195 0 discriminator 1
 2175              	
 2176 001c 4FF0FC03 	 mov r3,#252
 2177 0020 83F31188 	 msr basepri,r3
 2178 0024 BFF36F8F 	 isb 
 2179 0028 BFF34F8F 	 dsb 
 2180              	
 2181              	
 2182              	 .thumb
 2183 002c 3B62     	 str r3,[r7,#32]
 2184              	.L156:
 2185              	.LBE161:
 2186              	.LBE160:
 2187              	 .loc 1 1392 0 discriminator 1
 2188 002e FEE7     	 b .L156
 2189              	.L155:
1393:../Dave/Generated/FREERTOS/queue.c **** 
1394:../Dave/Generated/FREERTOS/queue.c **** 	/* Check this really is a semaphore, in which case the item size will be
1395:../Dave/Generated/FREERTOS/queue.c **** 	0. */
1396:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
 2190              	 .loc 1 1396 0
 2191 0030 FB6A     	 ldr r3,[r7,#44]
 2192 0032 1B6C     	 ldr r3,[r3,#64]
 2193 0034 002B     	 cmp r3,#0
 2194 0036 09D0     	 beq .L157
 2195              	.LBB162:
 2196              	.LBB163:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2197              	 .loc 2 195 0 discriminator 1
 2198              	
 2199 0038 4FF0FC03 	 mov r3,#252
 2200 003c 83F31188 	 msr basepri,r3
 2201 0040 BFF36F8F 	 isb 
 2202 0044 BFF34F8F 	 dsb 
 2203              	
 2204              	
 2205              	 .thumb
 2206 0048 FB61     	 str r3,[r7,#28]
 2207              	.L158:
 2208              	.LBE163:
 2209              	.LBE162:
 2210              	 .loc 1 1396 0 discriminator 2
 2211 004a FEE7     	 b .L158
 2212              	.L157:
1397:../Dave/Generated/FREERTOS/queue.c **** 
1398:../Dave/Generated/FREERTOS/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1399:../Dave/Generated/FREERTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1400:../Dave/Generated/FREERTOS/queue.c **** 	{
1401:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 2213              	 .loc 1 1401 0
 2214 004c FFF7FEFF 	 bl xTaskGetSchedulerState
 2215 0050 0346     	 mov r3,r0
 2216 0052 002B     	 cmp r3,#0
 2217 0054 02D1     	 bne .L159
 2218              	 .loc 1 1401 0 is_stmt 0 discriminator 2
 2219 0056 3B68     	 ldr r3,[r7]
 2220 0058 002B     	 cmp r3,#0
 2221 005a 01D1     	 bne .L160
 2222              	.L159:
 2223              	 .loc 1 1401 0 discriminator 3
 2224 005c 0123     	 movs r3,#1
 2225 005e 00E0     	 b .L161
 2226              	.L160:
 2227              	 .loc 1 1401 0 discriminator 4
 2228 0060 0023     	 movs r3,#0
 2229              	.L161:
 2230              	 .loc 1 1401 0 discriminator 6
 2231 0062 002B     	 cmp r3,#0
 2232 0064 09D1     	 bne .L162
 2233              	.LBB164:
 2234              	.LBB165:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2235              	 .loc 2 195 0 is_stmt 1 discriminator 7
 2236              	
 2237 0066 4FF0FC03 	 mov r3,#252
 2238 006a 83F31188 	 msr basepri,r3
 2239 006e BFF36F8F 	 isb 
 2240 0072 BFF34F8F 	 dsb 
 2241              	
 2242              	
 2243              	 .thumb
 2244 0076 BB61     	 str r3,[r7,#24]
 2245              	.L163:
 2246              	.LBE165:
 2247              	.LBE164:
 2248              	 .loc 1 1401 0 discriminator 3
 2249 0078 FEE7     	 b .L163
 2250              	.L162:
1402:../Dave/Generated/FREERTOS/queue.c **** 	}
1403:../Dave/Generated/FREERTOS/queue.c **** 	#endif
1404:../Dave/Generated/FREERTOS/queue.c **** 
1405:../Dave/Generated/FREERTOS/queue.c **** 
1406:../Dave/Generated/FREERTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1407:../Dave/Generated/FREERTOS/queue.c **** 	statements within the function itself.  This is done in the interest
1408:../Dave/Generated/FREERTOS/queue.c **** 	of execution time efficiency. */
1409:../Dave/Generated/FREERTOS/queue.c **** 
1410:../Dave/Generated/FREERTOS/queue.c **** 	for( ;; )
1411:../Dave/Generated/FREERTOS/queue.c **** 	{
1412:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 2251              	 .loc 1 1412 0
 2252 007a FFF7FEFF 	 bl vPortEnterCritical
 2253              	.LBB166:
1413:../Dave/Generated/FREERTOS/queue.c **** 		{
1414:../Dave/Generated/FREERTOS/queue.c **** 			/* Semaphores are queues with an item size of 0, and where the
1415:../Dave/Generated/FREERTOS/queue.c **** 			number of messages in the queue is the semaphore's count value. */
1416:../Dave/Generated/FREERTOS/queue.c **** 			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 2254              	 .loc 1 1416 0
 2255 007e FB6A     	 ldr r3,[r7,#44]
 2256 0080 9B6B     	 ldr r3,[r3,#56]
 2257 0082 BB62     	 str r3,[r7,#40]
1417:../Dave/Generated/FREERTOS/queue.c **** 
1418:../Dave/Generated/FREERTOS/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1419:../Dave/Generated/FREERTOS/queue.c **** 			must be the highest priority task wanting to access the queue. */
1420:../Dave/Generated/FREERTOS/queue.c **** 			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 2258              	 .loc 1 1420 0
 2259 0084 BB6A     	 ldr r3,[r7,#40]
 2260 0086 002B     	 cmp r3,#0
 2261 0088 24D0     	 beq .L164
1421:../Dave/Generated/FREERTOS/queue.c **** 			{
1422:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1423:../Dave/Generated/FREERTOS/queue.c **** 
1424:../Dave/Generated/FREERTOS/queue.c **** 				/* Semaphores are queues with a data size of zero and where the
1425:../Dave/Generated/FREERTOS/queue.c **** 				messages waiting is the semaphore's count.  Reduce the count. */
1426:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 2262              	 .loc 1 1426 0
 2263 008a BB6A     	 ldr r3,[r7,#40]
 2264 008c 5A1E     	 subs r2,r3,#1
 2265 008e FB6A     	 ldr r3,[r7,#44]
 2266 0090 9A63     	 str r2,[r3,#56]
1427:../Dave/Generated/FREERTOS/queue.c **** 
1428:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1429:../Dave/Generated/FREERTOS/queue.c **** 				{
1430:../Dave/Generated/FREERTOS/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2267              	 .loc 1 1430 0
 2268 0092 FB6A     	 ldr r3,[r7,#44]
 2269 0094 1B68     	 ldr r3,[r3]
 2270 0096 002B     	 cmp r3,#0
 2271 0098 04D1     	 bne .L165
1431:../Dave/Generated/FREERTOS/queue.c **** 					{
1432:../Dave/Generated/FREERTOS/queue.c **** 						/* Record the information required to implement
1433:../Dave/Generated/FREERTOS/queue.c **** 						priority inheritance should it become necessary. */
1434:../Dave/Generated/FREERTOS/queue.c **** 						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is n
 2272              	 .loc 1 1434 0
 2273 009a FFF7FEFF 	 bl pvTaskIncrementMutexHeldCount
 2274 009e 0246     	 mov r2,r0
 2275 00a0 FB6A     	 ldr r3,[r7,#44]
 2276 00a2 5A60     	 str r2,[r3,#4]
 2277              	.L165:
1435:../Dave/Generated/FREERTOS/queue.c **** 					}
1436:../Dave/Generated/FREERTOS/queue.c **** 					else
1437:../Dave/Generated/FREERTOS/queue.c **** 					{
1438:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1439:../Dave/Generated/FREERTOS/queue.c **** 					}
1440:../Dave/Generated/FREERTOS/queue.c **** 				}
1441:../Dave/Generated/FREERTOS/queue.c **** 				#endif /* configUSE_MUTEXES */
1442:../Dave/Generated/FREERTOS/queue.c **** 
1443:../Dave/Generated/FREERTOS/queue.c **** 				/* Check to see if other tasks are blocked waiting to give the
1444:../Dave/Generated/FREERTOS/queue.c **** 				semaphore, and if so, unblock the highest priority such task. */
1445:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2278              	 .loc 1 1445 0
 2279 00a4 FB6A     	 ldr r3,[r7,#44]
 2280 00a6 1B69     	 ldr r3,[r3,#16]
 2281 00a8 002B     	 cmp r3,#0
 2282 00aa 0FD0     	 beq .L166
1446:../Dave/Generated/FREERTOS/queue.c **** 				{
1447:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2283              	 .loc 1 1447 0
 2284 00ac FB6A     	 ldr r3,[r7,#44]
 2285 00ae 1033     	 adds r3,r3,#16
 2286 00b0 1846     	 mov r0,r3
 2287 00b2 FFF7FEFF 	 bl xTaskRemoveFromEventList
 2288 00b6 0346     	 mov r3,r0
 2289 00b8 002B     	 cmp r3,#0
 2290 00ba 07D0     	 beq .L166
1448:../Dave/Generated/FREERTOS/queue.c **** 					{
1449:../Dave/Generated/FREERTOS/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 2291              	 .loc 1 1449 0
 2292 00bc 544B     	 ldr r3,.L181
 2293 00be 4FF08052 	 mov r2,#268435456
 2294 00c2 1A60     	 str r2,[r3]
 2295              	
 2296 00c4 BFF34F8F 	 dsb
 2297              	
 2298              	
 2299 00c8 BFF36F8F 	 isb
 2300              	
 2301              	 .thumb
 2302              	.L166:
1450:../Dave/Generated/FREERTOS/queue.c **** 					}
1451:../Dave/Generated/FREERTOS/queue.c **** 					else
1452:../Dave/Generated/FREERTOS/queue.c **** 					{
1453:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1454:../Dave/Generated/FREERTOS/queue.c **** 					}
1455:../Dave/Generated/FREERTOS/queue.c **** 				}
1456:../Dave/Generated/FREERTOS/queue.c **** 				else
1457:../Dave/Generated/FREERTOS/queue.c **** 				{
1458:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1459:../Dave/Generated/FREERTOS/queue.c **** 				}
1460:../Dave/Generated/FREERTOS/queue.c **** 
1461:../Dave/Generated/FREERTOS/queue.c **** 				taskEXIT_CRITICAL();
 2303              	 .loc 1 1461 0
 2304 00cc FFF7FEFF 	 bl vPortExitCritical
1462:../Dave/Generated/FREERTOS/queue.c **** 				return pdPASS;
 2305              	 .loc 1 1462 0
 2306 00d0 0123     	 movs r3,#1
 2307 00d2 99E0     	 b .L180
 2308              	.L164:
1463:../Dave/Generated/FREERTOS/queue.c **** 			}
1464:../Dave/Generated/FREERTOS/queue.c **** 			else
1465:../Dave/Generated/FREERTOS/queue.c **** 			{
1466:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 2309              	 .loc 1 1466 0
 2310 00d4 3B68     	 ldr r3,[r7]
 2311 00d6 002B     	 cmp r3,#0
 2312 00d8 10D1     	 bne .L168
1467:../Dave/Generated/FREERTOS/queue.c **** 				{
1468:../Dave/Generated/FREERTOS/queue.c **** 					/* For inheritance to have occurred there must have been an
1469:../Dave/Generated/FREERTOS/queue.c **** 					initial timeout, and an adjusted timeout cannot become 0, as
1470:../Dave/Generated/FREERTOS/queue.c **** 					if it were 0 the function would have exited. */
1471:../Dave/Generated/FREERTOS/queue.c **** 					#if( configUSE_MUTEXES == 1 )
1472:../Dave/Generated/FREERTOS/queue.c **** 					{
1473:../Dave/Generated/FREERTOS/queue.c **** 						configASSERT( xInheritanceOccurred == pdFALSE );
 2313              	 .loc 1 1473 0
 2314 00da 3B6B     	 ldr r3,[r7,#48]
 2315 00dc 002B     	 cmp r3,#0
 2316 00de 09D0     	 beq .L169
 2317              	.LBB167:
 2318              	.LBB168:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2319              	 .loc 2 195 0 discriminator 1
 2320              	
 2321 00e0 4FF0FC03 	 mov r3,#252
 2322 00e4 83F31188 	 msr basepri,r3
 2323 00e8 BFF36F8F 	 isb 
 2324 00ec BFF34F8F 	 dsb 
 2325              	
 2326              	
 2327              	 .thumb
 2328 00f0 7B61     	 str r3,[r7,#20]
 2329              	.L170:
 2330              	.LBE168:
 2331              	.LBE167:
 2332              	 .loc 1 1473 0 discriminator 4
 2333 00f2 FEE7     	 b .L170
 2334              	.L169:
1474:../Dave/Generated/FREERTOS/queue.c **** 					}
1475:../Dave/Generated/FREERTOS/queue.c **** 					#endif /* configUSE_MUTEXES */
1476:../Dave/Generated/FREERTOS/queue.c **** 
1477:../Dave/Generated/FREERTOS/queue.c **** 					/* The semaphore count was 0 and no block time is specified
1478:../Dave/Generated/FREERTOS/queue.c **** 					(or the block time has expired) so exit now. */
1479:../Dave/Generated/FREERTOS/queue.c **** 					taskEXIT_CRITICAL();
 2335              	 .loc 1 1479 0
 2336 00f4 FFF7FEFF 	 bl vPortExitCritical
1480:../Dave/Generated/FREERTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1481:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_EMPTY;
 2337              	 .loc 1 1481 0
 2338 00f8 0023     	 movs r3,#0
 2339 00fa 85E0     	 b .L180
 2340              	.L168:
1482:../Dave/Generated/FREERTOS/queue.c **** 				}
1483:../Dave/Generated/FREERTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 2341              	 .loc 1 1483 0
 2342 00fc 7B6B     	 ldr r3,[r7,#52]
 2343 00fe 002B     	 cmp r3,#0
 2344 0100 06D1     	 bne .L171
1484:../Dave/Generated/FREERTOS/queue.c **** 				{
1485:../Dave/Generated/FREERTOS/queue.c **** 					/* The semaphore count was 0 and a block time was specified
1486:../Dave/Generated/FREERTOS/queue.c **** 					so configure the timeout structure ready to block. */
1487:../Dave/Generated/FREERTOS/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 2345              	 .loc 1 1487 0
 2346 0102 07F10C03 	 add r3,r7,#12
 2347 0106 1846     	 mov r0,r3
 2348 0108 FFF7FEFF 	 bl vTaskInternalSetTimeOutState
1488:../Dave/Generated/FREERTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 2349              	 .loc 1 1488 0
 2350 010c 0123     	 movs r3,#1
 2351 010e 7B63     	 str r3,[r7,#52]
 2352              	.L171:
 2353              	.LBE166:
1489:../Dave/Generated/FREERTOS/queue.c **** 				}
1490:../Dave/Generated/FREERTOS/queue.c **** 				else
1491:../Dave/Generated/FREERTOS/queue.c **** 				{
1492:../Dave/Generated/FREERTOS/queue.c **** 					/* Entry time was already set. */
1493:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1494:../Dave/Generated/FREERTOS/queue.c **** 				}
1495:../Dave/Generated/FREERTOS/queue.c **** 			}
1496:../Dave/Generated/FREERTOS/queue.c **** 		}
1497:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 2354              	 .loc 1 1497 0
 2355 0110 FFF7FEFF 	 bl vPortExitCritical
1498:../Dave/Generated/FREERTOS/queue.c **** 
1499:../Dave/Generated/FREERTOS/queue.c **** 		/* Interrupts and other tasks can give to and take from the semaphore
1500:../Dave/Generated/FREERTOS/queue.c **** 		now the critical section has been exited. */
1501:../Dave/Generated/FREERTOS/queue.c **** 
1502:../Dave/Generated/FREERTOS/queue.c **** 		vTaskSuspendAll();
 2356              	 .loc 1 1502 0
 2357 0114 FFF7FEFF 	 bl vTaskSuspendAll
1503:../Dave/Generated/FREERTOS/queue.c **** 		prvLockQueue( pxQueue );
 2358              	 .loc 1 1503 0
 2359 0118 FFF7FEFF 	 bl vPortEnterCritical
 2360 011c FB6A     	 ldr r3,[r7,#44]
 2361 011e 93F84430 	 ldrb r3,[r3,#68]
 2362 0122 DBB2     	 uxtb r3,r3
 2363 0124 5BB2     	 sxtb r3,r3
 2364 0126 B3F1FF3F 	 cmp r3,#-1
 2365 012a 03D1     	 bne .L172
 2366              	 .loc 1 1503 0 is_stmt 0 discriminator 1
 2367 012c FB6A     	 ldr r3,[r7,#44]
 2368 012e 0022     	 movs r2,#0
 2369 0130 83F84420 	 strb r2,[r3,#68]
 2370              	.L172:
 2371              	 .loc 1 1503 0 discriminator 3
 2372 0134 FB6A     	 ldr r3,[r7,#44]
 2373 0136 93F84530 	 ldrb r3,[r3,#69]
 2374 013a DBB2     	 uxtb r3,r3
 2375 013c 5BB2     	 sxtb r3,r3
 2376 013e B3F1FF3F 	 cmp r3,#-1
 2377 0142 03D1     	 bne .L173
 2378              	 .loc 1 1503 0 discriminator 4
 2379 0144 FB6A     	 ldr r3,[r7,#44]
 2380 0146 0022     	 movs r2,#0
 2381 0148 83F84520 	 strb r2,[r3,#69]
 2382              	.L173:
 2383              	 .loc 1 1503 0 discriminator 6
 2384 014c FFF7FEFF 	 bl vPortExitCritical
1504:../Dave/Generated/FREERTOS/queue.c **** 
1505:../Dave/Generated/FREERTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1506:../Dave/Generated/FREERTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 2385              	 .loc 1 1506 0 is_stmt 1 discriminator 6
 2386 0150 07F10C02 	 add r2,r7,#12
 2387 0154 3B46     	 mov r3,r7
 2388 0156 1046     	 mov r0,r2
 2389 0158 1946     	 mov r1,r3
 2390 015a FFF7FEFF 	 bl xTaskCheckForTimeOut
 2391 015e 0346     	 mov r3,r0
 2392 0160 002B     	 cmp r3,#0
 2393 0162 32D1     	 bne .L174
1507:../Dave/Generated/FREERTOS/queue.c **** 		{
1508:../Dave/Generated/FREERTOS/queue.c **** 			/* A block time is specified and not expired.  If the semaphore
1509:../Dave/Generated/FREERTOS/queue.c **** 			count is 0 then enter the Blocked state to wait for a semaphore to
1510:../Dave/Generated/FREERTOS/queue.c **** 			become available.  As semaphores are implemented with queues the
1511:../Dave/Generated/FREERTOS/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1512:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2394              	 .loc 1 1512 0
 2395 0164 F86A     	 ldr r0,[r7,#44]
 2396 0166 FFF7FEFF 	 bl prvIsQueueEmpty
 2397 016a 0346     	 mov r3,r0
 2398 016c 002B     	 cmp r3,#0
 2399 016e 26D0     	 beq .L175
1513:../Dave/Generated/FREERTOS/queue.c **** 			{
1514:../Dave/Generated/FREERTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1515:../Dave/Generated/FREERTOS/queue.c **** 
1516:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1517:../Dave/Generated/FREERTOS/queue.c **** 				{
1518:../Dave/Generated/FREERTOS/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2400              	 .loc 1 1518 0
 2401 0170 FB6A     	 ldr r3,[r7,#44]
 2402 0172 1B68     	 ldr r3,[r3]
 2403 0174 002B     	 cmp r3,#0
 2404 0176 09D1     	 bne .L176
1519:../Dave/Generated/FREERTOS/queue.c **** 					{
1520:../Dave/Generated/FREERTOS/queue.c **** 						taskENTER_CRITICAL();
 2405              	 .loc 1 1520 0
 2406 0178 FFF7FEFF 	 bl vPortEnterCritical
1521:../Dave/Generated/FREERTOS/queue.c **** 						{
1522:../Dave/Generated/FREERTOS/queue.c **** 							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 2407              	 .loc 1 1522 0
 2408 017c FB6A     	 ldr r3,[r7,#44]
 2409 017e 5B68     	 ldr r3,[r3,#4]
 2410 0180 1846     	 mov r0,r3
 2411 0182 FFF7FEFF 	 bl xTaskPriorityInherit
 2412 0186 3863     	 str r0,[r7,#48]
1523:../Dave/Generated/FREERTOS/queue.c **** 						}
1524:../Dave/Generated/FREERTOS/queue.c **** 						taskEXIT_CRITICAL();
 2413              	 .loc 1 1524 0
 2414 0188 FFF7FEFF 	 bl vPortExitCritical
 2415              	.L176:
1525:../Dave/Generated/FREERTOS/queue.c **** 					}
1526:../Dave/Generated/FREERTOS/queue.c **** 					else
1527:../Dave/Generated/FREERTOS/queue.c **** 					{
1528:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1529:../Dave/Generated/FREERTOS/queue.c **** 					}
1530:../Dave/Generated/FREERTOS/queue.c **** 				}
1531:../Dave/Generated/FREERTOS/queue.c **** 				#endif
1532:../Dave/Generated/FREERTOS/queue.c **** 
1533:../Dave/Generated/FREERTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2416              	 .loc 1 1533 0
 2417 018c FB6A     	 ldr r3,[r7,#44]
 2418 018e 03F12402 	 add r2,r3,#36
 2419 0192 3B68     	 ldr r3,[r7]
 2420 0194 1046     	 mov r0,r2
 2421 0196 1946     	 mov r1,r3
 2422 0198 FFF7FEFF 	 bl vTaskPlaceOnEventList
1534:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2423              	 .loc 1 1534 0
 2424 019c F86A     	 ldr r0,[r7,#44]
 2425 019e FFF7FEFF 	 bl prvUnlockQueue
1535:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 2426              	 .loc 1 1535 0
 2427 01a2 FFF7FEFF 	 bl xTaskResumeAll
 2428 01a6 0346     	 mov r3,r0
 2429 01a8 002B     	 cmp r3,#0
 2430 01aa 2CD1     	 bne .L178
1536:../Dave/Generated/FREERTOS/queue.c **** 				{
1537:../Dave/Generated/FREERTOS/queue.c **** 					portYIELD_WITHIN_API();
 2431              	 .loc 1 1537 0
 2432 01ac 184B     	 ldr r3,.L181
 2433 01ae 4FF08052 	 mov r2,#268435456
 2434 01b2 1A60     	 str r2,[r3]
 2435              	
 2436 01b4 BFF34F8F 	 dsb
 2437              	
 2438              	
 2439 01b8 BFF36F8F 	 isb
 2440              	
 2441              	 .thumb
 2442 01bc 23E0     	 b .L178
 2443              	.L175:
1538:../Dave/Generated/FREERTOS/queue.c **** 				}
1539:../Dave/Generated/FREERTOS/queue.c **** 				else
1540:../Dave/Generated/FREERTOS/queue.c **** 				{
1541:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1542:../Dave/Generated/FREERTOS/queue.c **** 				}
1543:../Dave/Generated/FREERTOS/queue.c **** 			}
1544:../Dave/Generated/FREERTOS/queue.c **** 			else
1545:../Dave/Generated/FREERTOS/queue.c **** 			{
1546:../Dave/Generated/FREERTOS/queue.c **** 				/* There was no timeout and the semaphore count was not 0, so
1547:../Dave/Generated/FREERTOS/queue.c **** 				attempt to take the semaphore again. */
1548:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2444              	 .loc 1 1548 0
 2445 01be F86A     	 ldr r0,[r7,#44]
 2446 01c0 FFF7FEFF 	 bl prvUnlockQueue
1549:../Dave/Generated/FREERTOS/queue.c **** 				( void ) xTaskResumeAll();
 2447              	 .loc 1 1549 0
 2448 01c4 FFF7FEFF 	 bl xTaskResumeAll
 2449 01c8 57E7     	 b .L162
 2450              	.L174:
1550:../Dave/Generated/FREERTOS/queue.c **** 			}
1551:../Dave/Generated/FREERTOS/queue.c **** 		}
1552:../Dave/Generated/FREERTOS/queue.c **** 		else
1553:../Dave/Generated/FREERTOS/queue.c **** 		{
1554:../Dave/Generated/FREERTOS/queue.c **** 			/* Timed out. */
1555:../Dave/Generated/FREERTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 2451              	 .loc 1 1555 0
 2452 01ca F86A     	 ldr r0,[r7,#44]
 2453 01cc FFF7FEFF 	 bl prvUnlockQueue
1556:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xTaskResumeAll();
 2454              	 .loc 1 1556 0
 2455 01d0 FFF7FEFF 	 bl xTaskResumeAll
1557:../Dave/Generated/FREERTOS/queue.c **** 
1558:../Dave/Generated/FREERTOS/queue.c **** 			/* If the semaphore count is 0 exit now as the timeout has
1559:../Dave/Generated/FREERTOS/queue.c **** 			expired.  Otherwise return to attempt to take the semaphore that is
1560:../Dave/Generated/FREERTOS/queue.c **** 			known to be available.  As semaphores are implemented by queues the
1561:../Dave/Generated/FREERTOS/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1562:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2456              	 .loc 1 1562 0
 2457 01d4 F86A     	 ldr r0,[r7,#44]
 2458 01d6 FFF7FEFF 	 bl prvIsQueueEmpty
 2459 01da 0346     	 mov r3,r0
 2460 01dc 002B     	 cmp r3,#0
 2461 01de 12D0     	 beq .L178
1563:../Dave/Generated/FREERTOS/queue.c **** 			{
1564:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1565:../Dave/Generated/FREERTOS/queue.c **** 				{
1566:../Dave/Generated/FREERTOS/queue.c **** 					/* xInheritanceOccurred could only have be set if
1567:../Dave/Generated/FREERTOS/queue.c **** 					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1568:../Dave/Generated/FREERTOS/queue.c **** 					test the mutex type again to check it is actually a mutex. */
1569:../Dave/Generated/FREERTOS/queue.c **** 					if( xInheritanceOccurred != pdFALSE )
 2462              	 .loc 1 1569 0
 2463 01e0 3B6B     	 ldr r3,[r7,#48]
 2464 01e2 002B     	 cmp r3,#0
 2465 01e4 0DD0     	 beq .L179
1570:../Dave/Generated/FREERTOS/queue.c **** 					{
1571:../Dave/Generated/FREERTOS/queue.c **** 						taskENTER_CRITICAL();
 2466              	 .loc 1 1571 0
 2467 01e6 FFF7FEFF 	 bl vPortEnterCritical
 2468              	.LBB169:
1572:../Dave/Generated/FREERTOS/queue.c **** 						{
1573:../Dave/Generated/FREERTOS/queue.c **** 							UBaseType_t uxHighestWaitingPriority;
1574:../Dave/Generated/FREERTOS/queue.c **** 
1575:../Dave/Generated/FREERTOS/queue.c **** 							/* This task blocking on the mutex caused another
1576:../Dave/Generated/FREERTOS/queue.c **** 							task to inherit this task's priority.  Now this task
1577:../Dave/Generated/FREERTOS/queue.c **** 							has timed out the priority should be disinherited
1578:../Dave/Generated/FREERTOS/queue.c **** 							again, but only as low as the next highest priority
1579:../Dave/Generated/FREERTOS/queue.c **** 							task that is waiting for the same mutex. */
1580:../Dave/Generated/FREERTOS/queue.c **** 							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 2469              	 .loc 1 1580 0
 2470 01ea F86A     	 ldr r0,[r7,#44]
 2471 01ec FFF7FEFF 	 bl prvGetDisinheritPriorityAfterTimeout
 2472 01f0 7862     	 str r0,[r7,#36]
1581:../Dave/Generated/FREERTOS/queue.c **** 							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPrio
 2473              	 .loc 1 1581 0
 2474 01f2 FB6A     	 ldr r3,[r7,#44]
 2475 01f4 5B68     	 ldr r3,[r3,#4]
 2476 01f6 1846     	 mov r0,r3
 2477 01f8 796A     	 ldr r1,[r7,#36]
 2478 01fa FFF7FEFF 	 bl vTaskPriorityDisinheritAfterTimeout
 2479              	.LBE169:
1582:../Dave/Generated/FREERTOS/queue.c **** 						}
1583:../Dave/Generated/FREERTOS/queue.c **** 						taskEXIT_CRITICAL();
 2480              	 .loc 1 1583 0
 2481 01fe FFF7FEFF 	 bl vPortExitCritical
 2482              	.L179:
1584:../Dave/Generated/FREERTOS/queue.c **** 					}
1585:../Dave/Generated/FREERTOS/queue.c **** 				}
1586:../Dave/Generated/FREERTOS/queue.c **** 				#endif /* configUSE_MUTEXES */
1587:../Dave/Generated/FREERTOS/queue.c **** 
1588:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1589:../Dave/Generated/FREERTOS/queue.c **** 				return errQUEUE_EMPTY;
 2483              	 .loc 1 1589 0
 2484 0202 0023     	 movs r3,#0
 2485 0204 00E0     	 b .L180
 2486              	.L178:
1590:../Dave/Generated/FREERTOS/queue.c **** 			}
1591:../Dave/Generated/FREERTOS/queue.c **** 			else
1592:../Dave/Generated/FREERTOS/queue.c **** 			{
1593:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1594:../Dave/Generated/FREERTOS/queue.c **** 			}
1595:../Dave/Generated/FREERTOS/queue.c **** 		}
1596:../Dave/Generated/FREERTOS/queue.c **** 	}
 2487              	 .loc 1 1596 0 discriminator 6
 2488 0206 38E7     	 b .L162
 2489              	.L180:
1597:../Dave/Generated/FREERTOS/queue.c **** }
 2490              	 .loc 1 1597 0 discriminator 7
 2491 0208 1846     	 mov r0,r3
 2492 020a 3837     	 adds r7,r7,#56
 2493              	.LCFI74:
 2494              	 .cfi_def_cfa_offset 8
 2495 020c BD46     	 mov sp,r7
 2496              	.LCFI75:
 2497              	 .cfi_def_cfa_register 13
 2498              	 
 2499 020e 80BD     	 pop {r7,pc}
 2500              	.L182:
 2501              	 .align 2
 2502              	.L181:
 2503 0210 04ED00E0 	 .word -536810236
 2504              	 .cfi_endproc
 2505              	.LFE149:
 2507              	 .section .text.xQueuePeek,"ax",%progbits
 2508              	 .align 2
 2509              	 .global xQueuePeek
 2510              	 .thumb
 2511              	 .thumb_func
 2513              	xQueuePeek:
 2514              	.LFB150:
1598:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1599:../Dave/Generated/FREERTOS/queue.c **** 
1600:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1601:../Dave/Generated/FREERTOS/queue.c **** {
 2515              	 .loc 1 1601 0
 2516              	 .cfi_startproc
 2517              	 
 2518              	 
 2519 0000 80B5     	 push {r7,lr}
 2520              	.LCFI76:
 2521              	 .cfi_def_cfa_offset 8
 2522              	 .cfi_offset 7,-8
 2523              	 .cfi_offset 14,-4
 2524 0002 8EB0     	 sub sp,sp,#56
 2525              	.LCFI77:
 2526              	 .cfi_def_cfa_offset 64
 2527 0004 00AF     	 add r7,sp,#0
 2528              	.LCFI78:
 2529              	 .cfi_def_cfa_register 7
 2530 0006 F860     	 str r0,[r7,#12]
 2531 0008 B960     	 str r1,[r7,#8]
 2532 000a 7A60     	 str r2,[r7,#4]
1602:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 2533              	 .loc 1 1602 0
 2534 000c 0023     	 movs r3,#0
 2535 000e 7B63     	 str r3,[r7,#52]
1603:../Dave/Generated/FREERTOS/queue.c **** TimeOut_t xTimeOut;
1604:../Dave/Generated/FREERTOS/queue.c **** int8_t *pcOriginalReadPosition;
1605:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2536              	 .loc 1 1605 0
 2537 0010 FB68     	 ldr r3,[r7,#12]
 2538 0012 3B63     	 str r3,[r7,#48]
1606:../Dave/Generated/FREERTOS/queue.c **** 
1607:../Dave/Generated/FREERTOS/queue.c **** 	/* Check the pointer is not NULL. */
1608:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( ( pxQueue ) );
 2539              	 .loc 1 1608 0
 2540 0014 3B6B     	 ldr r3,[r7,#48]
 2541 0016 002B     	 cmp r3,#0
 2542 0018 09D1     	 bne .L184
 2543              	.LBB170:
 2544              	.LBB171:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2545              	 .loc 2 195 0 discriminator 1
 2546              	
 2547 001a 4FF0FC03 	 mov r3,#252
 2548 001e 83F31188 	 msr basepri,r3
 2549 0022 BFF36F8F 	 isb 
 2550 0026 BFF34F8F 	 dsb 
 2551              	
 2552              	
 2553              	 .thumb
 2554 002a 7B62     	 str r3,[r7,#36]
 2555              	.L185:
 2556              	.LBE171:
 2557              	.LBE170:
 2558              	 .loc 1 1608 0 discriminator 1
 2559 002c FEE7     	 b .L185
 2560              	.L184:
1609:../Dave/Generated/FREERTOS/queue.c **** 
1610:../Dave/Generated/FREERTOS/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1611:../Dave/Generated/FREERTOS/queue.c **** 	is zero (so no data is copied into the buffer. */
1612:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
 2561              	 .loc 1 1612 0
 2562 002e BB68     	 ldr r3,[r7,#8]
 2563 0030 002B     	 cmp r3,#0
 2564 0032 03D1     	 bne .L186
 2565              	 .loc 1 1612 0 is_stmt 0 discriminator 2
 2566 0034 3B6B     	 ldr r3,[r7,#48]
 2567 0036 1B6C     	 ldr r3,[r3,#64]
 2568 0038 002B     	 cmp r3,#0
 2569 003a 01D1     	 bne .L187
 2570              	.L186:
 2571              	 .loc 1 1612 0 discriminator 3
 2572 003c 0123     	 movs r3,#1
 2573 003e 00E0     	 b .L188
 2574              	.L187:
 2575              	 .loc 1 1612 0 discriminator 4
 2576 0040 0023     	 movs r3,#0
 2577              	.L188:
 2578              	 .loc 1 1612 0 discriminator 6
 2579 0042 002B     	 cmp r3,#0
 2580 0044 09D1     	 bne .L189
 2581              	.LBB172:
 2582              	.LBB173:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2583              	 .loc 2 195 0 is_stmt 1 discriminator 7
 2584              	
 2585 0046 4FF0FC03 	 mov r3,#252
 2586 004a 83F31188 	 msr basepri,r3
 2587 004e BFF36F8F 	 isb 
 2588 0052 BFF34F8F 	 dsb 
 2589              	
 2590              	
 2591              	 .thumb
 2592 0056 3B62     	 str r3,[r7,#32]
 2593              	.L190:
 2594              	.LBE173:
 2595              	.LBE172:
 2596              	 .loc 1 1612 0 discriminator 2
 2597 0058 FEE7     	 b .L190
 2598              	.L189:
1613:../Dave/Generated/FREERTOS/queue.c **** 
1614:../Dave/Generated/FREERTOS/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1615:../Dave/Generated/FREERTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1616:../Dave/Generated/FREERTOS/queue.c **** 	{
1617:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 2599              	 .loc 1 1617 0
 2600 005a FFF7FEFF 	 bl xTaskGetSchedulerState
 2601 005e 0346     	 mov r3,r0
 2602 0060 002B     	 cmp r3,#0
 2603 0062 02D1     	 bne .L191
 2604              	 .loc 1 1617 0 is_stmt 0 discriminator 2
 2605 0064 7B68     	 ldr r3,[r7,#4]
 2606 0066 002B     	 cmp r3,#0
 2607 0068 01D1     	 bne .L192
 2608              	.L191:
 2609              	 .loc 1 1617 0 discriminator 3
 2610 006a 0123     	 movs r3,#1
 2611 006c 00E0     	 b .L193
 2612              	.L192:
 2613              	 .loc 1 1617 0 discriminator 4
 2614 006e 0023     	 movs r3,#0
 2615              	.L193:
 2616              	 .loc 1 1617 0 discriminator 6
 2617 0070 002B     	 cmp r3,#0
 2618 0072 09D1     	 bne .L194
 2619              	.LBB174:
 2620              	.LBB175:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2621              	 .loc 2 195 0 is_stmt 1 discriminator 7
 2622              	
 2623 0074 4FF0FC03 	 mov r3,#252
 2624 0078 83F31188 	 msr basepri,r3
 2625 007c BFF36F8F 	 isb 
 2626 0080 BFF34F8F 	 dsb 
 2627              	
 2628              	
 2629              	 .thumb
 2630 0084 FB61     	 str r3,[r7,#28]
 2631              	.L195:
 2632              	.LBE175:
 2633              	.LBE174:
 2634              	 .loc 1 1617 0 discriminator 3
 2635 0086 FEE7     	 b .L195
 2636              	.L194:
1618:../Dave/Generated/FREERTOS/queue.c **** 	}
1619:../Dave/Generated/FREERTOS/queue.c **** 	#endif
1620:../Dave/Generated/FREERTOS/queue.c **** 
1621:../Dave/Generated/FREERTOS/queue.c **** 
1622:../Dave/Generated/FREERTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1623:../Dave/Generated/FREERTOS/queue.c **** 	statements within the function itself.  This is done in the interest
1624:../Dave/Generated/FREERTOS/queue.c **** 	of execution time efficiency. */
1625:../Dave/Generated/FREERTOS/queue.c **** 
1626:../Dave/Generated/FREERTOS/queue.c **** 	for( ;; )
1627:../Dave/Generated/FREERTOS/queue.c **** 	{
1628:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 2637              	 .loc 1 1628 0
 2638 0088 FFF7FEFF 	 bl vPortEnterCritical
 2639              	.LBB176:
1629:../Dave/Generated/FREERTOS/queue.c **** 		{
1630:../Dave/Generated/FREERTOS/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2640              	 .loc 1 1630 0
 2641 008c 3B6B     	 ldr r3,[r7,#48]
 2642 008e 9B6B     	 ldr r3,[r3,#56]
 2643 0090 FB62     	 str r3,[r7,#44]
1631:../Dave/Generated/FREERTOS/queue.c **** 
1632:../Dave/Generated/FREERTOS/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1633:../Dave/Generated/FREERTOS/queue.c **** 			must be the highest priority task wanting to access the queue. */
1634:../Dave/Generated/FREERTOS/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2644              	 .loc 1 1634 0
 2645 0092 FB6A     	 ldr r3,[r7,#44]
 2646 0094 002B     	 cmp r3,#0
 2647 0096 21D0     	 beq .L196
1635:../Dave/Generated/FREERTOS/queue.c **** 			{
1636:../Dave/Generated/FREERTOS/queue.c **** 				/* Remember the read position so it can be reset after the data
1637:../Dave/Generated/FREERTOS/queue.c **** 				is read from the queue as this function is only peeking the
1638:../Dave/Generated/FREERTOS/queue.c **** 				data, not removing it. */
1639:../Dave/Generated/FREERTOS/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 2648              	 .loc 1 1639 0
 2649 0098 3B6B     	 ldr r3,[r7,#48]
 2650 009a DB68     	 ldr r3,[r3,#12]
 2651 009c BB62     	 str r3,[r7,#40]
1640:../Dave/Generated/FREERTOS/queue.c **** 
1641:../Dave/Generated/FREERTOS/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 2652              	 .loc 1 1641 0
 2653 009e 386B     	 ldr r0,[r7,#48]
 2654 00a0 B968     	 ldr r1,[r7,#8]
 2655 00a2 FFF7FEFF 	 bl prvCopyDataFromQueue
1642:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_PEEK( pxQueue );
1643:../Dave/Generated/FREERTOS/queue.c **** 
1644:../Dave/Generated/FREERTOS/queue.c **** 				/* The data is not being removed, so reset the read pointer. */
1645:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 2656              	 .loc 1 1645 0
 2657 00a6 3B6B     	 ldr r3,[r7,#48]
 2658 00a8 BA6A     	 ldr r2,[r7,#40]
 2659 00aa DA60     	 str r2,[r3,#12]
1646:../Dave/Generated/FREERTOS/queue.c **** 
1647:../Dave/Generated/FREERTOS/queue.c **** 				/* The data is being left in the queue, so see if there are
1648:../Dave/Generated/FREERTOS/queue.c **** 				any other tasks waiting for the data. */
1649:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2660              	 .loc 1 1649 0
 2661 00ac 3B6B     	 ldr r3,[r7,#48]
 2662 00ae 5B6A     	 ldr r3,[r3,#36]
 2663 00b0 002B     	 cmp r3,#0
 2664 00b2 0FD0     	 beq .L197
1650:../Dave/Generated/FREERTOS/queue.c **** 				{
1651:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2665              	 .loc 1 1651 0
 2666 00b4 3B6B     	 ldr r3,[r7,#48]
 2667 00b6 2433     	 adds r3,r3,#36
 2668 00b8 1846     	 mov r0,r3
 2669 00ba FFF7FEFF 	 bl xTaskRemoveFromEventList
 2670 00be 0346     	 mov r3,r0
 2671 00c0 002B     	 cmp r3,#0
 2672 00c2 07D0     	 beq .L197
1652:../Dave/Generated/FREERTOS/queue.c **** 					{
1653:../Dave/Generated/FREERTOS/queue.c **** 						/* The task waiting has a higher priority than this task. */
1654:../Dave/Generated/FREERTOS/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 2673              	 .loc 1 1654 0
 2674 00c4 3E4B     	 ldr r3,.L208
 2675 00c6 4FF08052 	 mov r2,#268435456
 2676 00ca 1A60     	 str r2,[r3]
 2677              	
 2678 00cc BFF34F8F 	 dsb
 2679              	
 2680              	
 2681 00d0 BFF36F8F 	 isb
 2682              	
 2683              	 .thumb
 2684              	.L197:
1655:../Dave/Generated/FREERTOS/queue.c **** 					}
1656:../Dave/Generated/FREERTOS/queue.c **** 					else
1657:../Dave/Generated/FREERTOS/queue.c **** 					{
1658:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1659:../Dave/Generated/FREERTOS/queue.c **** 					}
1660:../Dave/Generated/FREERTOS/queue.c **** 				}
1661:../Dave/Generated/FREERTOS/queue.c **** 				else
1662:../Dave/Generated/FREERTOS/queue.c **** 				{
1663:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1664:../Dave/Generated/FREERTOS/queue.c **** 				}
1665:../Dave/Generated/FREERTOS/queue.c **** 
1666:../Dave/Generated/FREERTOS/queue.c **** 				taskEXIT_CRITICAL();
 2685              	 .loc 1 1666 0
 2686 00d4 FFF7FEFF 	 bl vPortExitCritical
1667:../Dave/Generated/FREERTOS/queue.c **** 				return pdPASS;
 2687              	 .loc 1 1667 0
 2688 00d8 0123     	 movs r3,#1
 2689 00da 6DE0     	 b .L207
 2690              	.L196:
1668:../Dave/Generated/FREERTOS/queue.c **** 			}
1669:../Dave/Generated/FREERTOS/queue.c **** 			else
1670:../Dave/Generated/FREERTOS/queue.c **** 			{
1671:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 2691              	 .loc 1 1671 0
 2692 00dc 7B68     	 ldr r3,[r7,#4]
 2693 00de 002B     	 cmp r3,#0
 2694 00e0 03D1     	 bne .L199
1672:../Dave/Generated/FREERTOS/queue.c **** 				{
1673:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was empty and no block time is specified (or
1674:../Dave/Generated/FREERTOS/queue.c **** 					the block time has expired) so leave now. */
1675:../Dave/Generated/FREERTOS/queue.c **** 					taskEXIT_CRITICAL();
 2695              	 .loc 1 1675 0
 2696 00e2 FFF7FEFF 	 bl vPortExitCritical
1676:../Dave/Generated/FREERTOS/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
1677:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_EMPTY;
 2697              	 .loc 1 1677 0
 2698 00e6 0023     	 movs r3,#0
 2699 00e8 66E0     	 b .L207
 2700              	.L199:
1678:../Dave/Generated/FREERTOS/queue.c **** 				}
1679:../Dave/Generated/FREERTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 2701              	 .loc 1 1679 0
 2702 00ea 7B6B     	 ldr r3,[r7,#52]
 2703 00ec 002B     	 cmp r3,#0
 2704 00ee 06D1     	 bne .L200
1680:../Dave/Generated/FREERTOS/queue.c **** 				{
1681:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was empty and a block time was specified so
1682:../Dave/Generated/FREERTOS/queue.c **** 					configure the timeout structure ready to enter the blocked
1683:../Dave/Generated/FREERTOS/queue.c **** 					state. */
1684:../Dave/Generated/FREERTOS/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 2705              	 .loc 1 1684 0
 2706 00f0 07F11403 	 add r3,r7,#20
 2707 00f4 1846     	 mov r0,r3
 2708 00f6 FFF7FEFF 	 bl vTaskInternalSetTimeOutState
1685:../Dave/Generated/FREERTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 2709              	 .loc 1 1685 0
 2710 00fa 0123     	 movs r3,#1
 2711 00fc 7B63     	 str r3,[r7,#52]
 2712              	.L200:
 2713              	.LBE176:
1686:../Dave/Generated/FREERTOS/queue.c **** 				}
1687:../Dave/Generated/FREERTOS/queue.c **** 				else
1688:../Dave/Generated/FREERTOS/queue.c **** 				{
1689:../Dave/Generated/FREERTOS/queue.c **** 					/* Entry time was already set. */
1690:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1691:../Dave/Generated/FREERTOS/queue.c **** 				}
1692:../Dave/Generated/FREERTOS/queue.c **** 			}
1693:../Dave/Generated/FREERTOS/queue.c **** 		}
1694:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 2714              	 .loc 1 1694 0
 2715 00fe FFF7FEFF 	 bl vPortExitCritical
1695:../Dave/Generated/FREERTOS/queue.c **** 
1696:../Dave/Generated/FREERTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1697:../Dave/Generated/FREERTOS/queue.c **** 		now the critical section has been exited. */
1698:../Dave/Generated/FREERTOS/queue.c **** 
1699:../Dave/Generated/FREERTOS/queue.c **** 		vTaskSuspendAll();
 2716              	 .loc 1 1699 0
 2717 0102 FFF7FEFF 	 bl vTaskSuspendAll
1700:../Dave/Generated/FREERTOS/queue.c **** 		prvLockQueue( pxQueue );
 2718              	 .loc 1 1700 0
 2719 0106 FFF7FEFF 	 bl vPortEnterCritical
 2720 010a 3B6B     	 ldr r3,[r7,#48]
 2721 010c 93F84430 	 ldrb r3,[r3,#68]
 2722 0110 DBB2     	 uxtb r3,r3
 2723 0112 5BB2     	 sxtb r3,r3
 2724 0114 B3F1FF3F 	 cmp r3,#-1
 2725 0118 03D1     	 bne .L201
 2726              	 .loc 1 1700 0 is_stmt 0 discriminator 1
 2727 011a 3B6B     	 ldr r3,[r7,#48]
 2728 011c 0022     	 movs r2,#0
 2729 011e 83F84420 	 strb r2,[r3,#68]
 2730              	.L201:
 2731              	 .loc 1 1700 0 discriminator 3
 2732 0122 3B6B     	 ldr r3,[r7,#48]
 2733 0124 93F84530 	 ldrb r3,[r3,#69]
 2734 0128 DBB2     	 uxtb r3,r3
 2735 012a 5BB2     	 sxtb r3,r3
 2736 012c B3F1FF3F 	 cmp r3,#-1
 2737 0130 03D1     	 bne .L202
 2738              	 .loc 1 1700 0 discriminator 4
 2739 0132 3B6B     	 ldr r3,[r7,#48]
 2740 0134 0022     	 movs r2,#0
 2741 0136 83F84520 	 strb r2,[r3,#69]
 2742              	.L202:
 2743              	 .loc 1 1700 0 discriminator 6
 2744 013a FFF7FEFF 	 bl vPortExitCritical
1701:../Dave/Generated/FREERTOS/queue.c **** 
1702:../Dave/Generated/FREERTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1703:../Dave/Generated/FREERTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 2745              	 .loc 1 1703 0 is_stmt 1 discriminator 6
 2746 013e 07F11402 	 add r2,r7,#20
 2747 0142 3B1D     	 adds r3,r7,#4
 2748 0144 1046     	 mov r0,r2
 2749 0146 1946     	 mov r1,r3
 2750 0148 FFF7FEFF 	 bl xTaskCheckForTimeOut
 2751 014c 0346     	 mov r3,r0
 2752 014e 002B     	 cmp r3,#0
 2753 0150 24D1     	 bne .L203
1704:../Dave/Generated/FREERTOS/queue.c **** 		{
1705:../Dave/Generated/FREERTOS/queue.c **** 			/* Timeout has not expired yet, check to see if there is data in the
1706:../Dave/Generated/FREERTOS/queue.c **** 			queue now, and if not enter the Blocked state to wait for data. */
1707:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2754              	 .loc 1 1707 0
 2755 0152 386B     	 ldr r0,[r7,#48]
 2756 0154 FFF7FEFF 	 bl prvIsQueueEmpty
 2757 0158 0346     	 mov r3,r0
 2758 015a 002B     	 cmp r3,#0
 2759 015c 18D0     	 beq .L204
1708:../Dave/Generated/FREERTOS/queue.c **** 			{
1709:../Dave/Generated/FREERTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1710:../Dave/Generated/FREERTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2760              	 .loc 1 1710 0
 2761 015e 3B6B     	 ldr r3,[r7,#48]
 2762 0160 03F12402 	 add r2,r3,#36
 2763 0164 7B68     	 ldr r3,[r7,#4]
 2764 0166 1046     	 mov r0,r2
 2765 0168 1946     	 mov r1,r3
 2766 016a FFF7FEFF 	 bl vTaskPlaceOnEventList
1711:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2767              	 .loc 1 1711 0
 2768 016e 386B     	 ldr r0,[r7,#48]
 2769 0170 FFF7FEFF 	 bl prvUnlockQueue
1712:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 2770              	 .loc 1 1712 0
 2771 0174 FFF7FEFF 	 bl xTaskResumeAll
 2772 0178 0346     	 mov r3,r0
 2773 017a 002B     	 cmp r3,#0
 2774 017c 1BD1     	 bne .L206
1713:../Dave/Generated/FREERTOS/queue.c **** 				{
1714:../Dave/Generated/FREERTOS/queue.c **** 					portYIELD_WITHIN_API();
 2775              	 .loc 1 1714 0
 2776 017e 104B     	 ldr r3,.L208
 2777 0180 4FF08052 	 mov r2,#268435456
 2778 0184 1A60     	 str r2,[r3]
 2779              	
 2780 0186 BFF34F8F 	 dsb
 2781              	
 2782              	
 2783 018a BFF36F8F 	 isb
 2784              	
 2785              	 .thumb
 2786 018e 12E0     	 b .L206
 2787              	.L204:
1715:../Dave/Generated/FREERTOS/queue.c **** 				}
1716:../Dave/Generated/FREERTOS/queue.c **** 				else
1717:../Dave/Generated/FREERTOS/queue.c **** 				{
1718:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1719:../Dave/Generated/FREERTOS/queue.c **** 				}
1720:../Dave/Generated/FREERTOS/queue.c **** 			}
1721:../Dave/Generated/FREERTOS/queue.c **** 			else
1722:../Dave/Generated/FREERTOS/queue.c **** 			{
1723:../Dave/Generated/FREERTOS/queue.c **** 				/* There is data in the queue now, so don't enter the blocked
1724:../Dave/Generated/FREERTOS/queue.c **** 				state, instead return to try and obtain the data. */
1725:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2788              	 .loc 1 1725 0
 2789 0190 386B     	 ldr r0,[r7,#48]
 2790 0192 FFF7FEFF 	 bl prvUnlockQueue
1726:../Dave/Generated/FREERTOS/queue.c **** 				( void ) xTaskResumeAll();
 2791              	 .loc 1 1726 0
 2792 0196 FFF7FEFF 	 bl xTaskResumeAll
 2793 019a 75E7     	 b .L194
 2794              	.L203:
1727:../Dave/Generated/FREERTOS/queue.c **** 			}
1728:../Dave/Generated/FREERTOS/queue.c **** 		}
1729:../Dave/Generated/FREERTOS/queue.c **** 		else
1730:../Dave/Generated/FREERTOS/queue.c **** 		{
1731:../Dave/Generated/FREERTOS/queue.c **** 			/* The timeout has expired.  If there is still no data in the queue
1732:../Dave/Generated/FREERTOS/queue.c **** 			exit, otherwise go back and try to read the data again. */
1733:../Dave/Generated/FREERTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 2795              	 .loc 1 1733 0
 2796 019c 386B     	 ldr r0,[r7,#48]
 2797 019e FFF7FEFF 	 bl prvUnlockQueue
1734:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xTaskResumeAll();
 2798              	 .loc 1 1734 0
 2799 01a2 FFF7FEFF 	 bl xTaskResumeAll
1735:../Dave/Generated/FREERTOS/queue.c **** 
1736:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2800              	 .loc 1 1736 0
 2801 01a6 386B     	 ldr r0,[r7,#48]
 2802 01a8 FFF7FEFF 	 bl prvIsQueueEmpty
 2803 01ac 0346     	 mov r3,r0
 2804 01ae 002B     	 cmp r3,#0
 2805 01b0 01D0     	 beq .L206
1737:../Dave/Generated/FREERTOS/queue.c **** 			{
1738:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_PEEK_FAILED( pxQueue );
1739:../Dave/Generated/FREERTOS/queue.c **** 				return errQUEUE_EMPTY;
 2806              	 .loc 1 1739 0
 2807 01b2 0023     	 movs r3,#0
 2808 01b4 00E0     	 b .L207
 2809              	.L206:
1740:../Dave/Generated/FREERTOS/queue.c **** 			}
1741:../Dave/Generated/FREERTOS/queue.c **** 			else
1742:../Dave/Generated/FREERTOS/queue.c **** 			{
1743:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1744:../Dave/Generated/FREERTOS/queue.c **** 			}
1745:../Dave/Generated/FREERTOS/queue.c **** 		}
1746:../Dave/Generated/FREERTOS/queue.c **** 	}
 2810              	 .loc 1 1746 0 discriminator 5
 2811 01b6 67E7     	 b .L194
 2812              	.L207:
1747:../Dave/Generated/FREERTOS/queue.c **** }
 2813              	 .loc 1 1747 0 discriminator 6
 2814 01b8 1846     	 mov r0,r3
 2815 01ba 3837     	 adds r7,r7,#56
 2816              	.LCFI79:
 2817              	 .cfi_def_cfa_offset 8
 2818 01bc BD46     	 mov sp,r7
 2819              	.LCFI80:
 2820              	 .cfi_def_cfa_register 13
 2821              	 
 2822 01be 80BD     	 pop {r7,pc}
 2823              	.L209:
 2824              	 .align 2
 2825              	.L208:
 2826 01c0 04ED00E0 	 .word -536810236
 2827              	 .cfi_endproc
 2828              	.LFE150:
 2830              	 .section .text.xQueueReceiveFromISR,"ax",%progbits
 2831              	 .align 2
 2832              	 .global xQueueReceiveFromISR
 2833              	 .thumb
 2834              	 .thumb_func
 2836              	xQueueReceiveFromISR:
 2837              	.LFB151:
1748:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1749:../Dave/Generated/FREERTOS/queue.c **** 
1750:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1751:../Dave/Generated/FREERTOS/queue.c **** {
 2838              	 .loc 1 1751 0
 2839              	 .cfi_startproc
 2840              	 
 2841              	 
 2842 0000 80B5     	 push {r7,lr}
 2843              	.LCFI81:
 2844              	 .cfi_def_cfa_offset 8
 2845              	 .cfi_offset 7,-8
 2846              	 .cfi_offset 14,-4
 2847 0002 8EB0     	 sub sp,sp,#56
 2848              	.LCFI82:
 2849              	 .cfi_def_cfa_offset 64
 2850 0004 00AF     	 add r7,sp,#0
 2851              	.LCFI83:
 2852              	 .cfi_def_cfa_register 7
 2853 0006 F860     	 str r0,[r7,#12]
 2854 0008 B960     	 str r1,[r7,#8]
 2855 000a 7A60     	 str r2,[r7,#4]
1752:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
1753:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1754:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2856              	 .loc 1 1754 0
 2857 000c FB68     	 ldr r3,[r7,#12]
 2858 000e 3B63     	 str r3,[r7,#48]
1755:../Dave/Generated/FREERTOS/queue.c **** 
1756:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 2859              	 .loc 1 1756 0
 2860 0010 3B6B     	 ldr r3,[r7,#48]
 2861 0012 002B     	 cmp r3,#0
 2862 0014 09D1     	 bne .L211
 2863              	.LBB177:
 2864              	.LBB178:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2865              	 .loc 2 195 0 discriminator 1
 2866              	
 2867 0016 4FF0FC03 	 mov r3,#252
 2868 001a 83F31188 	 msr basepri,r3
 2869 001e BFF36F8F 	 isb 
 2870 0022 BFF34F8F 	 dsb 
 2871              	
 2872              	
 2873              	 .thumb
 2874 0026 3B62     	 str r3,[r7,#32]
 2875              	.L212:
 2876              	.LBE178:
 2877              	.LBE177:
 2878              	 .loc 1 1756 0 discriminator 1
 2879 0028 FEE7     	 b .L212
 2880              	.L211:
1757:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2881              	 .loc 1 1757 0
 2882 002a BB68     	 ldr r3,[r7,#8]
 2883 002c 002B     	 cmp r3,#0
 2884 002e 03D1     	 bne .L213
 2885              	 .loc 1 1757 0 is_stmt 0 discriminator 2
 2886 0030 3B6B     	 ldr r3,[r7,#48]
 2887 0032 1B6C     	 ldr r3,[r3,#64]
 2888 0034 002B     	 cmp r3,#0
 2889 0036 01D1     	 bne .L214
 2890              	.L213:
 2891              	 .loc 1 1757 0 discriminator 3
 2892 0038 0123     	 movs r3,#1
 2893 003a 00E0     	 b .L215
 2894              	.L214:
 2895              	 .loc 1 1757 0 discriminator 4
 2896 003c 0023     	 movs r3,#0
 2897              	.L215:
 2898              	 .loc 1 1757 0 discriminator 6
 2899 003e 002B     	 cmp r3,#0
 2900 0040 09D1     	 bne .L216
 2901              	.LBB179:
 2902              	.LBB180:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2903              	 .loc 2 195 0 is_stmt 1 discriminator 7
 2904              	
 2905 0042 4FF0FC03 	 mov r3,#252
 2906 0046 83F31188 	 msr basepri,r3
 2907 004a BFF36F8F 	 isb 
 2908 004e BFF34F8F 	 dsb 
 2909              	
 2910              	
 2911              	 .thumb
 2912 0052 FB61     	 str r3,[r7,#28]
 2913              	.L217:
 2914              	.LBE180:
 2915              	.LBE179:
 2916              	 .loc 1 1757 0 discriminator 2
 2917 0054 FEE7     	 b .L217
 2918              	.L216:
1758:../Dave/Generated/FREERTOS/queue.c **** 
1759:../Dave/Generated/FREERTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1760:../Dave/Generated/FREERTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1761:../Dave/Generated/FREERTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1762:../Dave/Generated/FREERTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1763:../Dave/Generated/FREERTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1764:../Dave/Generated/FREERTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1765:../Dave/Generated/FREERTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1766:../Dave/Generated/FREERTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1767:../Dave/Generated/FREERTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1768:../Dave/Generated/FREERTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1769:../Dave/Generated/FREERTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1770:../Dave/Generated/FREERTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1771:../Dave/Generated/FREERTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1772:../Dave/Generated/FREERTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1773:../Dave/Generated/FREERTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 2919              	 .loc 1 1773 0
 2920 0056 FFF7FEFF 	 bl vPortValidateInterruptPriority
 2921              	.LBB181:
 2922              	.LBB182:
 211:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2923              	 .loc 2 211 0
 2924              	
 2925 005a EFF31182 	 mrs r2,basepri
 2926 005e 4FF0FC03 	 mov r3,#252
 2927 0062 83F31188 	 msr basepri,r3
 2928 0066 BFF36F8F 	 isb 
 2929 006a BFF34F8F 	 dsb 
 2930              	
 2931              	
 2932              	 .thumb
 2933 006e BA61     	 str r2,[r7,#24]
 2934 0070 7B61     	 str r3,[r7,#20]
 223:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 2935              	 .loc 2 223 0
 2936 0072 BB69     	 ldr r3,[r7,#24]
 2937              	.LBE182:
 2938              	.LBE181:
1774:../Dave/Generated/FREERTOS/queue.c **** 
1775:../Dave/Generated/FREERTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 2939              	 .loc 1 1775 0
 2940 0074 FB62     	 str r3,[r7,#44]
 2941              	.LBB183:
1776:../Dave/Generated/FREERTOS/queue.c **** 	{
1777:../Dave/Generated/FREERTOS/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2942              	 .loc 1 1777 0
 2943 0076 3B6B     	 ldr r3,[r7,#48]
 2944 0078 9B6B     	 ldr r3,[r3,#56]
 2945 007a BB62     	 str r3,[r7,#40]
1778:../Dave/Generated/FREERTOS/queue.c **** 
1779:../Dave/Generated/FREERTOS/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1780:../Dave/Generated/FREERTOS/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2946              	 .loc 1 1780 0
 2947 007c BB6A     	 ldr r3,[r7,#40]
 2948 007e 002B     	 cmp r3,#0
 2949 0080 2FD0     	 beq .L219
 2950              	.LBB184:
1781:../Dave/Generated/FREERTOS/queue.c **** 		{
1782:../Dave/Generated/FREERTOS/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
 2951              	 .loc 1 1782 0
 2952 0082 3B6B     	 ldr r3,[r7,#48]
 2953 0084 93F84430 	 ldrb r3,[r3,#68]
 2954 0088 87F82730 	 strb r3,[r7,#39]
1783:../Dave/Generated/FREERTOS/queue.c **** 
1784:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1785:../Dave/Generated/FREERTOS/queue.c **** 
1786:../Dave/Generated/FREERTOS/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 2955              	 .loc 1 1786 0
 2956 008c 386B     	 ldr r0,[r7,#48]
 2957 008e B968     	 ldr r1,[r7,#8]
 2958 0090 FFF7FEFF 	 bl prvCopyDataFromQueue
1787:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 2959              	 .loc 1 1787 0
 2960 0094 BB6A     	 ldr r3,[r7,#40]
 2961 0096 5A1E     	 subs r2,r3,#1
 2962 0098 3B6B     	 ldr r3,[r7,#48]
 2963 009a 9A63     	 str r2,[r3,#56]
1788:../Dave/Generated/FREERTOS/queue.c **** 
1789:../Dave/Generated/FREERTOS/queue.c **** 			/* If the queue is locked the event list will not be modified.
1790:../Dave/Generated/FREERTOS/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1791:../Dave/Generated/FREERTOS/queue.c **** 			will know that an ISR has removed data while the queue was
1792:../Dave/Generated/FREERTOS/queue.c **** 			locked. */
1793:../Dave/Generated/FREERTOS/queue.c **** 			if( cRxLock == queueUNLOCKED )
 2964              	 .loc 1 1793 0
 2965 009c 97F92730 	 ldrsb r3,[r7,#39]
 2966 00a0 B3F1FF3F 	 cmp r3,#-1
 2967 00a4 12D1     	 bne .L220
1794:../Dave/Generated/FREERTOS/queue.c **** 			{
1795:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2968              	 .loc 1 1795 0
 2969 00a6 3B6B     	 ldr r3,[r7,#48]
 2970 00a8 1B69     	 ldr r3,[r3,#16]
 2971 00aa 002B     	 cmp r3,#0
 2972 00ac 16D0     	 beq .L221
1796:../Dave/Generated/FREERTOS/queue.c **** 				{
1797:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2973              	 .loc 1 1797 0
 2974 00ae 3B6B     	 ldr r3,[r7,#48]
 2975 00b0 1033     	 adds r3,r3,#16
 2976 00b2 1846     	 mov r0,r3
 2977 00b4 FFF7FEFF 	 bl xTaskRemoveFromEventList
 2978 00b8 0346     	 mov r3,r0
 2979 00ba 002B     	 cmp r3,#0
 2980 00bc 0ED0     	 beq .L221
1798:../Dave/Generated/FREERTOS/queue.c **** 					{
1799:../Dave/Generated/FREERTOS/queue.c **** 						/* The task waiting has a higher priority than us so
1800:../Dave/Generated/FREERTOS/queue.c **** 						force a context switch. */
1801:../Dave/Generated/FREERTOS/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 2981              	 .loc 1 1801 0
 2982 00be 7B68     	 ldr r3,[r7,#4]
 2983 00c0 002B     	 cmp r3,#0
 2984 00c2 0BD0     	 beq .L221
1802:../Dave/Generated/FREERTOS/queue.c **** 						{
1803:../Dave/Generated/FREERTOS/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 2985              	 .loc 1 1803 0
 2986 00c4 7B68     	 ldr r3,[r7,#4]
 2987 00c6 0122     	 movs r2,#1
 2988 00c8 1A60     	 str r2,[r3]
 2989 00ca 07E0     	 b .L221
 2990              	.L220:
1804:../Dave/Generated/FREERTOS/queue.c **** 						}
1805:../Dave/Generated/FREERTOS/queue.c **** 						else
1806:../Dave/Generated/FREERTOS/queue.c **** 						{
1807:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1808:../Dave/Generated/FREERTOS/queue.c **** 						}
1809:../Dave/Generated/FREERTOS/queue.c **** 					}
1810:../Dave/Generated/FREERTOS/queue.c **** 					else
1811:../Dave/Generated/FREERTOS/queue.c **** 					{
1812:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1813:../Dave/Generated/FREERTOS/queue.c **** 					}
1814:../Dave/Generated/FREERTOS/queue.c **** 				}
1815:../Dave/Generated/FREERTOS/queue.c **** 				else
1816:../Dave/Generated/FREERTOS/queue.c **** 				{
1817:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1818:../Dave/Generated/FREERTOS/queue.c **** 				}
1819:../Dave/Generated/FREERTOS/queue.c **** 			}
1820:../Dave/Generated/FREERTOS/queue.c **** 			else
1821:../Dave/Generated/FREERTOS/queue.c **** 			{
1822:../Dave/Generated/FREERTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1823:../Dave/Generated/FREERTOS/queue.c **** 				knows that data was removed while it was locked. */
1824:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 2991              	 .loc 1 1824 0
 2992 00cc 97F82730 	 ldrb r3,[r7,#39]
 2993 00d0 0133     	 adds r3,r3,#1
 2994 00d2 DBB2     	 uxtb r3,r3
 2995 00d4 DAB2     	 uxtb r2,r3
 2996 00d6 3B6B     	 ldr r3,[r7,#48]
 2997 00d8 83F84420 	 strb r2,[r3,#68]
 2998              	.L221:
1825:../Dave/Generated/FREERTOS/queue.c **** 			}
1826:../Dave/Generated/FREERTOS/queue.c **** 
1827:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 2999              	 .loc 1 1827 0
 3000 00dc 0123     	 movs r3,#1
 3001 00de 7B63     	 str r3,[r7,#52]
 3002              	.LBE184:
 3003 00e0 01E0     	 b .L222
 3004              	.L219:
1828:../Dave/Generated/FREERTOS/queue.c **** 		}
1829:../Dave/Generated/FREERTOS/queue.c **** 		else
1830:../Dave/Generated/FREERTOS/queue.c **** 		{
1831:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
 3005              	 .loc 1 1831 0
 3006 00e2 0023     	 movs r3,#0
 3007 00e4 7B63     	 str r3,[r7,#52]
 3008              	.L222:
 3009 00e6 FB6A     	 ldr r3,[r7,#44]
 3010 00e8 3B61     	 str r3,[r7,#16]
 3011              	.LBE183:
 3012              	.LBB185:
 3013              	.LBB186:
 3014              	 .loc 2 229 0
 3015 00ea 3B69     	 ldr r3,[r7,#16]
 3016              	
 3017 00ec 83F31188 	 msr basepri,r3
 3018              	
 3019              	 .thumb
 3020              	.LBE186:
 3021              	.LBE185:
1832:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1833:../Dave/Generated/FREERTOS/queue.c **** 		}
1834:../Dave/Generated/FREERTOS/queue.c **** 	}
1835:../Dave/Generated/FREERTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1836:../Dave/Generated/FREERTOS/queue.c **** 
1837:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 3022              	 .loc 1 1837 0
 3023 00f0 7B6B     	 ldr r3,[r7,#52]
1838:../Dave/Generated/FREERTOS/queue.c **** }
 3024              	 .loc 1 1838 0
 3025 00f2 1846     	 mov r0,r3
 3026 00f4 3837     	 adds r7,r7,#56
 3027              	.LCFI84:
 3028              	 .cfi_def_cfa_offset 8
 3029 00f6 BD46     	 mov sp,r7
 3030              	.LCFI85:
 3031              	 .cfi_def_cfa_register 13
 3032              	 
 3033 00f8 80BD     	 pop {r7,pc}
 3034              	 .cfi_endproc
 3035              	.LFE151:
 3037 00fa 00BF     	 .section .text.xQueuePeekFromISR,"ax",%progbits
 3038              	 .align 2
 3039              	 .global xQueuePeekFromISR
 3040              	 .thumb
 3041              	 .thumb_func
 3043              	xQueuePeekFromISR:
 3044              	.LFB152:
1839:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1840:../Dave/Generated/FREERTOS/queue.c **** 
1841:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1842:../Dave/Generated/FREERTOS/queue.c **** {
 3045              	 .loc 1 1842 0
 3046              	 .cfi_startproc
 3047              	 
 3048              	 
 3049 0000 80B5     	 push {r7,lr}
 3050              	.LCFI86:
 3051              	 .cfi_def_cfa_offset 8
 3052              	 .cfi_offset 7,-8
 3053              	 .cfi_offset 14,-4
 3054 0002 8CB0     	 sub sp,sp,#48
 3055              	.LCFI87:
 3056              	 .cfi_def_cfa_offset 56
 3057 0004 00AF     	 add r7,sp,#0
 3058              	.LCFI88:
 3059              	 .cfi_def_cfa_register 7
 3060 0006 7860     	 str r0,[r7,#4]
 3061 0008 3960     	 str r1,[r7]
1843:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
1844:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1845:../Dave/Generated/FREERTOS/queue.c **** int8_t *pcOriginalReadPosition;
1846:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 3062              	 .loc 1 1846 0
 3063 000a 7B68     	 ldr r3,[r7,#4]
 3064 000c BB62     	 str r3,[r7,#40]
1847:../Dave/Generated/FREERTOS/queue.c **** 
1848:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 3065              	 .loc 1 1848 0
 3066 000e BB6A     	 ldr r3,[r7,#40]
 3067 0010 002B     	 cmp r3,#0
 3068 0012 09D1     	 bne .L225
 3069              	.LBB187:
 3070              	.LBB188:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3071              	 .loc 2 195 0 discriminator 1
 3072              	
 3073 0014 4FF0FC03 	 mov r3,#252
 3074 0018 83F31188 	 msr basepri,r3
 3075 001c BFF36F8F 	 isb 
 3076 0020 BFF34F8F 	 dsb 
 3077              	
 3078              	
 3079              	 .thumb
 3080 0024 FB61     	 str r3,[r7,#28]
 3081              	.L226:
 3082              	.LBE188:
 3083              	.LBE187:
 3084              	 .loc 1 1848 0 discriminator 1
 3085 0026 FEE7     	 b .L226
 3086              	.L225:
1849:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3087              	 .loc 1 1849 0
 3088 0028 3B68     	 ldr r3,[r7]
 3089 002a 002B     	 cmp r3,#0
 3090 002c 03D1     	 bne .L227
 3091              	 .loc 1 1849 0 is_stmt 0 discriminator 2
 3092 002e BB6A     	 ldr r3,[r7,#40]
 3093 0030 1B6C     	 ldr r3,[r3,#64]
 3094 0032 002B     	 cmp r3,#0
 3095 0034 01D1     	 bne .L228
 3096              	.L227:
 3097              	 .loc 1 1849 0 discriminator 3
 3098 0036 0123     	 movs r3,#1
 3099 0038 00E0     	 b .L229
 3100              	.L228:
 3101              	 .loc 1 1849 0 discriminator 4
 3102 003a 0023     	 movs r3,#0
 3103              	.L229:
 3104              	 .loc 1 1849 0 discriminator 6
 3105 003c 002B     	 cmp r3,#0
 3106 003e 09D1     	 bne .L230
 3107              	.LBB189:
 3108              	.LBB190:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3109              	 .loc 2 195 0 is_stmt 1 discriminator 7
 3110              	
 3111 0040 4FF0FC03 	 mov r3,#252
 3112 0044 83F31188 	 msr basepri,r3
 3113 0048 BFF36F8F 	 isb 
 3114 004c BFF34F8F 	 dsb 
 3115              	
 3116              	
 3117              	 .thumb
 3118 0050 BB61     	 str r3,[r7,#24]
 3119              	.L231:
 3120              	.LBE190:
 3121              	.LBE189:
 3122              	 .loc 1 1849 0 discriminator 2
 3123 0052 FEE7     	 b .L231
 3124              	.L230:
1850:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 3125              	 .loc 1 1850 0
 3126 0054 BB6A     	 ldr r3,[r7,#40]
 3127 0056 1B6C     	 ldr r3,[r3,#64]
 3128 0058 002B     	 cmp r3,#0
 3129 005a 09D1     	 bne .L232
 3130              	.LBB191:
 3131              	.LBB192:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3132              	 .loc 2 195 0 discriminator 1
 3133              	
 3134 005c 4FF0FC03 	 mov r3,#252
 3135 0060 83F31188 	 msr basepri,r3
 3136 0064 BFF36F8F 	 isb 
 3137 0068 BFF34F8F 	 dsb 
 3138              	
 3139              	
 3140              	 .thumb
 3141 006c 7B61     	 str r3,[r7,#20]
 3142              	.L233:
 3143              	.LBE192:
 3144              	.LBE191:
 3145              	 .loc 1 1850 0 discriminator 3
 3146 006e FEE7     	 b .L233
 3147              	.L232:
1851:../Dave/Generated/FREERTOS/queue.c **** 
1852:../Dave/Generated/FREERTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1853:../Dave/Generated/FREERTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1854:../Dave/Generated/FREERTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1855:../Dave/Generated/FREERTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1856:../Dave/Generated/FREERTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1857:../Dave/Generated/FREERTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1858:../Dave/Generated/FREERTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1859:../Dave/Generated/FREERTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1860:../Dave/Generated/FREERTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1861:../Dave/Generated/FREERTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1862:../Dave/Generated/FREERTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1863:../Dave/Generated/FREERTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1864:../Dave/Generated/FREERTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1865:../Dave/Generated/FREERTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1866:../Dave/Generated/FREERTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 3148              	 .loc 1 1866 0
 3149 0070 FFF7FEFF 	 bl vPortValidateInterruptPriority
 3150              	.LBB193:
 3151              	.LBB194:
 211:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3152              	 .loc 2 211 0
 3153              	
 3154 0074 EFF31182 	 mrs r2,basepri
 3155 0078 4FF0FC03 	 mov r3,#252
 3156 007c 83F31188 	 msr basepri,r3
 3157 0080 BFF36F8F 	 isb 
 3158 0084 BFF34F8F 	 dsb 
 3159              	
 3160              	
 3161              	 .thumb
 3162 0088 3A61     	 str r2,[r7,#16]
 3163 008a FB60     	 str r3,[r7,#12]
 223:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 3164              	 .loc 2 223 0
 3165 008c 3B69     	 ldr r3,[r7,#16]
 3166              	.LBE194:
 3167              	.LBE193:
1867:../Dave/Generated/FREERTOS/queue.c **** 
1868:../Dave/Generated/FREERTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 3168              	 .loc 1 1868 0
 3169 008e 7B62     	 str r3,[r7,#36]
1869:../Dave/Generated/FREERTOS/queue.c **** 	{
1870:../Dave/Generated/FREERTOS/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1871:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 3170              	 .loc 1 1871 0
 3171 0090 BB6A     	 ldr r3,[r7,#40]
 3172 0092 9B6B     	 ldr r3,[r3,#56]
 3173 0094 002B     	 cmp r3,#0
 3174 0096 0CD0     	 beq .L235
1872:../Dave/Generated/FREERTOS/queue.c **** 		{
1873:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1874:../Dave/Generated/FREERTOS/queue.c **** 
1875:../Dave/Generated/FREERTOS/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1876:../Dave/Generated/FREERTOS/queue.c **** 			actually being removed from the queue. */
1877:../Dave/Generated/FREERTOS/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 3175              	 .loc 1 1877 0
 3176 0098 BB6A     	 ldr r3,[r7,#40]
 3177 009a DB68     	 ldr r3,[r3,#12]
 3178 009c 3B62     	 str r3,[r7,#32]
1878:../Dave/Generated/FREERTOS/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 3179              	 .loc 1 1878 0
 3180 009e B86A     	 ldr r0,[r7,#40]
 3181 00a0 3968     	 ldr r1,[r7]
 3182 00a2 FFF7FEFF 	 bl prvCopyDataFromQueue
1879:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 3183              	 .loc 1 1879 0
 3184 00a6 BB6A     	 ldr r3,[r7,#40]
 3185 00a8 3A6A     	 ldr r2,[r7,#32]
 3186 00aa DA60     	 str r2,[r3,#12]
1880:../Dave/Generated/FREERTOS/queue.c **** 
1881:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 3187              	 .loc 1 1881 0
 3188 00ac 0123     	 movs r3,#1
 3189 00ae FB62     	 str r3,[r7,#44]
 3190 00b0 01E0     	 b .L236
 3191              	.L235:
1882:../Dave/Generated/FREERTOS/queue.c **** 		}
1883:../Dave/Generated/FREERTOS/queue.c **** 		else
1884:../Dave/Generated/FREERTOS/queue.c **** 		{
1885:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
 3192              	 .loc 1 1885 0
 3193 00b2 0023     	 movs r3,#0
 3194 00b4 FB62     	 str r3,[r7,#44]
 3195              	.L236:
 3196 00b6 7B6A     	 ldr r3,[r7,#36]
 3197 00b8 BB60     	 str r3,[r7,#8]
 3198              	.LBB195:
 3199              	.LBB196:
 3200              	 .loc 2 229 0
 3201 00ba BB68     	 ldr r3,[r7,#8]
 3202              	
 3203 00bc 83F31188 	 msr basepri,r3
 3204              	
 3205              	 .thumb
 3206              	.LBE196:
 3207              	.LBE195:
1886:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1887:../Dave/Generated/FREERTOS/queue.c **** 		}
1888:../Dave/Generated/FREERTOS/queue.c **** 	}
1889:../Dave/Generated/FREERTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1890:../Dave/Generated/FREERTOS/queue.c **** 
1891:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 3208              	 .loc 1 1891 0
 3209 00c0 FB6A     	 ldr r3,[r7,#44]
1892:../Dave/Generated/FREERTOS/queue.c **** }
 3210              	 .loc 1 1892 0
 3211 00c2 1846     	 mov r0,r3
 3212 00c4 3037     	 adds r7,r7,#48
 3213              	.LCFI89:
 3214              	 .cfi_def_cfa_offset 8
 3215 00c6 BD46     	 mov sp,r7
 3216              	.LCFI90:
 3217              	 .cfi_def_cfa_register 13
 3218              	 
 3219 00c8 80BD     	 pop {r7,pc}
 3220              	 .cfi_endproc
 3221              	.LFE152:
 3223 00ca 00BF     	 .section .text.uxQueueMessagesWaiting,"ax",%progbits
 3224              	 .align 2
 3225              	 .global uxQueueMessagesWaiting
 3226              	 .thumb
 3227              	 .thumb_func
 3229              	uxQueueMessagesWaiting:
 3230              	.LFB153:
1893:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1894:../Dave/Generated/FREERTOS/queue.c **** 
1895:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1896:../Dave/Generated/FREERTOS/queue.c **** {
 3231              	 .loc 1 1896 0
 3232              	 .cfi_startproc
 3233              	 
 3234              	 
 3235 0000 80B5     	 push {r7,lr}
 3236              	.LCFI91:
 3237              	 .cfi_def_cfa_offset 8
 3238              	 .cfi_offset 7,-8
 3239              	 .cfi_offset 14,-4
 3240 0002 84B0     	 sub sp,sp,#16
 3241              	.LCFI92:
 3242              	 .cfi_def_cfa_offset 24
 3243 0004 00AF     	 add r7,sp,#0
 3244              	.LCFI93:
 3245              	 .cfi_def_cfa_register 7
 3246 0006 7860     	 str r0,[r7,#4]
1897:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxReturn;
1898:../Dave/Generated/FREERTOS/queue.c **** 
1899:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( xQueue );
 3247              	 .loc 1 1899 0
 3248 0008 7B68     	 ldr r3,[r7,#4]
 3249 000a 002B     	 cmp r3,#0
 3250 000c 09D1     	 bne .L239
 3251              	.LBB197:
 3252              	.LBB198:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3253              	 .loc 2 195 0 discriminator 1
 3254              	
 3255 000e 4FF0FC03 	 mov r3,#252
 3256 0012 83F31188 	 msr basepri,r3
 3257 0016 BFF36F8F 	 isb 
 3258 001a BFF34F8F 	 dsb 
 3259              	
 3260              	
 3261              	 .thumb
 3262 001e BB60     	 str r3,[r7,#8]
 3263              	.L240:
 3264              	.LBE198:
 3265              	.LBE197:
 3266              	 .loc 1 1899 0 discriminator 1
 3267 0020 FEE7     	 b .L240
 3268              	.L239:
1900:../Dave/Generated/FREERTOS/queue.c **** 
1901:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 3269              	 .loc 1 1901 0
 3270 0022 FFF7FEFF 	 bl vPortEnterCritical
1902:../Dave/Generated/FREERTOS/queue.c **** 	{
1903:../Dave/Generated/FREERTOS/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 3271              	 .loc 1 1903 0
 3272 0026 7B68     	 ldr r3,[r7,#4]
 3273 0028 9B6B     	 ldr r3,[r3,#56]
 3274 002a FB60     	 str r3,[r7,#12]
1904:../Dave/Generated/FREERTOS/queue.c **** 	}
1905:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 3275              	 .loc 1 1905 0
 3276 002c FFF7FEFF 	 bl vPortExitCritical
1906:../Dave/Generated/FREERTOS/queue.c **** 
1907:../Dave/Generated/FREERTOS/queue.c **** 	return uxReturn;
 3277              	 .loc 1 1907 0
 3278 0030 FB68     	 ldr r3,[r7,#12]
1908:../Dave/Generated/FREERTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3279              	 .loc 1 1908 0
 3280 0032 1846     	 mov r0,r3
 3281 0034 1037     	 adds r7,r7,#16
 3282              	.LCFI94:
 3283              	 .cfi_def_cfa_offset 8
 3284 0036 BD46     	 mov sp,r7
 3285              	.LCFI95:
 3286              	 .cfi_def_cfa_register 13
 3287              	 
 3288 0038 80BD     	 pop {r7,pc}
 3289              	 .cfi_endproc
 3290              	.LFE153:
 3292 003a 00BF     	 .section .text.uxQueueSpacesAvailable,"ax",%progbits
 3293              	 .align 2
 3294              	 .global uxQueueSpacesAvailable
 3295              	 .thumb
 3296              	 .thumb_func
 3298              	uxQueueSpacesAvailable:
 3299              	.LFB154:
1909:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1910:../Dave/Generated/FREERTOS/queue.c **** 
1911:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1912:../Dave/Generated/FREERTOS/queue.c **** {
 3300              	 .loc 1 1912 0
 3301              	 .cfi_startproc
 3302              	 
 3303              	 
 3304 0000 80B5     	 push {r7,lr}
 3305              	.LCFI96:
 3306              	 .cfi_def_cfa_offset 8
 3307              	 .cfi_offset 7,-8
 3308              	 .cfi_offset 14,-4
 3309 0002 86B0     	 sub sp,sp,#24
 3310              	.LCFI97:
 3311              	 .cfi_def_cfa_offset 32
 3312 0004 00AF     	 add r7,sp,#0
 3313              	.LCFI98:
 3314              	 .cfi_def_cfa_register 7
 3315 0006 7860     	 str r0,[r7,#4]
1913:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxReturn;
1914:../Dave/Generated/FREERTOS/queue.c **** Queue_t *pxQueue;
1915:../Dave/Generated/FREERTOS/queue.c **** 
1916:../Dave/Generated/FREERTOS/queue.c **** 	pxQueue = ( Queue_t * ) xQueue;
 3316              	 .loc 1 1916 0
 3317 0008 7B68     	 ldr r3,[r7,#4]
 3318 000a 7B61     	 str r3,[r7,#20]
1917:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 3319              	 .loc 1 1917 0
 3320 000c 7B69     	 ldr r3,[r7,#20]
 3321 000e 002B     	 cmp r3,#0
 3322 0010 09D1     	 bne .L243
 3323              	.LBB199:
 3324              	.LBB200:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3325              	 .loc 2 195 0 discriminator 1
 3326              	
 3327 0012 4FF0FC03 	 mov r3,#252
 3328 0016 83F31188 	 msr basepri,r3
 3329 001a BFF36F8F 	 isb 
 3330 001e BFF34F8F 	 dsb 
 3331              	
 3332              	
 3333              	 .thumb
 3334 0022 FB60     	 str r3,[r7,#12]
 3335              	.L244:
 3336              	.LBE200:
 3337              	.LBE199:
 3338              	 .loc 1 1917 0 discriminator 1
 3339 0024 FEE7     	 b .L244
 3340              	.L243:
1918:../Dave/Generated/FREERTOS/queue.c **** 
1919:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 3341              	 .loc 1 1919 0
 3342 0026 FFF7FEFF 	 bl vPortEnterCritical
1920:../Dave/Generated/FREERTOS/queue.c **** 	{
1921:../Dave/Generated/FREERTOS/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 3343              	 .loc 1 1921 0
 3344 002a 7B69     	 ldr r3,[r7,#20]
 3345 002c DA6B     	 ldr r2,[r3,#60]
 3346 002e 7B69     	 ldr r3,[r7,#20]
 3347 0030 9B6B     	 ldr r3,[r3,#56]
 3348 0032 D31A     	 subs r3,r2,r3
 3349 0034 3B61     	 str r3,[r7,#16]
1922:../Dave/Generated/FREERTOS/queue.c **** 	}
1923:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 3350              	 .loc 1 1923 0
 3351 0036 FFF7FEFF 	 bl vPortExitCritical
1924:../Dave/Generated/FREERTOS/queue.c **** 
1925:../Dave/Generated/FREERTOS/queue.c **** 	return uxReturn;
 3352              	 .loc 1 1925 0
 3353 003a 3B69     	 ldr r3,[r7,#16]
1926:../Dave/Generated/FREERTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3354              	 .loc 1 1926 0
 3355 003c 1846     	 mov r0,r3
 3356 003e 1837     	 adds r7,r7,#24
 3357              	.LCFI99:
 3358              	 .cfi_def_cfa_offset 8
 3359 0040 BD46     	 mov sp,r7
 3360              	.LCFI100:
 3361              	 .cfi_def_cfa_register 13
 3362              	 
 3363 0042 80BD     	 pop {r7,pc}
 3364              	 .cfi_endproc
 3365              	.LFE154:
 3367              	 .section .text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 3368              	 .align 2
 3369              	 .global uxQueueMessagesWaitingFromISR
 3370              	 .thumb
 3371              	 .thumb_func
 3373              	uxQueueMessagesWaitingFromISR:
 3374              	.LFB155:
1927:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1928:../Dave/Generated/FREERTOS/queue.c **** 
1929:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1930:../Dave/Generated/FREERTOS/queue.c **** {
 3375              	 .loc 1 1930 0
 3376              	 .cfi_startproc
 3377              	 
 3378              	 
 3379              	 
 3380 0000 80B4     	 push {r7}
 3381              	.LCFI101:
 3382              	 .cfi_def_cfa_offset 4
 3383              	 .cfi_offset 7,-4
 3384 0002 85B0     	 sub sp,sp,#20
 3385              	.LCFI102:
 3386              	 .cfi_def_cfa_offset 24
 3387 0004 00AF     	 add r7,sp,#0
 3388              	.LCFI103:
 3389              	 .cfi_def_cfa_register 7
 3390 0006 7860     	 str r0,[r7,#4]
1931:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxReturn;
1932:../Dave/Generated/FREERTOS/queue.c **** 
1933:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( xQueue );
 3391              	 .loc 1 1933 0
 3392 0008 7B68     	 ldr r3,[r7,#4]
 3393 000a 002B     	 cmp r3,#0
 3394 000c 09D1     	 bne .L247
 3395              	.LBB201:
 3396              	.LBB202:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3397              	 .loc 2 195 0 discriminator 1
 3398              	
 3399 000e 4FF0FC03 	 mov r3,#252
 3400 0012 83F31188 	 msr basepri,r3
 3401 0016 BFF36F8F 	 isb 
 3402 001a BFF34F8F 	 dsb 
 3403              	
 3404              	
 3405              	 .thumb
 3406 001e BB60     	 str r3,[r7,#8]
 3407              	.L248:
 3408              	.LBE202:
 3409              	.LBE201:
 3410              	 .loc 1 1933 0 discriminator 1
 3411 0020 FEE7     	 b .L248
 3412              	.L247:
1934:../Dave/Generated/FREERTOS/queue.c **** 
1935:../Dave/Generated/FREERTOS/queue.c **** 	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 3413              	 .loc 1 1935 0
 3414 0022 7B68     	 ldr r3,[r7,#4]
 3415 0024 9B6B     	 ldr r3,[r3,#56]
 3416 0026 FB60     	 str r3,[r7,#12]
1936:../Dave/Generated/FREERTOS/queue.c **** 
1937:../Dave/Generated/FREERTOS/queue.c **** 	return uxReturn;
 3417              	 .loc 1 1937 0
 3418 0028 FB68     	 ldr r3,[r7,#12]
1938:../Dave/Generated/FREERTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3419              	 .loc 1 1938 0
 3420 002a 1846     	 mov r0,r3
 3421 002c 1437     	 adds r7,r7,#20
 3422              	.LCFI104:
 3423              	 .cfi_def_cfa_offset 4
 3424 002e BD46     	 mov sp,r7
 3425              	.LCFI105:
 3426              	 .cfi_def_cfa_register 13
 3427              	 
 3428 0030 5DF8047B 	 ldr r7,[sp],#4
 3429              	.LCFI106:
 3430              	 .cfi_restore 7
 3431              	 .cfi_def_cfa_offset 0
 3432 0034 7047     	 bx lr
 3433              	 .cfi_endproc
 3434              	.LFE155:
 3436 0036 00BF     	 .section .text.vQueueDelete,"ax",%progbits
 3437              	 .align 2
 3438              	 .global vQueueDelete
 3439              	 .thumb
 3440              	 .thumb_func
 3442              	vQueueDelete:
 3443              	.LFB156:
1939:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1940:../Dave/Generated/FREERTOS/queue.c **** 
1941:../Dave/Generated/FREERTOS/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1942:../Dave/Generated/FREERTOS/queue.c **** {
 3444              	 .loc 1 1942 0
 3445              	 .cfi_startproc
 3446              	 
 3447              	 
 3448 0000 80B5     	 push {r7,lr}
 3449              	.LCFI107:
 3450              	 .cfi_def_cfa_offset 8
 3451              	 .cfi_offset 7,-8
 3452              	 .cfi_offset 14,-4
 3453 0002 84B0     	 sub sp,sp,#16
 3454              	.LCFI108:
 3455              	 .cfi_def_cfa_offset 24
 3456 0004 00AF     	 add r7,sp,#0
 3457              	.LCFI109:
 3458              	 .cfi_def_cfa_register 7
 3459 0006 7860     	 str r0,[r7,#4]
1943:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 3460              	 .loc 1 1943 0
 3461 0008 7B68     	 ldr r3,[r7,#4]
 3462 000a FB60     	 str r3,[r7,#12]
1944:../Dave/Generated/FREERTOS/queue.c **** 
1945:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 3463              	 .loc 1 1945 0
 3464 000c FB68     	 ldr r3,[r7,#12]
 3465 000e 002B     	 cmp r3,#0
 3466 0010 09D1     	 bne .L251
 3467              	.LBB203:
 3468              	.LBB204:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3469              	 .loc 2 195 0 discriminator 1
 3470              	
 3471 0012 4FF0FC03 	 mov r3,#252
 3472 0016 83F31188 	 msr basepri,r3
 3473 001a BFF36F8F 	 isb 
 3474 001e BFF34F8F 	 dsb 
 3475              	
 3476              	
 3477              	 .thumb
 3478 0022 BB60     	 str r3,[r7,#8]
 3479              	.L252:
 3480              	.LBE204:
 3481              	.LBE203:
 3482              	 .loc 1 1945 0 discriminator 1
 3483 0024 FEE7     	 b .L252
 3484              	.L251:
1946:../Dave/Generated/FREERTOS/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1947:../Dave/Generated/FREERTOS/queue.c **** 
1948:../Dave/Generated/FREERTOS/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1949:../Dave/Generated/FREERTOS/queue.c **** 	{
1950:../Dave/Generated/FREERTOS/queue.c **** 		vQueueUnregisterQueue( pxQueue );
 3485              	 .loc 1 1950 0
 3486 0026 F868     	 ldr r0,[r7,#12]
 3487 0028 FFF7FEFF 	 bl vQueueUnregisterQueue
1951:../Dave/Generated/FREERTOS/queue.c **** 	}
1952:../Dave/Generated/FREERTOS/queue.c **** 	#endif
1953:../Dave/Generated/FREERTOS/queue.c **** 
1954:../Dave/Generated/FREERTOS/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1955:../Dave/Generated/FREERTOS/queue.c **** 	{
1956:../Dave/Generated/FREERTOS/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1957:../Dave/Generated/FREERTOS/queue.c **** 		again. */
1958:../Dave/Generated/FREERTOS/queue.c **** 		vPortFree( pxQueue );
 3488              	 .loc 1 1958 0
 3489 002c F868     	 ldr r0,[r7,#12]
 3490 002e FFF7FEFF 	 bl vPortFree
1959:../Dave/Generated/FREERTOS/queue.c **** 	}
1960:../Dave/Generated/FREERTOS/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1961:../Dave/Generated/FREERTOS/queue.c **** 	{
1962:../Dave/Generated/FREERTOS/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1963:../Dave/Generated/FREERTOS/queue.c **** 		check before attempting to free the memory. */
1964:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1965:../Dave/Generated/FREERTOS/queue.c **** 		{
1966:../Dave/Generated/FREERTOS/queue.c **** 			vPortFree( pxQueue );
1967:../Dave/Generated/FREERTOS/queue.c **** 		}
1968:../Dave/Generated/FREERTOS/queue.c **** 		else
1969:../Dave/Generated/FREERTOS/queue.c **** 		{
1970:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1971:../Dave/Generated/FREERTOS/queue.c **** 		}
1972:../Dave/Generated/FREERTOS/queue.c **** 	}
1973:../Dave/Generated/FREERTOS/queue.c **** 	#else
1974:../Dave/Generated/FREERTOS/queue.c **** 	{
1975:../Dave/Generated/FREERTOS/queue.c **** 		/* The queue must have been statically allocated, so is not going to be
1976:../Dave/Generated/FREERTOS/queue.c **** 		deleted.  Avoid compiler warnings about the unused parameter. */
1977:../Dave/Generated/FREERTOS/queue.c **** 		( void ) pxQueue;
1978:../Dave/Generated/FREERTOS/queue.c **** 	}
1979:../Dave/Generated/FREERTOS/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
1980:../Dave/Generated/FREERTOS/queue.c **** }
 3491              	 .loc 1 1980 0
 3492 0032 1037     	 adds r7,r7,#16
 3493              	.LCFI110:
 3494              	 .cfi_def_cfa_offset 8
 3495 0034 BD46     	 mov sp,r7
 3496              	.LCFI111:
 3497              	 .cfi_def_cfa_register 13
 3498              	 
 3499 0036 80BD     	 pop {r7,pc}
 3500              	 .cfi_endproc
 3501              	.LFE156:
 3503              	 .section .text.uxQueueGetQueueNumber,"ax",%progbits
 3504              	 .align 2
 3505              	 .global uxQueueGetQueueNumber
 3506              	 .thumb
 3507              	 .thumb_func
 3509              	uxQueueGetQueueNumber:
 3510              	.LFB157:
1981:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1982:../Dave/Generated/FREERTOS/queue.c **** 
1983:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1984:../Dave/Generated/FREERTOS/queue.c **** 
1985:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1986:../Dave/Generated/FREERTOS/queue.c **** 	{
 3511              	 .loc 1 1986 0
 3512              	 .cfi_startproc
 3513              	 
 3514              	 
 3515              	 
 3516 0000 80B4     	 push {r7}
 3517              	.LCFI112:
 3518              	 .cfi_def_cfa_offset 4
 3519              	 .cfi_offset 7,-4
 3520 0002 83B0     	 sub sp,sp,#12
 3521              	.LCFI113:
 3522              	 .cfi_def_cfa_offset 16
 3523 0004 00AF     	 add r7,sp,#0
 3524              	.LCFI114:
 3525              	 .cfi_def_cfa_register 7
 3526 0006 7860     	 str r0,[r7,#4]
1987:../Dave/Generated/FREERTOS/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 3527              	 .loc 1 1987 0
 3528 0008 7B68     	 ldr r3,[r7,#4]
 3529 000a DB6C     	 ldr r3,[r3,#76]
1988:../Dave/Generated/FREERTOS/queue.c **** 	}
 3530              	 .loc 1 1988 0
 3531 000c 1846     	 mov r0,r3
 3532 000e 0C37     	 adds r7,r7,#12
 3533              	.LCFI115:
 3534              	 .cfi_def_cfa_offset 4
 3535 0010 BD46     	 mov sp,r7
 3536              	.LCFI116:
 3537              	 .cfi_def_cfa_register 13
 3538              	 
 3539 0012 5DF8047B 	 ldr r7,[sp],#4
 3540              	.LCFI117:
 3541              	 .cfi_restore 7
 3542              	 .cfi_def_cfa_offset 0
 3543 0016 7047     	 bx lr
 3544              	 .cfi_endproc
 3545              	.LFE157:
 3547              	 .section .text.vQueueSetQueueNumber,"ax",%progbits
 3548              	 .align 2
 3549              	 .global vQueueSetQueueNumber
 3550              	 .thumb
 3551              	 .thumb_func
 3553              	vQueueSetQueueNumber:
 3554              	.LFB158:
1989:../Dave/Generated/FREERTOS/queue.c **** 
1990:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1991:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1992:../Dave/Generated/FREERTOS/queue.c **** 
1993:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1994:../Dave/Generated/FREERTOS/queue.c **** 
1995:../Dave/Generated/FREERTOS/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1996:../Dave/Generated/FREERTOS/queue.c **** 	{
 3555              	 .loc 1 1996 0
 3556              	 .cfi_startproc
 3557              	 
 3558              	 
 3559              	 
 3560 0000 80B4     	 push {r7}
 3561              	.LCFI118:
 3562              	 .cfi_def_cfa_offset 4
 3563              	 .cfi_offset 7,-4
 3564 0002 83B0     	 sub sp,sp,#12
 3565              	.LCFI119:
 3566              	 .cfi_def_cfa_offset 16
 3567 0004 00AF     	 add r7,sp,#0
 3568              	.LCFI120:
 3569              	 .cfi_def_cfa_register 7
 3570 0006 7860     	 str r0,[r7,#4]
 3571 0008 3960     	 str r1,[r7]
1997:../Dave/Generated/FREERTOS/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 3572              	 .loc 1 1997 0
 3573 000a 7B68     	 ldr r3,[r7,#4]
 3574 000c 3A68     	 ldr r2,[r7]
 3575 000e DA64     	 str r2,[r3,#76]
1998:../Dave/Generated/FREERTOS/queue.c **** 	}
 3576              	 .loc 1 1998 0
 3577 0010 0C37     	 adds r7,r7,#12
 3578              	.LCFI121:
 3579              	 .cfi_def_cfa_offset 4
 3580 0012 BD46     	 mov sp,r7
 3581              	.LCFI122:
 3582              	 .cfi_def_cfa_register 13
 3583              	 
 3584 0014 5DF8047B 	 ldr r7,[sp],#4
 3585              	.LCFI123:
 3586              	 .cfi_restore 7
 3587              	 .cfi_def_cfa_offset 0
 3588 0018 7047     	 bx lr
 3589              	 .cfi_endproc
 3590              	.LFE158:
 3592 001a 00BF     	 .section .text.ucQueueGetQueueType,"ax",%progbits
 3593              	 .align 2
 3594              	 .global ucQueueGetQueueType
 3595              	 .thumb
 3596              	 .thumb_func
 3598              	ucQueueGetQueueType:
 3599              	.LFB159:
1999:../Dave/Generated/FREERTOS/queue.c **** 
2000:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2001:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2002:../Dave/Generated/FREERTOS/queue.c **** 
2003:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2004:../Dave/Generated/FREERTOS/queue.c **** 
2005:../Dave/Generated/FREERTOS/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2006:../Dave/Generated/FREERTOS/queue.c **** 	{
 3600              	 .loc 1 2006 0
 3601              	 .cfi_startproc
 3602              	 
 3603              	 
 3604              	 
 3605 0000 80B4     	 push {r7}
 3606              	.LCFI124:
 3607              	 .cfi_def_cfa_offset 4
 3608              	 .cfi_offset 7,-4
 3609 0002 83B0     	 sub sp,sp,#12
 3610              	.LCFI125:
 3611              	 .cfi_def_cfa_offset 16
 3612 0004 00AF     	 add r7,sp,#0
 3613              	.LCFI126:
 3614              	 .cfi_def_cfa_register 7
 3615 0006 7860     	 str r0,[r7,#4]
2007:../Dave/Generated/FREERTOS/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
 3616              	 .loc 1 2007 0
 3617 0008 7B68     	 ldr r3,[r7,#4]
 3618 000a 93F85030 	 ldrb r3,[r3,#80]
2008:../Dave/Generated/FREERTOS/queue.c **** 	}
 3619              	 .loc 1 2008 0
 3620 000e 1846     	 mov r0,r3
 3621 0010 0C37     	 adds r7,r7,#12
 3622              	.LCFI127:
 3623              	 .cfi_def_cfa_offset 4
 3624 0012 BD46     	 mov sp,r7
 3625              	.LCFI128:
 3626              	 .cfi_def_cfa_register 13
 3627              	 
 3628 0014 5DF8047B 	 ldr r7,[sp],#4
 3629              	.LCFI129:
 3630              	 .cfi_restore 7
 3631              	 .cfi_def_cfa_offset 0
 3632 0018 7047     	 bx lr
 3633              	 .cfi_endproc
 3634              	.LFE159:
 3636 001a 00BF     	 .section .text.prvGetDisinheritPriorityAfterTimeout,"ax",%progbits
 3637              	 .align 2
 3638              	 .thumb
 3639              	 .thumb_func
 3641              	prvGetDisinheritPriorityAfterTimeout:
 3642              	.LFB160:
2009:../Dave/Generated/FREERTOS/queue.c **** 
2010:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2011:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2012:../Dave/Generated/FREERTOS/queue.c **** 
2013:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_MUTEXES == 1 )
2014:../Dave/Generated/FREERTOS/queue.c **** 
2015:../Dave/Generated/FREERTOS/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2016:../Dave/Generated/FREERTOS/queue.c **** 	{
 3643              	 .loc 1 2016 0
 3644              	 .cfi_startproc
 3645              	 
 3646              	 
 3647              	 
 3648 0000 80B4     	 push {r7}
 3649              	.LCFI130:
 3650              	 .cfi_def_cfa_offset 4
 3651              	 .cfi_offset 7,-4
 3652 0002 85B0     	 sub sp,sp,#20
 3653              	.LCFI131:
 3654              	 .cfi_def_cfa_offset 24
 3655 0004 00AF     	 add r7,sp,#0
 3656              	.LCFI132:
 3657              	 .cfi_def_cfa_register 7
 3658 0006 7860     	 str r0,[r7,#4]
2017:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t uxHighestPriorityOfWaitingTasks;
2018:../Dave/Generated/FREERTOS/queue.c **** 
2019:../Dave/Generated/FREERTOS/queue.c **** 		/* If a task waiting for a mutex causes the mutex holder to inherit a
2020:../Dave/Generated/FREERTOS/queue.c **** 		priority, but the waiting task times out, then the holder should
2021:../Dave/Generated/FREERTOS/queue.c **** 		disinherit the priority - but only down to the highest priority of any
2022:../Dave/Generated/FREERTOS/queue.c **** 		other tasks that are waiting for the same mutex.  For this purpose,
2023:../Dave/Generated/FREERTOS/queue.c **** 		return the priority of the highest priority task that is waiting for the
2024:../Dave/Generated/FREERTOS/queue.c **** 		mutex. */
2025:../Dave/Generated/FREERTOS/queue.c **** 		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
 3659              	 .loc 1 2025 0
 3660 0008 7B68     	 ldr r3,[r7,#4]
 3661 000a 5B6A     	 ldr r3,[r3,#36]
 3662 000c 002B     	 cmp r3,#0
 3663 000e 06D0     	 beq .L259
2026:../Dave/Generated/FREERTOS/queue.c **** 		{
2027:../Dave/Generated/FREERTOS/queue.c **** 			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( px
 3664              	 .loc 1 2027 0
 3665 0010 7B68     	 ldr r3,[r7,#4]
 3666 0012 1B6B     	 ldr r3,[r3,#48]
 3667 0014 1B68     	 ldr r3,[r3]
 3668 0016 C3F10503 	 rsb r3,r3,#5
 3669 001a FB60     	 str r3,[r7,#12]
 3670 001c 01E0     	 b .L260
 3671              	.L259:
2028:../Dave/Generated/FREERTOS/queue.c **** 		}
2029:../Dave/Generated/FREERTOS/queue.c **** 		else
2030:../Dave/Generated/FREERTOS/queue.c **** 		{
2031:../Dave/Generated/FREERTOS/queue.c **** 			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 3672              	 .loc 1 2031 0
 3673 001e 0023     	 movs r3,#0
 3674 0020 FB60     	 str r3,[r7,#12]
 3675              	.L260:
2032:../Dave/Generated/FREERTOS/queue.c **** 		}
2033:../Dave/Generated/FREERTOS/queue.c **** 
2034:../Dave/Generated/FREERTOS/queue.c **** 		return uxHighestPriorityOfWaitingTasks;
 3676              	 .loc 1 2034 0
 3677 0022 FB68     	 ldr r3,[r7,#12]
2035:../Dave/Generated/FREERTOS/queue.c **** 	}
 3678              	 .loc 1 2035 0
 3679 0024 1846     	 mov r0,r3
 3680 0026 1437     	 adds r7,r7,#20
 3681              	.LCFI133:
 3682              	 .cfi_def_cfa_offset 4
 3683 0028 BD46     	 mov sp,r7
 3684              	.LCFI134:
 3685              	 .cfi_def_cfa_register 13
 3686              	 
 3687 002a 5DF8047B 	 ldr r7,[sp],#4
 3688              	.LCFI135:
 3689              	 .cfi_restore 7
 3690              	 .cfi_def_cfa_offset 0
 3691 002e 7047     	 bx lr
 3692              	 .cfi_endproc
 3693              	.LFE160:
 3695              	 .section .text.prvCopyDataToQueue,"ax",%progbits
 3696              	 .align 2
 3697              	 .thumb
 3698              	 .thumb_func
 3700              	prvCopyDataToQueue:
 3701              	.LFB161:
2036:../Dave/Generated/FREERTOS/queue.c **** 
2037:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_MUTEXES */
2038:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2039:../Dave/Generated/FREERTOS/queue.c **** 
2040:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
2041:../Dave/Generated/FREERTOS/queue.c **** {
 3702              	 .loc 1 2041 0
 3703              	 .cfi_startproc
 3704              	 
 3705              	 
 3706 0000 80B5     	 push {r7,lr}
 3707              	.LCFI136:
 3708              	 .cfi_def_cfa_offset 8
 3709              	 .cfi_offset 7,-8
 3710              	 .cfi_offset 14,-4
 3711 0002 86B0     	 sub sp,sp,#24
 3712              	.LCFI137:
 3713              	 .cfi_def_cfa_offset 32
 3714 0004 00AF     	 add r7,sp,#0
 3715              	.LCFI138:
 3716              	 .cfi_def_cfa_register 7
 3717 0006 F860     	 str r0,[r7,#12]
 3718 0008 B960     	 str r1,[r7,#8]
 3719 000a 7A60     	 str r2,[r7,#4]
2042:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn = pdFALSE;
 3720              	 .loc 1 2042 0
 3721 000c 0023     	 movs r3,#0
 3722 000e 7B61     	 str r3,[r7,#20]
2043:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxMessagesWaiting;
2044:../Dave/Generated/FREERTOS/queue.c **** 
2045:../Dave/Generated/FREERTOS/queue.c **** 	/* This function is called from a critical section. */
2046:../Dave/Generated/FREERTOS/queue.c **** 
2047:../Dave/Generated/FREERTOS/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 3723              	 .loc 1 2047 0
 3724 0010 FB68     	 ldr r3,[r7,#12]
 3725 0012 9B6B     	 ldr r3,[r3,#56]
 3726 0014 3B61     	 str r3,[r7,#16]
2048:../Dave/Generated/FREERTOS/queue.c **** 
2049:../Dave/Generated/FREERTOS/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 3727              	 .loc 1 2049 0
 3728 0016 FB68     	 ldr r3,[r7,#12]
 3729 0018 1B6C     	 ldr r3,[r3,#64]
 3730 001a 002B     	 cmp r3,#0
 3731 001c 0DD1     	 bne .L263
2050:../Dave/Generated/FREERTOS/queue.c **** 	{
2051:../Dave/Generated/FREERTOS/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
2052:../Dave/Generated/FREERTOS/queue.c **** 		{
2053:../Dave/Generated/FREERTOS/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 3732              	 .loc 1 2053 0
 3733 001e FB68     	 ldr r3,[r7,#12]
 3734 0020 1B68     	 ldr r3,[r3]
 3735 0022 002B     	 cmp r3,#0
 3736 0024 4FD1     	 bne .L264
2054:../Dave/Generated/FREERTOS/queue.c **** 			{
2055:../Dave/Generated/FREERTOS/queue.c **** 				/* The mutex is no longer being held. */
2056:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 3737              	 .loc 1 2056 0
 3738 0026 FB68     	 ldr r3,[r7,#12]
 3739 0028 5B68     	 ldr r3,[r3,#4]
 3740 002a 1846     	 mov r0,r3
 3741 002c FFF7FEFF 	 bl xTaskPriorityDisinherit
 3742 0030 7861     	 str r0,[r7,#20]
2057:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 3743              	 .loc 1 2057 0
 3744 0032 FB68     	 ldr r3,[r7,#12]
 3745 0034 0022     	 movs r2,#0
 3746 0036 5A60     	 str r2,[r3,#4]
 3747 0038 45E0     	 b .L264
 3748              	.L263:
2058:../Dave/Generated/FREERTOS/queue.c **** 			}
2059:../Dave/Generated/FREERTOS/queue.c **** 			else
2060:../Dave/Generated/FREERTOS/queue.c **** 			{
2061:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2062:../Dave/Generated/FREERTOS/queue.c **** 			}
2063:../Dave/Generated/FREERTOS/queue.c **** 		}
2064:../Dave/Generated/FREERTOS/queue.c **** 		#endif /* configUSE_MUTEXES */
2065:../Dave/Generated/FREERTOS/queue.c **** 	}
2066:../Dave/Generated/FREERTOS/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 3749              	 .loc 1 2066 0
 3750 003a 7B68     	 ldr r3,[r7,#4]
 3751 003c 002B     	 cmp r3,#0
 3752 003e 1AD1     	 bne .L265
2067:../Dave/Generated/FREERTOS/queue.c **** 	{
2068:../Dave/Generated/FREERTOS/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 3753              	 .loc 1 2068 0
 3754 0040 FB68     	 ldr r3,[r7,#12]
 3755 0042 9A68     	 ldr r2,[r3,#8]
 3756 0044 FB68     	 ldr r3,[r7,#12]
 3757 0046 1B6C     	 ldr r3,[r3,#64]
 3758 0048 1046     	 mov r0,r2
 3759 004a B968     	 ldr r1,[r7,#8]
 3760 004c 1A46     	 mov r2,r3
 3761 004e FFF7FEFF 	 bl memcpy
2069:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 3762              	 .loc 1 2069 0
 3763 0052 FB68     	 ldr r3,[r7,#12]
 3764 0054 9A68     	 ldr r2,[r3,#8]
 3765 0056 FB68     	 ldr r3,[r7,#12]
 3766 0058 1B6C     	 ldr r3,[r3,#64]
 3767 005a 1A44     	 add r2,r2,r3
 3768 005c FB68     	 ldr r3,[r7,#12]
 3769 005e 9A60     	 str r2,[r3,#8]
2070:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 3770              	 .loc 1 2070 0
 3771 0060 FB68     	 ldr r3,[r7,#12]
 3772 0062 9A68     	 ldr r2,[r3,#8]
 3773 0064 FB68     	 ldr r3,[r7,#12]
 3774 0066 5B68     	 ldr r3,[r3,#4]
 3775 0068 9A42     	 cmp r2,r3
 3776 006a 2CD3     	 bcc .L264
2071:../Dave/Generated/FREERTOS/queue.c **** 		{
2072:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 3777              	 .loc 1 2072 0
 3778 006c FB68     	 ldr r3,[r7,#12]
 3779 006e 1A68     	 ldr r2,[r3]
 3780 0070 FB68     	 ldr r3,[r7,#12]
 3781 0072 9A60     	 str r2,[r3,#8]
 3782 0074 27E0     	 b .L264
 3783              	.L265:
2073:../Dave/Generated/FREERTOS/queue.c **** 		}
2074:../Dave/Generated/FREERTOS/queue.c **** 		else
2075:../Dave/Generated/FREERTOS/queue.c **** 		{
2076:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2077:../Dave/Generated/FREERTOS/queue.c **** 		}
2078:../Dave/Generated/FREERTOS/queue.c **** 	}
2079:../Dave/Generated/FREERTOS/queue.c **** 	else
2080:../Dave/Generated/FREERTOS/queue.c **** 	{
2081:../Dave/Generated/FREERTOS/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize 
 3784              	 .loc 1 2081 0
 3785 0076 FB68     	 ldr r3,[r7,#12]
 3786 0078 DA68     	 ldr r2,[r3,#12]
 3787 007a FB68     	 ldr r3,[r7,#12]
 3788 007c 1B6C     	 ldr r3,[r3,#64]
 3789 007e 1046     	 mov r0,r2
 3790 0080 B968     	 ldr r1,[r7,#8]
 3791 0082 1A46     	 mov r2,r3
 3792 0084 FFF7FEFF 	 bl memcpy
2082:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 3793              	 .loc 1 2082 0
 3794 0088 FB68     	 ldr r3,[r7,#12]
 3795 008a DA68     	 ldr r2,[r3,#12]
 3796 008c FB68     	 ldr r3,[r7,#12]
 3797 008e 1B6C     	 ldr r3,[r3,#64]
 3798 0090 5B42     	 negs r3,r3
 3799 0092 1A44     	 add r2,r2,r3
 3800 0094 FB68     	 ldr r3,[r7,#12]
 3801 0096 DA60     	 str r2,[r3,#12]
2083:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 3802              	 .loc 1 2083 0
 3803 0098 FB68     	 ldr r3,[r7,#12]
 3804 009a DA68     	 ldr r2,[r3,#12]
 3805 009c FB68     	 ldr r3,[r7,#12]
 3806 009e 1B68     	 ldr r3,[r3]
 3807 00a0 9A42     	 cmp r2,r3
 3808 00a2 07D2     	 bcs .L266
2084:../Dave/Generated/FREERTOS/queue.c **** 		{
2085:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 3809              	 .loc 1 2085 0
 3810 00a4 FB68     	 ldr r3,[r7,#12]
 3811 00a6 5A68     	 ldr r2,[r3,#4]
 3812 00a8 FB68     	 ldr r3,[r7,#12]
 3813 00aa 1B6C     	 ldr r3,[r3,#64]
 3814 00ac 5B42     	 negs r3,r3
 3815 00ae 1A44     	 add r2,r2,r3
 3816 00b0 FB68     	 ldr r3,[r7,#12]
 3817 00b2 DA60     	 str r2,[r3,#12]
 3818              	.L266:
2086:../Dave/Generated/FREERTOS/queue.c **** 		}
2087:../Dave/Generated/FREERTOS/queue.c **** 		else
2088:../Dave/Generated/FREERTOS/queue.c **** 		{
2089:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2090:../Dave/Generated/FREERTOS/queue.c **** 		}
2091:../Dave/Generated/FREERTOS/queue.c **** 
2092:../Dave/Generated/FREERTOS/queue.c **** 		if( xPosition == queueOVERWRITE )
 3819              	 .loc 1 2092 0
 3820 00b4 7B68     	 ldr r3,[r7,#4]
 3821 00b6 022B     	 cmp r3,#2
 3822 00b8 05D1     	 bne .L264
2093:../Dave/Generated/FREERTOS/queue.c **** 		{
2094:../Dave/Generated/FREERTOS/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 3823              	 .loc 1 2094 0
 3824 00ba 3B69     	 ldr r3,[r7,#16]
 3825 00bc 002B     	 cmp r3,#0
 3826 00be 02D0     	 beq .L264
2095:../Dave/Generated/FREERTOS/queue.c **** 			{
2096:../Dave/Generated/FREERTOS/queue.c **** 				/* An item is not being added but overwritten, so subtract
2097:../Dave/Generated/FREERTOS/queue.c **** 				one from the recorded number of items in the queue so when
2098:../Dave/Generated/FREERTOS/queue.c **** 				one is added again below the number of recorded items remains
2099:../Dave/Generated/FREERTOS/queue.c **** 				correct. */
2100:../Dave/Generated/FREERTOS/queue.c **** 				--uxMessagesWaiting;
 3827              	 .loc 1 2100 0
 3828 00c0 3B69     	 ldr r3,[r7,#16]
 3829 00c2 013B     	 subs r3,r3,#1
 3830 00c4 3B61     	 str r3,[r7,#16]
 3831              	.L264:
2101:../Dave/Generated/FREERTOS/queue.c **** 			}
2102:../Dave/Generated/FREERTOS/queue.c **** 			else
2103:../Dave/Generated/FREERTOS/queue.c **** 			{
2104:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2105:../Dave/Generated/FREERTOS/queue.c **** 			}
2106:../Dave/Generated/FREERTOS/queue.c **** 		}
2107:../Dave/Generated/FREERTOS/queue.c **** 		else
2108:../Dave/Generated/FREERTOS/queue.c **** 		{
2109:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2110:../Dave/Generated/FREERTOS/queue.c **** 		}
2111:../Dave/Generated/FREERTOS/queue.c **** 	}
2112:../Dave/Generated/FREERTOS/queue.c **** 
2113:../Dave/Generated/FREERTOS/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 3832              	 .loc 1 2113 0
 3833 00c6 3B69     	 ldr r3,[r7,#16]
 3834 00c8 5A1C     	 adds r2,r3,#1
 3835 00ca FB68     	 ldr r3,[r7,#12]
 3836 00cc 9A63     	 str r2,[r3,#56]
2114:../Dave/Generated/FREERTOS/queue.c **** 
2115:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 3837              	 .loc 1 2115 0
 3838 00ce 7B69     	 ldr r3,[r7,#20]
2116:../Dave/Generated/FREERTOS/queue.c **** }
 3839              	 .loc 1 2116 0
 3840 00d0 1846     	 mov r0,r3
 3841 00d2 1837     	 adds r7,r7,#24
 3842              	.LCFI139:
 3843              	 .cfi_def_cfa_offset 8
 3844 00d4 BD46     	 mov sp,r7
 3845              	.LCFI140:
 3846              	 .cfi_def_cfa_register 13
 3847              	 
 3848 00d6 80BD     	 pop {r7,pc}
 3849              	 .cfi_endproc
 3850              	.LFE161:
 3852              	 .section .text.prvCopyDataFromQueue,"ax",%progbits
 3853              	 .align 2
 3854              	 .thumb
 3855              	 .thumb_func
 3857              	prvCopyDataFromQueue:
 3858              	.LFB162:
2117:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2118:../Dave/Generated/FREERTOS/queue.c **** 
2119:../Dave/Generated/FREERTOS/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
2120:../Dave/Generated/FREERTOS/queue.c **** {
 3859              	 .loc 1 2120 0
 3860              	 .cfi_startproc
 3861              	 
 3862              	 
 3863 0000 80B5     	 push {r7,lr}
 3864              	.LCFI141:
 3865              	 .cfi_def_cfa_offset 8
 3866              	 .cfi_offset 7,-8
 3867              	 .cfi_offset 14,-4
 3868 0002 82B0     	 sub sp,sp,#8
 3869              	.LCFI142:
 3870              	 .cfi_def_cfa_offset 16
 3871 0004 00AF     	 add r7,sp,#0
 3872              	.LCFI143:
 3873              	 .cfi_def_cfa_register 7
 3874 0006 7860     	 str r0,[r7,#4]
 3875 0008 3960     	 str r1,[r7]
2121:../Dave/Generated/FREERTOS/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 3876              	 .loc 1 2121 0
 3877 000a 7B68     	 ldr r3,[r7,#4]
 3878 000c 1B6C     	 ldr r3,[r3,#64]
 3879 000e 002B     	 cmp r3,#0
 3880 0010 19D0     	 beq .L268
2122:../Dave/Generated/FREERTOS/queue.c **** 	{
2123:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 3881              	 .loc 1 2123 0
 3882 0012 7B68     	 ldr r3,[r7,#4]
 3883 0014 DA68     	 ldr r2,[r3,#12]
 3884 0016 7B68     	 ldr r3,[r7,#4]
 3885 0018 1B6C     	 ldr r3,[r3,#64]
 3886 001a 1A44     	 add r2,r2,r3
 3887 001c 7B68     	 ldr r3,[r7,#4]
 3888 001e DA60     	 str r2,[r3,#12]
2124:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 3889              	 .loc 1 2124 0
 3890 0020 7B68     	 ldr r3,[r7,#4]
 3891 0022 DA68     	 ldr r2,[r3,#12]
 3892 0024 7B68     	 ldr r3,[r7,#4]
 3893 0026 5B68     	 ldr r3,[r3,#4]
 3894 0028 9A42     	 cmp r2,r3
 3895 002a 03D3     	 bcc .L270
2125:../Dave/Generated/FREERTOS/queue.c **** 		{
2126:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 3896              	 .loc 1 2126 0
 3897 002c 7B68     	 ldr r3,[r7,#4]
 3898 002e 1A68     	 ldr r2,[r3]
 3899 0030 7B68     	 ldr r3,[r7,#4]
 3900 0032 DA60     	 str r2,[r3,#12]
 3901              	.L270:
2127:../Dave/Generated/FREERTOS/queue.c **** 		}
2128:../Dave/Generated/FREERTOS/queue.c **** 		else
2129:../Dave/Generated/FREERTOS/queue.c **** 		{
2130:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2131:../Dave/Generated/FREERTOS/queue.c **** 		}
2132:../Dave/Generated/FREERTOS/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
 3902              	 .loc 1 2132 0
 3903 0034 7B68     	 ldr r3,[r7,#4]
 3904 0036 DA68     	 ldr r2,[r3,#12]
 3905 0038 7B68     	 ldr r3,[r7,#4]
 3906 003a 1B6C     	 ldr r3,[r3,#64]
 3907 003c 3868     	 ldr r0,[r7]
 3908 003e 1146     	 mov r1,r2
 3909 0040 1A46     	 mov r2,r3
 3910 0042 FFF7FEFF 	 bl memcpy
 3911              	.L268:
2133:../Dave/Generated/FREERTOS/queue.c **** 	}
2134:../Dave/Generated/FREERTOS/queue.c **** }
 3912              	 .loc 1 2134 0
 3913 0046 0837     	 adds r7,r7,#8
 3914              	.LCFI144:
 3915              	 .cfi_def_cfa_offset 8
 3916 0048 BD46     	 mov sp,r7
 3917              	.LCFI145:
 3918              	 .cfi_def_cfa_register 13
 3919              	 
 3920 004a 80BD     	 pop {r7,pc}
 3921              	 .cfi_endproc
 3922              	.LFE162:
 3924              	 .section .text.prvUnlockQueue,"ax",%progbits
 3925              	 .align 2
 3926              	 .thumb
 3927              	 .thumb_func
 3929              	prvUnlockQueue:
 3930              	.LFB163:
2135:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2136:../Dave/Generated/FREERTOS/queue.c **** 
2137:../Dave/Generated/FREERTOS/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2138:../Dave/Generated/FREERTOS/queue.c **** {
 3931              	 .loc 1 2138 0
 3932              	 .cfi_startproc
 3933              	 
 3934              	 
 3935 0000 80B5     	 push {r7,lr}
 3936              	.LCFI146:
 3937              	 .cfi_def_cfa_offset 8
 3938              	 .cfi_offset 7,-8
 3939              	 .cfi_offset 14,-4
 3940 0002 84B0     	 sub sp,sp,#16
 3941              	.LCFI147:
 3942              	 .cfi_def_cfa_offset 24
 3943 0004 00AF     	 add r7,sp,#0
 3944              	.LCFI148:
 3945              	 .cfi_def_cfa_register 7
 3946 0006 7860     	 str r0,[r7,#4]
2139:../Dave/Generated/FREERTOS/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2140:../Dave/Generated/FREERTOS/queue.c **** 
2141:../Dave/Generated/FREERTOS/queue.c **** 	/* The lock counts contains the number of extra data items placed or
2142:../Dave/Generated/FREERTOS/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
2143:../Dave/Generated/FREERTOS/queue.c **** 	locked items can be added or removed, but the event lists cannot be
2144:../Dave/Generated/FREERTOS/queue.c **** 	updated. */
2145:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 3947              	 .loc 1 2145 0
 3948 0008 FFF7FEFF 	 bl vPortEnterCritical
 3949              	.LBB205:
2146:../Dave/Generated/FREERTOS/queue.c **** 	{
2147:../Dave/Generated/FREERTOS/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
 3950              	 .loc 1 2147 0
 3951 000c 7B68     	 ldr r3,[r7,#4]
 3952 000e 93F84530 	 ldrb r3,[r3,#69]
 3953 0012 FB73     	 strb r3,[r7,#15]
2148:../Dave/Generated/FREERTOS/queue.c **** 
2149:../Dave/Generated/FREERTOS/queue.c **** 		/* See if data was added to the queue while it was locked. */
2150:../Dave/Generated/FREERTOS/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
 3954              	 .loc 1 2150 0
 3955 0014 21E0     	 b .L272
 3956              	.L277:
2151:../Dave/Generated/FREERTOS/queue.c **** 		{
2152:../Dave/Generated/FREERTOS/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
2153:../Dave/Generated/FREERTOS/queue.c **** 			blocked waiting for data to become available? */
2154:../Dave/Generated/FREERTOS/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
2155:../Dave/Generated/FREERTOS/queue.c **** 			{
2156:../Dave/Generated/FREERTOS/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
 3957              	 .loc 1 2156 0
 3958 0016 7B68     	 ldr r3,[r7,#4]
 3959 0018 9B6C     	 ldr r3,[r3,#72]
 3960 001a 002B     	 cmp r3,#0
 3961 001c 09D0     	 beq .L273
2157:../Dave/Generated/FREERTOS/queue.c **** 				{
2158:../Dave/Generated/FREERTOS/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
 3962              	 .loc 1 2158 0
 3963 001e 7868     	 ldr r0,[r7,#4]
 3964 0020 0021     	 movs r1,#0
 3965 0022 FFF7FEFF 	 bl prvNotifyQueueSetContainer
 3966 0026 0346     	 mov r3,r0
 3967 0028 002B     	 cmp r3,#0
 3968 002a 12D0     	 beq .L274
2159:../Dave/Generated/FREERTOS/queue.c **** 					{
2160:../Dave/Generated/FREERTOS/queue.c **** 						/* The queue is a member of a queue set, and posting to
2161:../Dave/Generated/FREERTOS/queue.c **** 						the queue set caused a higher priority task to unblock.
2162:../Dave/Generated/FREERTOS/queue.c **** 						A context switch is required. */
2163:../Dave/Generated/FREERTOS/queue.c **** 						vTaskMissedYield();
 3969              	 .loc 1 2163 0
 3970 002c FFF7FEFF 	 bl vTaskMissedYield
 3971 0030 0FE0     	 b .L274
 3972              	.L273:
2164:../Dave/Generated/FREERTOS/queue.c **** 					}
2165:../Dave/Generated/FREERTOS/queue.c **** 					else
2166:../Dave/Generated/FREERTOS/queue.c **** 					{
2167:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2168:../Dave/Generated/FREERTOS/queue.c **** 					}
2169:../Dave/Generated/FREERTOS/queue.c **** 				}
2170:../Dave/Generated/FREERTOS/queue.c **** 				else
2171:../Dave/Generated/FREERTOS/queue.c **** 				{
2172:../Dave/Generated/FREERTOS/queue.c **** 					/* Tasks that are removed from the event list will get
2173:../Dave/Generated/FREERTOS/queue.c **** 					added to the pending ready list as the scheduler is still
2174:../Dave/Generated/FREERTOS/queue.c **** 					suspended. */
2175:../Dave/Generated/FREERTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 3973              	 .loc 1 2175 0
 3974 0032 7B68     	 ldr r3,[r7,#4]
 3975 0034 5B6A     	 ldr r3,[r3,#36]
 3976 0036 002B     	 cmp r3,#0
 3977 0038 0AD0     	 beq .L275
2176:../Dave/Generated/FREERTOS/queue.c **** 					{
2177:../Dave/Generated/FREERTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 3978              	 .loc 1 2177 0
 3979 003a 7B68     	 ldr r3,[r7,#4]
 3980 003c 2433     	 adds r3,r3,#36
 3981 003e 1846     	 mov r0,r3
 3982 0040 FFF7FEFF 	 bl xTaskRemoveFromEventList
 3983 0044 0346     	 mov r3,r0
 3984 0046 002B     	 cmp r3,#0
 3985 0048 03D0     	 beq .L274
2178:../Dave/Generated/FREERTOS/queue.c **** 						{
2179:../Dave/Generated/FREERTOS/queue.c **** 							/* The task waiting has a higher priority so record that a
2180:../Dave/Generated/FREERTOS/queue.c **** 							context	switch is required. */
2181:../Dave/Generated/FREERTOS/queue.c **** 							vTaskMissedYield();
 3986              	 .loc 1 2181 0
 3987 004a FFF7FEFF 	 bl vTaskMissedYield
 3988 004e 00E0     	 b .L274
 3989              	.L275:
2182:../Dave/Generated/FREERTOS/queue.c **** 						}
2183:../Dave/Generated/FREERTOS/queue.c **** 						else
2184:../Dave/Generated/FREERTOS/queue.c **** 						{
2185:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
2186:../Dave/Generated/FREERTOS/queue.c **** 						}
2187:../Dave/Generated/FREERTOS/queue.c **** 					}
2188:../Dave/Generated/FREERTOS/queue.c **** 					else
2189:../Dave/Generated/FREERTOS/queue.c **** 					{
2190:../Dave/Generated/FREERTOS/queue.c **** 						break;
 3990              	 .loc 1 2190 0
 3991 0050 07E0     	 b .L276
 3992              	.L274:
2191:../Dave/Generated/FREERTOS/queue.c **** 					}
2192:../Dave/Generated/FREERTOS/queue.c **** 				}
2193:../Dave/Generated/FREERTOS/queue.c **** 			}
2194:../Dave/Generated/FREERTOS/queue.c **** 			#else /* configUSE_QUEUE_SETS */
2195:../Dave/Generated/FREERTOS/queue.c **** 			{
2196:../Dave/Generated/FREERTOS/queue.c **** 				/* Tasks that are removed from the event list will get added to
2197:../Dave/Generated/FREERTOS/queue.c **** 				the pending ready list as the scheduler is still suspended. */
2198:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2199:../Dave/Generated/FREERTOS/queue.c **** 				{
2200:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2201:../Dave/Generated/FREERTOS/queue.c **** 					{
2202:../Dave/Generated/FREERTOS/queue.c **** 						/* The task waiting has a higher priority so record that
2203:../Dave/Generated/FREERTOS/queue.c **** 						a context switch is required. */
2204:../Dave/Generated/FREERTOS/queue.c **** 						vTaskMissedYield();
2205:../Dave/Generated/FREERTOS/queue.c **** 					}
2206:../Dave/Generated/FREERTOS/queue.c **** 					else
2207:../Dave/Generated/FREERTOS/queue.c **** 					{
2208:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2209:../Dave/Generated/FREERTOS/queue.c **** 					}
2210:../Dave/Generated/FREERTOS/queue.c **** 				}
2211:../Dave/Generated/FREERTOS/queue.c **** 				else
2212:../Dave/Generated/FREERTOS/queue.c **** 				{
2213:../Dave/Generated/FREERTOS/queue.c **** 					break;
2214:../Dave/Generated/FREERTOS/queue.c **** 				}
2215:../Dave/Generated/FREERTOS/queue.c **** 			}
2216:../Dave/Generated/FREERTOS/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
2217:../Dave/Generated/FREERTOS/queue.c **** 
2218:../Dave/Generated/FREERTOS/queue.c **** 			--cTxLock;
 3993              	 .loc 1 2218 0
 3994 0052 FB7B     	 ldrb r3,[r7,#15]
 3995 0054 013B     	 subs r3,r3,#1
 3996 0056 DBB2     	 uxtb r3,r3
 3997 0058 FB73     	 strb r3,[r7,#15]
 3998              	.L272:
2150:../Dave/Generated/FREERTOS/queue.c **** 		{
 3999              	 .loc 1 2150 0
 4000 005a 97F90F30 	 ldrsb r3,[r7,#15]
 4001 005e 002B     	 cmp r3,#0
 4002 0060 D9DC     	 bgt .L277
 4003              	.L276:
2219:../Dave/Generated/FREERTOS/queue.c **** 		}
2220:../Dave/Generated/FREERTOS/queue.c **** 
2221:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 4004              	 .loc 1 2221 0
 4005 0062 7B68     	 ldr r3,[r7,#4]
 4006 0064 FF22     	 movs r2,#255
 4007 0066 83F84520 	 strb r2,[r3,#69]
 4008              	.LBE205:
2222:../Dave/Generated/FREERTOS/queue.c **** 	}
2223:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 4009              	 .loc 1 2223 0
 4010 006a FFF7FEFF 	 bl vPortExitCritical
2224:../Dave/Generated/FREERTOS/queue.c **** 
2225:../Dave/Generated/FREERTOS/queue.c **** 	/* Do the same for the Rx lock. */
2226:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 4011              	 .loc 1 2226 0
 4012 006e FFF7FEFF 	 bl vPortEnterCritical
 4013              	.LBB206:
2227:../Dave/Generated/FREERTOS/queue.c **** 	{
2228:../Dave/Generated/FREERTOS/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
 4014              	 .loc 1 2228 0
 4015 0072 7B68     	 ldr r3,[r7,#4]
 4016 0074 93F84430 	 ldrb r3,[r3,#68]
 4017 0078 BB73     	 strb r3,[r7,#14]
2229:../Dave/Generated/FREERTOS/queue.c **** 
2230:../Dave/Generated/FREERTOS/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
 4018              	 .loc 1 2230 0
 4019 007a 13E0     	 b .L278
 4020              	.L282:
2231:../Dave/Generated/FREERTOS/queue.c **** 		{
2232:../Dave/Generated/FREERTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4021              	 .loc 1 2232 0
 4022 007c 7B68     	 ldr r3,[r7,#4]
 4023 007e 1B69     	 ldr r3,[r3,#16]
 4024 0080 002B     	 cmp r3,#0
 4025 0082 0ED0     	 beq .L279
2233:../Dave/Generated/FREERTOS/queue.c **** 			{
2234:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4026              	 .loc 1 2234 0
 4027 0084 7B68     	 ldr r3,[r7,#4]
 4028 0086 1033     	 adds r3,r3,#16
 4029 0088 1846     	 mov r0,r3
 4030 008a FFF7FEFF 	 bl xTaskRemoveFromEventList
 4031 008e 0346     	 mov r3,r0
 4032 0090 002B     	 cmp r3,#0
 4033 0092 01D0     	 beq .L280
2235:../Dave/Generated/FREERTOS/queue.c **** 				{
2236:../Dave/Generated/FREERTOS/queue.c **** 					vTaskMissedYield();
 4034              	 .loc 1 2236 0
 4035 0094 FFF7FEFF 	 bl vTaskMissedYield
 4036              	.L280:
2237:../Dave/Generated/FREERTOS/queue.c **** 				}
2238:../Dave/Generated/FREERTOS/queue.c **** 				else
2239:../Dave/Generated/FREERTOS/queue.c **** 				{
2240:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2241:../Dave/Generated/FREERTOS/queue.c **** 				}
2242:../Dave/Generated/FREERTOS/queue.c **** 
2243:../Dave/Generated/FREERTOS/queue.c **** 				--cRxLock;
 4037              	 .loc 1 2243 0
 4038 0098 BB7B     	 ldrb r3,[r7,#14]
 4039 009a 013B     	 subs r3,r3,#1
 4040 009c DBB2     	 uxtb r3,r3
 4041 009e BB73     	 strb r3,[r7,#14]
 4042 00a0 00E0     	 b .L278
 4043              	.L279:
2244:../Dave/Generated/FREERTOS/queue.c **** 			}
2245:../Dave/Generated/FREERTOS/queue.c **** 			else
2246:../Dave/Generated/FREERTOS/queue.c **** 			{
2247:../Dave/Generated/FREERTOS/queue.c **** 				break;
 4044              	 .loc 1 2247 0
 4045 00a2 03E0     	 b .L281
 4046              	.L278:
2230:../Dave/Generated/FREERTOS/queue.c **** 		{
 4047              	 .loc 1 2230 0
 4048 00a4 97F90E30 	 ldrsb r3,[r7,#14]
 4049 00a8 002B     	 cmp r3,#0
 4050 00aa E7DC     	 bgt .L282
 4051              	.L281:
2248:../Dave/Generated/FREERTOS/queue.c **** 			}
2249:../Dave/Generated/FREERTOS/queue.c **** 		}
2250:../Dave/Generated/FREERTOS/queue.c **** 
2251:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 4052              	 .loc 1 2251 0
 4053 00ac 7B68     	 ldr r3,[r7,#4]
 4054 00ae FF22     	 movs r2,#255
 4055 00b0 83F84420 	 strb r2,[r3,#68]
 4056              	.LBE206:
2252:../Dave/Generated/FREERTOS/queue.c **** 	}
2253:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 4057              	 .loc 1 2253 0
 4058 00b4 FFF7FEFF 	 bl vPortExitCritical
2254:../Dave/Generated/FREERTOS/queue.c **** }
 4059              	 .loc 1 2254 0
 4060 00b8 1037     	 adds r7,r7,#16
 4061              	.LCFI149:
 4062              	 .cfi_def_cfa_offset 8
 4063 00ba BD46     	 mov sp,r7
 4064              	.LCFI150:
 4065              	 .cfi_def_cfa_register 13
 4066              	 
 4067 00bc 80BD     	 pop {r7,pc}
 4068              	 .cfi_endproc
 4069              	.LFE163:
 4071 00be 00BF     	 .section .text.prvIsQueueEmpty,"ax",%progbits
 4072              	 .align 2
 4073              	 .thumb
 4074              	 .thumb_func
 4076              	prvIsQueueEmpty:
 4077              	.LFB164:
2255:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2256:../Dave/Generated/FREERTOS/queue.c **** 
2257:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
2258:../Dave/Generated/FREERTOS/queue.c **** {
 4078              	 .loc 1 2258 0
 4079              	 .cfi_startproc
 4080              	 
 4081              	 
 4082 0000 80B5     	 push {r7,lr}
 4083              	.LCFI151:
 4084              	 .cfi_def_cfa_offset 8
 4085              	 .cfi_offset 7,-8
 4086              	 .cfi_offset 14,-4
 4087 0002 84B0     	 sub sp,sp,#16
 4088              	.LCFI152:
 4089              	 .cfi_def_cfa_offset 24
 4090 0004 00AF     	 add r7,sp,#0
 4091              	.LCFI153:
 4092              	 .cfi_def_cfa_register 7
 4093 0006 7860     	 str r0,[r7,#4]
2259:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
2260:../Dave/Generated/FREERTOS/queue.c **** 
2261:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 4094              	 .loc 1 2261 0
 4095 0008 FFF7FEFF 	 bl vPortEnterCritical
2262:../Dave/Generated/FREERTOS/queue.c **** 	{
2263:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 4096              	 .loc 1 2263 0
 4097 000c 7B68     	 ldr r3,[r7,#4]
 4098 000e 9B6B     	 ldr r3,[r3,#56]
 4099 0010 002B     	 cmp r3,#0
 4100 0012 02D1     	 bne .L284
2264:../Dave/Generated/FREERTOS/queue.c **** 		{
2265:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdTRUE;
 4101              	 .loc 1 2265 0
 4102 0014 0123     	 movs r3,#1
 4103 0016 FB60     	 str r3,[r7,#12]
 4104 0018 01E0     	 b .L285
 4105              	.L284:
2266:../Dave/Generated/FREERTOS/queue.c **** 		}
2267:../Dave/Generated/FREERTOS/queue.c **** 		else
2268:../Dave/Generated/FREERTOS/queue.c **** 		{
2269:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFALSE;
 4106              	 .loc 1 2269 0
 4107 001a 0023     	 movs r3,#0
 4108 001c FB60     	 str r3,[r7,#12]
 4109              	.L285:
2270:../Dave/Generated/FREERTOS/queue.c **** 		}
2271:../Dave/Generated/FREERTOS/queue.c **** 	}
2272:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 4110              	 .loc 1 2272 0
 4111 001e FFF7FEFF 	 bl vPortExitCritical
2273:../Dave/Generated/FREERTOS/queue.c **** 
2274:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 4112              	 .loc 1 2274 0
 4113 0022 FB68     	 ldr r3,[r7,#12]
2275:../Dave/Generated/FREERTOS/queue.c **** }
 4114              	 .loc 1 2275 0
 4115 0024 1846     	 mov r0,r3
 4116 0026 1037     	 adds r7,r7,#16
 4117              	.LCFI154:
 4118              	 .cfi_def_cfa_offset 8
 4119 0028 BD46     	 mov sp,r7
 4120              	.LCFI155:
 4121              	 .cfi_def_cfa_register 13
 4122              	 
 4123 002a 80BD     	 pop {r7,pc}
 4124              	 .cfi_endproc
 4125              	.LFE164:
 4127              	 .section .text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 4128              	 .align 2
 4129              	 .global xQueueIsQueueEmptyFromISR
 4130              	 .thumb
 4131              	 .thumb_func
 4133              	xQueueIsQueueEmptyFromISR:
 4134              	.LFB165:
2276:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2277:../Dave/Generated/FREERTOS/queue.c **** 
2278:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2279:../Dave/Generated/FREERTOS/queue.c **** {
 4135              	 .loc 1 2279 0
 4136              	 .cfi_startproc
 4137              	 
 4138              	 
 4139              	 
 4140 0000 80B4     	 push {r7}
 4141              	.LCFI156:
 4142              	 .cfi_def_cfa_offset 4
 4143              	 .cfi_offset 7,-4
 4144 0002 85B0     	 sub sp,sp,#20
 4145              	.LCFI157:
 4146              	 .cfi_def_cfa_offset 24
 4147 0004 00AF     	 add r7,sp,#0
 4148              	.LCFI158:
 4149              	 .cfi_def_cfa_register 7
 4150 0006 7860     	 str r0,[r7,#4]
2280:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
2281:../Dave/Generated/FREERTOS/queue.c **** 
2282:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( xQueue );
 4151              	 .loc 1 2282 0
 4152 0008 7B68     	 ldr r3,[r7,#4]
 4153 000a 002B     	 cmp r3,#0
 4154 000c 09D1     	 bne .L288
 4155              	.LBB207:
 4156              	.LBB208:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 4157              	 .loc 2 195 0 discriminator 1
 4158              	
 4159 000e 4FF0FC03 	 mov r3,#252
 4160 0012 83F31188 	 msr basepri,r3
 4161 0016 BFF36F8F 	 isb 
 4162 001a BFF34F8F 	 dsb 
 4163              	
 4164              	
 4165              	 .thumb
 4166 001e BB60     	 str r3,[r7,#8]
 4167              	.L289:
 4168              	.LBE208:
 4169              	.LBE207:
 4170              	 .loc 1 2282 0 discriminator 1
 4171 0020 FEE7     	 b .L289
 4172              	.L288:
2283:../Dave/Generated/FREERTOS/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 4173              	 .loc 1 2283 0
 4174 0022 7B68     	 ldr r3,[r7,#4]
 4175 0024 9B6B     	 ldr r3,[r3,#56]
 4176 0026 002B     	 cmp r3,#0
 4177 0028 02D1     	 bne .L290
2284:../Dave/Generated/FREERTOS/queue.c **** 	{
2285:../Dave/Generated/FREERTOS/queue.c **** 		xReturn = pdTRUE;
 4178              	 .loc 1 2285 0
 4179 002a 0123     	 movs r3,#1
 4180 002c FB60     	 str r3,[r7,#12]
 4181 002e 01E0     	 b .L291
 4182              	.L290:
2286:../Dave/Generated/FREERTOS/queue.c **** 	}
2287:../Dave/Generated/FREERTOS/queue.c **** 	else
2288:../Dave/Generated/FREERTOS/queue.c **** 	{
2289:../Dave/Generated/FREERTOS/queue.c **** 		xReturn = pdFALSE;
 4183              	 .loc 1 2289 0
 4184 0030 0023     	 movs r3,#0
 4185 0032 FB60     	 str r3,[r7,#12]
 4186              	.L291:
2290:../Dave/Generated/FREERTOS/queue.c **** 	}
2291:../Dave/Generated/FREERTOS/queue.c **** 
2292:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 4187              	 .loc 1 2292 0
 4188 0034 FB68     	 ldr r3,[r7,#12]
2293:../Dave/Generated/FREERTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 4189              	 .loc 1 2293 0
 4190 0036 1846     	 mov r0,r3
 4191 0038 1437     	 adds r7,r7,#20
 4192              	.LCFI159:
 4193              	 .cfi_def_cfa_offset 4
 4194 003a BD46     	 mov sp,r7
 4195              	.LCFI160:
 4196              	 .cfi_def_cfa_register 13
 4197              	 
 4198 003c 5DF8047B 	 ldr r7,[sp],#4
 4199              	.LCFI161:
 4200              	 .cfi_restore 7
 4201              	 .cfi_def_cfa_offset 0
 4202 0040 7047     	 bx lr
 4203              	 .cfi_endproc
 4204              	.LFE165:
 4206 0042 00BF     	 .section .text.prvIsQueueFull,"ax",%progbits
 4207              	 .align 2
 4208              	 .thumb
 4209              	 .thumb_func
 4211              	prvIsQueueFull:
 4212              	.LFB166:
2294:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2295:../Dave/Generated/FREERTOS/queue.c **** 
2296:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2297:../Dave/Generated/FREERTOS/queue.c **** {
 4213              	 .loc 1 2297 0
 4214              	 .cfi_startproc
 4215              	 
 4216              	 
 4217 0000 80B5     	 push {r7,lr}
 4218              	.LCFI162:
 4219              	 .cfi_def_cfa_offset 8
 4220              	 .cfi_offset 7,-8
 4221              	 .cfi_offset 14,-4
 4222 0002 84B0     	 sub sp,sp,#16
 4223              	.LCFI163:
 4224              	 .cfi_def_cfa_offset 24
 4225 0004 00AF     	 add r7,sp,#0
 4226              	.LCFI164:
 4227              	 .cfi_def_cfa_register 7
 4228 0006 7860     	 str r0,[r7,#4]
2298:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
2299:../Dave/Generated/FREERTOS/queue.c **** 
2300:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 4229              	 .loc 1 2300 0
 4230 0008 FFF7FEFF 	 bl vPortEnterCritical
2301:../Dave/Generated/FREERTOS/queue.c **** 	{
2302:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 4231              	 .loc 1 2302 0
 4232 000c 7B68     	 ldr r3,[r7,#4]
 4233 000e 9A6B     	 ldr r2,[r3,#56]
 4234 0010 7B68     	 ldr r3,[r7,#4]
 4235 0012 DB6B     	 ldr r3,[r3,#60]
 4236 0014 9A42     	 cmp r2,r3
 4237 0016 02D1     	 bne .L294
2303:../Dave/Generated/FREERTOS/queue.c **** 		{
2304:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdTRUE;
 4238              	 .loc 1 2304 0
 4239 0018 0123     	 movs r3,#1
 4240 001a FB60     	 str r3,[r7,#12]
 4241 001c 01E0     	 b .L295
 4242              	.L294:
2305:../Dave/Generated/FREERTOS/queue.c **** 		}
2306:../Dave/Generated/FREERTOS/queue.c **** 		else
2307:../Dave/Generated/FREERTOS/queue.c **** 		{
2308:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFALSE;
 4243              	 .loc 1 2308 0
 4244 001e 0023     	 movs r3,#0
 4245 0020 FB60     	 str r3,[r7,#12]
 4246              	.L295:
2309:../Dave/Generated/FREERTOS/queue.c **** 		}
2310:../Dave/Generated/FREERTOS/queue.c **** 	}
2311:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 4247              	 .loc 1 2311 0
 4248 0022 FFF7FEFF 	 bl vPortExitCritical
2312:../Dave/Generated/FREERTOS/queue.c **** 
2313:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 4249              	 .loc 1 2313 0
 4250 0026 FB68     	 ldr r3,[r7,#12]
2314:../Dave/Generated/FREERTOS/queue.c **** }
 4251              	 .loc 1 2314 0
 4252 0028 1846     	 mov r0,r3
 4253 002a 1037     	 adds r7,r7,#16
 4254              	.LCFI165:
 4255              	 .cfi_def_cfa_offset 8
 4256 002c BD46     	 mov sp,r7
 4257              	.LCFI166:
 4258              	 .cfi_def_cfa_register 13
 4259              	 
 4260 002e 80BD     	 pop {r7,pc}
 4261              	 .cfi_endproc
 4262              	.LFE166:
 4264              	 .section .text.xQueueIsQueueFullFromISR,"ax",%progbits
 4265              	 .align 2
 4266              	 .global xQueueIsQueueFullFromISR
 4267              	 .thumb
 4268              	 .thumb_func
 4270              	xQueueIsQueueFullFromISR:
 4271              	.LFB167:
2315:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2316:../Dave/Generated/FREERTOS/queue.c **** 
2317:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2318:../Dave/Generated/FREERTOS/queue.c **** {
 4272              	 .loc 1 2318 0
 4273              	 .cfi_startproc
 4274              	 
 4275              	 
 4276              	 
 4277 0000 80B4     	 push {r7}
 4278              	.LCFI167:
 4279              	 .cfi_def_cfa_offset 4
 4280              	 .cfi_offset 7,-4
 4281 0002 85B0     	 sub sp,sp,#20
 4282              	.LCFI168:
 4283              	 .cfi_def_cfa_offset 24
 4284 0004 00AF     	 add r7,sp,#0
 4285              	.LCFI169:
 4286              	 .cfi_def_cfa_register 7
 4287 0006 7860     	 str r0,[r7,#4]
2319:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
2320:../Dave/Generated/FREERTOS/queue.c **** 
2321:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( xQueue );
 4288              	 .loc 1 2321 0
 4289 0008 7B68     	 ldr r3,[r7,#4]
 4290 000a 002B     	 cmp r3,#0
 4291 000c 09D1     	 bne .L298
 4292              	.LBB209:
 4293              	.LBB210:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 4294              	 .loc 2 195 0 discriminator 1
 4295              	
 4296 000e 4FF0FC03 	 mov r3,#252
 4297 0012 83F31188 	 msr basepri,r3
 4298 0016 BFF36F8F 	 isb 
 4299 001a BFF34F8F 	 dsb 
 4300              	
 4301              	
 4302              	 .thumb
 4303 001e BB60     	 str r3,[r7,#8]
 4304              	.L299:
 4305              	.LBE210:
 4306              	.LBE209:
 4307              	 .loc 1 2321 0 discriminator 1
 4308 0020 FEE7     	 b .L299
 4309              	.L298:
2322:../Dave/Generated/FREERTOS/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 4310              	 .loc 1 2322 0
 4311 0022 7B68     	 ldr r3,[r7,#4]
 4312 0024 9A6B     	 ldr r2,[r3,#56]
 4313 0026 7B68     	 ldr r3,[r7,#4]
 4314 0028 DB6B     	 ldr r3,[r3,#60]
 4315 002a 9A42     	 cmp r2,r3
 4316 002c 02D1     	 bne .L300
2323:../Dave/Generated/FREERTOS/queue.c **** 	{
2324:../Dave/Generated/FREERTOS/queue.c **** 		xReturn = pdTRUE;
 4317              	 .loc 1 2324 0
 4318 002e 0123     	 movs r3,#1
 4319 0030 FB60     	 str r3,[r7,#12]
 4320 0032 01E0     	 b .L301
 4321              	.L300:
2325:../Dave/Generated/FREERTOS/queue.c **** 	}
2326:../Dave/Generated/FREERTOS/queue.c **** 	else
2327:../Dave/Generated/FREERTOS/queue.c **** 	{
2328:../Dave/Generated/FREERTOS/queue.c **** 		xReturn = pdFALSE;
 4322              	 .loc 1 2328 0
 4323 0034 0023     	 movs r3,#0
 4324 0036 FB60     	 str r3,[r7,#12]
 4325              	.L301:
2329:../Dave/Generated/FREERTOS/queue.c **** 	}
2330:../Dave/Generated/FREERTOS/queue.c **** 
2331:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 4326              	 .loc 1 2331 0
 4327 0038 FB68     	 ldr r3,[r7,#12]
2332:../Dave/Generated/FREERTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 4328              	 .loc 1 2332 0
 4329 003a 1846     	 mov r0,r3
 4330 003c 1437     	 adds r7,r7,#20
 4331              	.LCFI170:
 4332              	 .cfi_def_cfa_offset 4
 4333 003e BD46     	 mov sp,r7
 4334              	.LCFI171:
 4335              	 .cfi_def_cfa_register 13
 4336              	 
 4337 0040 5DF8047B 	 ldr r7,[sp],#4
 4338              	.LCFI172:
 4339              	 .cfi_restore 7
 4340              	 .cfi_def_cfa_offset 0
 4341 0044 7047     	 bx lr
 4342              	 .cfi_endproc
 4343              	.LFE167:
 4345 0046 00BF     	 .section .text.vQueueAddToRegistry,"ax",%progbits
 4346              	 .align 2
 4347              	 .global vQueueAddToRegistry
 4348              	 .thumb
 4349              	 .thumb_func
 4351              	vQueueAddToRegistry:
 4352              	.LFB168:
2333:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2334:../Dave/Generated/FREERTOS/queue.c **** 
2335:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2336:../Dave/Generated/FREERTOS/queue.c **** 
2337:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
2338:../Dave/Generated/FREERTOS/queue.c **** 	{
2339:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
2340:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2341:../Dave/Generated/FREERTOS/queue.c **** 
2342:../Dave/Generated/FREERTOS/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2343:../Dave/Generated/FREERTOS/queue.c **** 		is required to prevent an interrupt removing something from the queue
2344:../Dave/Generated/FREERTOS/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2345:../Dave/Generated/FREERTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2346:../Dave/Generated/FREERTOS/queue.c **** 		{
2347:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
2348:../Dave/Generated/FREERTOS/queue.c **** 			{
2349:../Dave/Generated/FREERTOS/queue.c **** 				/* The queue is full - do we want to block or just leave without
2350:../Dave/Generated/FREERTOS/queue.c **** 				posting? */
2351:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2352:../Dave/Generated/FREERTOS/queue.c **** 				{
2353:../Dave/Generated/FREERTOS/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2354:../Dave/Generated/FREERTOS/queue.c **** 					return indicating that we need to block. */
2355:../Dave/Generated/FREERTOS/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2356:../Dave/Generated/FREERTOS/queue.c **** 					portENABLE_INTERRUPTS();
2357:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_BLOCKED;
2358:../Dave/Generated/FREERTOS/queue.c **** 				}
2359:../Dave/Generated/FREERTOS/queue.c **** 				else
2360:../Dave/Generated/FREERTOS/queue.c **** 				{
2361:../Dave/Generated/FREERTOS/queue.c **** 					portENABLE_INTERRUPTS();
2362:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_FULL;
2363:../Dave/Generated/FREERTOS/queue.c **** 				}
2364:../Dave/Generated/FREERTOS/queue.c **** 			}
2365:../Dave/Generated/FREERTOS/queue.c **** 		}
2366:../Dave/Generated/FREERTOS/queue.c **** 		portENABLE_INTERRUPTS();
2367:../Dave/Generated/FREERTOS/queue.c **** 
2368:../Dave/Generated/FREERTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2369:../Dave/Generated/FREERTOS/queue.c **** 		{
2370:../Dave/Generated/FREERTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2371:../Dave/Generated/FREERTOS/queue.c **** 			{
2372:../Dave/Generated/FREERTOS/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2373:../Dave/Generated/FREERTOS/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2374:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdPASS;
2375:../Dave/Generated/FREERTOS/queue.c **** 
2376:../Dave/Generated/FREERTOS/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2377:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2378:../Dave/Generated/FREERTOS/queue.c **** 				{
2379:../Dave/Generated/FREERTOS/queue.c **** 					/* In this instance the co-routine could be placed directly
2380:../Dave/Generated/FREERTOS/queue.c **** 					into the ready list as we are within a critical section.
2381:../Dave/Generated/FREERTOS/queue.c **** 					Instead the same pending ready list mechanism is used as if
2382:../Dave/Generated/FREERTOS/queue.c **** 					the event were caused from within an interrupt. */
2383:../Dave/Generated/FREERTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2384:../Dave/Generated/FREERTOS/queue.c **** 					{
2385:../Dave/Generated/FREERTOS/queue.c **** 						/* The co-routine waiting has a higher priority so record
2386:../Dave/Generated/FREERTOS/queue.c **** 						that a yield might be appropriate. */
2387:../Dave/Generated/FREERTOS/queue.c **** 						xReturn = errQUEUE_YIELD;
2388:../Dave/Generated/FREERTOS/queue.c **** 					}
2389:../Dave/Generated/FREERTOS/queue.c **** 					else
2390:../Dave/Generated/FREERTOS/queue.c **** 					{
2391:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2392:../Dave/Generated/FREERTOS/queue.c **** 					}
2393:../Dave/Generated/FREERTOS/queue.c **** 				}
2394:../Dave/Generated/FREERTOS/queue.c **** 				else
2395:../Dave/Generated/FREERTOS/queue.c **** 				{
2396:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2397:../Dave/Generated/FREERTOS/queue.c **** 				}
2398:../Dave/Generated/FREERTOS/queue.c **** 			}
2399:../Dave/Generated/FREERTOS/queue.c **** 			else
2400:../Dave/Generated/FREERTOS/queue.c **** 			{
2401:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = errQUEUE_FULL;
2402:../Dave/Generated/FREERTOS/queue.c **** 			}
2403:../Dave/Generated/FREERTOS/queue.c **** 		}
2404:../Dave/Generated/FREERTOS/queue.c **** 		portENABLE_INTERRUPTS();
2405:../Dave/Generated/FREERTOS/queue.c **** 
2406:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
2407:../Dave/Generated/FREERTOS/queue.c **** 	}
2408:../Dave/Generated/FREERTOS/queue.c **** 
2409:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2410:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2411:../Dave/Generated/FREERTOS/queue.c **** 
2412:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2413:../Dave/Generated/FREERTOS/queue.c **** 
2414:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2415:../Dave/Generated/FREERTOS/queue.c **** 	{
2416:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
2417:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2418:../Dave/Generated/FREERTOS/queue.c **** 
2419:../Dave/Generated/FREERTOS/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2420:../Dave/Generated/FREERTOS/queue.c **** 		is required to prevent an interrupt adding something to the queue
2421:../Dave/Generated/FREERTOS/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2422:../Dave/Generated/FREERTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2423:../Dave/Generated/FREERTOS/queue.c **** 		{
2424:../Dave/Generated/FREERTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2425:../Dave/Generated/FREERTOS/queue.c **** 			{
2426:../Dave/Generated/FREERTOS/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2427:../Dave/Generated/FREERTOS/queue.c **** 				leave with nothing? */
2428:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2429:../Dave/Generated/FREERTOS/queue.c **** 				{
2430:../Dave/Generated/FREERTOS/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2431:../Dave/Generated/FREERTOS/queue.c **** 					indicating that we need to block. */
2432:../Dave/Generated/FREERTOS/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
2433:../Dave/Generated/FREERTOS/queue.c **** 					portENABLE_INTERRUPTS();
2434:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_BLOCKED;
2435:../Dave/Generated/FREERTOS/queue.c **** 				}
2436:../Dave/Generated/FREERTOS/queue.c **** 				else
2437:../Dave/Generated/FREERTOS/queue.c **** 				{
2438:../Dave/Generated/FREERTOS/queue.c **** 					portENABLE_INTERRUPTS();
2439:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_FULL;
2440:../Dave/Generated/FREERTOS/queue.c **** 				}
2441:../Dave/Generated/FREERTOS/queue.c **** 			}
2442:../Dave/Generated/FREERTOS/queue.c **** 			else
2443:../Dave/Generated/FREERTOS/queue.c **** 			{
2444:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2445:../Dave/Generated/FREERTOS/queue.c **** 			}
2446:../Dave/Generated/FREERTOS/queue.c **** 		}
2447:../Dave/Generated/FREERTOS/queue.c **** 		portENABLE_INTERRUPTS();
2448:../Dave/Generated/FREERTOS/queue.c **** 
2449:../Dave/Generated/FREERTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2450:../Dave/Generated/FREERTOS/queue.c **** 		{
2451:../Dave/Generated/FREERTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2452:../Dave/Generated/FREERTOS/queue.c **** 			{
2453:../Dave/Generated/FREERTOS/queue.c **** 				/* Data is available from the queue. */
2454:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2455:../Dave/Generated/FREERTOS/queue.c **** 				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2456:../Dave/Generated/FREERTOS/queue.c **** 				{
2457:../Dave/Generated/FREERTOS/queue.c **** 					pxQueue->u.pcReadFrom = pxQueue->pcHead;
2458:../Dave/Generated/FREERTOS/queue.c **** 				}
2459:../Dave/Generated/FREERTOS/queue.c **** 				else
2460:../Dave/Generated/FREERTOS/queue.c **** 				{
2461:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2462:../Dave/Generated/FREERTOS/queue.c **** 				}
2463:../Dave/Generated/FREERTOS/queue.c **** 				--( pxQueue->uxMessagesWaiting );
2464:../Dave/Generated/FREERTOS/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->u
2465:../Dave/Generated/FREERTOS/queue.c **** 
2466:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdPASS;
2467:../Dave/Generated/FREERTOS/queue.c **** 
2468:../Dave/Generated/FREERTOS/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2469:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2470:../Dave/Generated/FREERTOS/queue.c **** 				{
2471:../Dave/Generated/FREERTOS/queue.c **** 					/* In this instance the co-routine could be placed directly
2472:../Dave/Generated/FREERTOS/queue.c **** 					into the ready list as we are within a critical section.
2473:../Dave/Generated/FREERTOS/queue.c **** 					Instead the same pending ready list mechanism is used as if
2474:../Dave/Generated/FREERTOS/queue.c **** 					the event were caused from within an interrupt. */
2475:../Dave/Generated/FREERTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2476:../Dave/Generated/FREERTOS/queue.c **** 					{
2477:../Dave/Generated/FREERTOS/queue.c **** 						xReturn = errQUEUE_YIELD;
2478:../Dave/Generated/FREERTOS/queue.c **** 					}
2479:../Dave/Generated/FREERTOS/queue.c **** 					else
2480:../Dave/Generated/FREERTOS/queue.c **** 					{
2481:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2482:../Dave/Generated/FREERTOS/queue.c **** 					}
2483:../Dave/Generated/FREERTOS/queue.c **** 				}
2484:../Dave/Generated/FREERTOS/queue.c **** 				else
2485:../Dave/Generated/FREERTOS/queue.c **** 				{
2486:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2487:../Dave/Generated/FREERTOS/queue.c **** 				}
2488:../Dave/Generated/FREERTOS/queue.c **** 			}
2489:../Dave/Generated/FREERTOS/queue.c **** 			else
2490:../Dave/Generated/FREERTOS/queue.c **** 			{
2491:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdFAIL;
2492:../Dave/Generated/FREERTOS/queue.c **** 			}
2493:../Dave/Generated/FREERTOS/queue.c **** 		}
2494:../Dave/Generated/FREERTOS/queue.c **** 		portENABLE_INTERRUPTS();
2495:../Dave/Generated/FREERTOS/queue.c **** 
2496:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
2497:../Dave/Generated/FREERTOS/queue.c **** 	}
2498:../Dave/Generated/FREERTOS/queue.c **** 
2499:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2500:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2501:../Dave/Generated/FREERTOS/queue.c **** 
2502:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2503:../Dave/Generated/FREERTOS/queue.c **** 
2504:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2505:../Dave/Generated/FREERTOS/queue.c **** 	{
2506:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2507:../Dave/Generated/FREERTOS/queue.c **** 
2508:../Dave/Generated/FREERTOS/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2509:../Dave/Generated/FREERTOS/queue.c **** 		exit without doing anything. */
2510:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2511:../Dave/Generated/FREERTOS/queue.c **** 		{
2512:../Dave/Generated/FREERTOS/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2513:../Dave/Generated/FREERTOS/queue.c **** 
2514:../Dave/Generated/FREERTOS/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2515:../Dave/Generated/FREERTOS/queue.c **** 			co-routine has not already been woken. */
2516:../Dave/Generated/FREERTOS/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
2517:../Dave/Generated/FREERTOS/queue.c **** 			{
2518:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2519:../Dave/Generated/FREERTOS/queue.c **** 				{
2520:../Dave/Generated/FREERTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2521:../Dave/Generated/FREERTOS/queue.c **** 					{
2522:../Dave/Generated/FREERTOS/queue.c **** 						return pdTRUE;
2523:../Dave/Generated/FREERTOS/queue.c **** 					}
2524:../Dave/Generated/FREERTOS/queue.c **** 					else
2525:../Dave/Generated/FREERTOS/queue.c **** 					{
2526:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2527:../Dave/Generated/FREERTOS/queue.c **** 					}
2528:../Dave/Generated/FREERTOS/queue.c **** 				}
2529:../Dave/Generated/FREERTOS/queue.c **** 				else
2530:../Dave/Generated/FREERTOS/queue.c **** 				{
2531:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2532:../Dave/Generated/FREERTOS/queue.c **** 				}
2533:../Dave/Generated/FREERTOS/queue.c **** 			}
2534:../Dave/Generated/FREERTOS/queue.c **** 			else
2535:../Dave/Generated/FREERTOS/queue.c **** 			{
2536:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2537:../Dave/Generated/FREERTOS/queue.c **** 			}
2538:../Dave/Generated/FREERTOS/queue.c **** 		}
2539:../Dave/Generated/FREERTOS/queue.c **** 		else
2540:../Dave/Generated/FREERTOS/queue.c **** 		{
2541:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2542:../Dave/Generated/FREERTOS/queue.c **** 		}
2543:../Dave/Generated/FREERTOS/queue.c **** 
2544:../Dave/Generated/FREERTOS/queue.c **** 		return xCoRoutinePreviouslyWoken;
2545:../Dave/Generated/FREERTOS/queue.c **** 	}
2546:../Dave/Generated/FREERTOS/queue.c **** 
2547:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2548:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2549:../Dave/Generated/FREERTOS/queue.c **** 
2550:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2551:../Dave/Generated/FREERTOS/queue.c **** 
2552:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2553:../Dave/Generated/FREERTOS/queue.c **** 	{
2554:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
2555:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2556:../Dave/Generated/FREERTOS/queue.c **** 
2557:../Dave/Generated/FREERTOS/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2558:../Dave/Generated/FREERTOS/queue.c **** 		not then just leave without doing anything. */
2559:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2560:../Dave/Generated/FREERTOS/queue.c **** 		{
2561:../Dave/Generated/FREERTOS/queue.c **** 			/* Copy the data from the queue. */
2562:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2563:../Dave/Generated/FREERTOS/queue.c **** 			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2564:../Dave/Generated/FREERTOS/queue.c **** 			{
2565:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->u.pcReadFrom = pxQueue->pcHead;
2566:../Dave/Generated/FREERTOS/queue.c **** 			}
2567:../Dave/Generated/FREERTOS/queue.c **** 			else
2568:../Dave/Generated/FREERTOS/queue.c **** 			{
2569:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2570:../Dave/Generated/FREERTOS/queue.c **** 			}
2571:../Dave/Generated/FREERTOS/queue.c **** 			--( pxQueue->uxMessagesWaiting );
2572:../Dave/Generated/FREERTOS/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->ux
2573:../Dave/Generated/FREERTOS/queue.c **** 
2574:../Dave/Generated/FREERTOS/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
2575:../Dave/Generated/FREERTOS/queue.c **** 			{
2576:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2577:../Dave/Generated/FREERTOS/queue.c **** 				{
2578:../Dave/Generated/FREERTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2579:../Dave/Generated/FREERTOS/queue.c **** 					{
2580:../Dave/Generated/FREERTOS/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2581:../Dave/Generated/FREERTOS/queue.c **** 					}
2582:../Dave/Generated/FREERTOS/queue.c **** 					else
2583:../Dave/Generated/FREERTOS/queue.c **** 					{
2584:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2585:../Dave/Generated/FREERTOS/queue.c **** 					}
2586:../Dave/Generated/FREERTOS/queue.c **** 				}
2587:../Dave/Generated/FREERTOS/queue.c **** 				else
2588:../Dave/Generated/FREERTOS/queue.c **** 				{
2589:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2590:../Dave/Generated/FREERTOS/queue.c **** 				}
2591:../Dave/Generated/FREERTOS/queue.c **** 			}
2592:../Dave/Generated/FREERTOS/queue.c **** 			else
2593:../Dave/Generated/FREERTOS/queue.c **** 			{
2594:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2595:../Dave/Generated/FREERTOS/queue.c **** 			}
2596:../Dave/Generated/FREERTOS/queue.c **** 
2597:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
2598:../Dave/Generated/FREERTOS/queue.c **** 		}
2599:../Dave/Generated/FREERTOS/queue.c **** 		else
2600:../Dave/Generated/FREERTOS/queue.c **** 		{
2601:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
2602:../Dave/Generated/FREERTOS/queue.c **** 		}
2603:../Dave/Generated/FREERTOS/queue.c **** 
2604:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
2605:../Dave/Generated/FREERTOS/queue.c **** 	}
2606:../Dave/Generated/FREERTOS/queue.c **** 
2607:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2608:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2609:../Dave/Generated/FREERTOS/queue.c **** 
2610:../Dave/Generated/FREERTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2611:../Dave/Generated/FREERTOS/queue.c **** 
2612:../Dave/Generated/FREERTOS/queue.c **** 	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified
2613:../Dave/Generated/FREERTOS/queue.c **** 	{
 4353              	 .loc 1 2613 0
 4354              	 .cfi_startproc
 4355              	 
 4356              	 
 4357              	 
 4358 0000 80B4     	 push {r7}
 4359              	.LCFI173:
 4360              	 .cfi_def_cfa_offset 4
 4361              	 .cfi_offset 7,-4
 4362 0002 85B0     	 sub sp,sp,#20
 4363              	.LCFI174:
 4364              	 .cfi_def_cfa_offset 24
 4365 0004 00AF     	 add r7,sp,#0
 4366              	.LCFI175:
 4367              	 .cfi_def_cfa_register 7
 4368 0006 7860     	 str r0,[r7,#4]
 4369 0008 3960     	 str r1,[r7]
2614:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t ux;
2615:../Dave/Generated/FREERTOS/queue.c **** 
2616:../Dave/Generated/FREERTOS/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
2617:../Dave/Generated/FREERTOS/queue.c **** 		a free slot. */
2618:../Dave/Generated/FREERTOS/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 4370              	 .loc 1 2618 0
 4371 000a 0023     	 movs r3,#0
 4372 000c FB60     	 str r3,[r7,#12]
 4373 000e 14E0     	 b .L304
 4374              	.L307:
2619:../Dave/Generated/FREERTOS/queue.c **** 		{
2620:../Dave/Generated/FREERTOS/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 4375              	 .loc 1 2620 0
 4376 0010 0E4A     	 ldr r2,.L308
 4377 0012 FB68     	 ldr r3,[r7,#12]
 4378 0014 52F83330 	 ldr r3,[r2,r3,lsl#3]
 4379 0018 002B     	 cmp r3,#0
 4380 001a 0BD1     	 bne .L305
2621:../Dave/Generated/FREERTOS/queue.c **** 			{
2622:../Dave/Generated/FREERTOS/queue.c **** 				/* Store the information on this queue. */
2623:../Dave/Generated/FREERTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 4381              	 .loc 1 2623 0
 4382 001c 0B49     	 ldr r1,.L308
 4383 001e FB68     	 ldr r3,[r7,#12]
 4384 0020 3A68     	 ldr r2,[r7]
 4385 0022 41F83320 	 str r2,[r1,r3,lsl#3]
2624:../Dave/Generated/FREERTOS/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 4386              	 .loc 1 2624 0
 4387 0026 094A     	 ldr r2,.L308
 4388 0028 FB68     	 ldr r3,[r7,#12]
 4389 002a DB00     	 lsls r3,r3,#3
 4390 002c 1344     	 add r3,r3,r2
 4391 002e 7A68     	 ldr r2,[r7,#4]
 4392 0030 5A60     	 str r2,[r3,#4]
2625:../Dave/Generated/FREERTOS/queue.c **** 
2626:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2627:../Dave/Generated/FREERTOS/queue.c **** 				break;
 4393              	 .loc 1 2627 0
 4394 0032 05E0     	 b .L303
 4395              	.L305:
2618:../Dave/Generated/FREERTOS/queue.c **** 		{
 4396              	 .loc 1 2618 0 discriminator 2
 4397 0034 FB68     	 ldr r3,[r7,#12]
 4398 0036 0133     	 adds r3,r3,#1
 4399 0038 FB60     	 str r3,[r7,#12]
 4400              	.L304:
2618:../Dave/Generated/FREERTOS/queue.c **** 		{
 4401              	 .loc 1 2618 0 is_stmt 0 discriminator 1
 4402 003a FB68     	 ldr r3,[r7,#12]
 4403 003c 072B     	 cmp r3,#7
 4404 003e E7D9     	 bls .L307
 4405              	.L303:
2628:../Dave/Generated/FREERTOS/queue.c **** 			}
2629:../Dave/Generated/FREERTOS/queue.c **** 			else
2630:../Dave/Generated/FREERTOS/queue.c **** 			{
2631:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2632:../Dave/Generated/FREERTOS/queue.c **** 			}
2633:../Dave/Generated/FREERTOS/queue.c **** 		}
2634:../Dave/Generated/FREERTOS/queue.c **** 	}
 4406              	 .loc 1 2634 0 is_stmt 1
 4407 0040 1437     	 adds r7,r7,#20
 4408              	.LCFI176:
 4409              	 .cfi_def_cfa_offset 4
 4410 0042 BD46     	 mov sp,r7
 4411              	.LCFI177:
 4412              	 .cfi_def_cfa_register 13
 4413              	 
 4414 0044 5DF8047B 	 ldr r7,[sp],#4
 4415              	.LCFI178:
 4416              	 .cfi_restore 7
 4417              	 .cfi_def_cfa_offset 0
 4418 0048 7047     	 bx lr
 4419              	.L309:
 4420 004a 00BF     	 .align 2
 4421              	.L308:
 4422 004c 00000000 	 .word xQueueRegistry
 4423              	 .cfi_endproc
 4424              	.LFE168:
 4426              	 .section .text.pcQueueGetName,"ax",%progbits
 4427              	 .align 2
 4428              	 .global pcQueueGetName
 4429              	 .thumb
 4430              	 .thumb_func
 4432              	pcQueueGetName:
 4433              	.LFB169:
2635:../Dave/Generated/FREERTOS/queue.c **** 
2636:../Dave/Generated/FREERTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2637:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2638:../Dave/Generated/FREERTOS/queue.c **** 
2639:../Dave/Generated/FREERTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2640:../Dave/Generated/FREERTOS/queue.c **** 
2641:../Dave/Generated/FREERTOS/queue.c **** 	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed
2642:../Dave/Generated/FREERTOS/queue.c **** 	{
 4434              	 .loc 1 2642 0
 4435              	 .cfi_startproc
 4436              	 
 4437              	 
 4438              	 
 4439 0000 80B4     	 push {r7}
 4440              	.LCFI179:
 4441              	 .cfi_def_cfa_offset 4
 4442              	 .cfi_offset 7,-4
 4443 0002 85B0     	 sub sp,sp,#20
 4444              	.LCFI180:
 4445              	 .cfi_def_cfa_offset 24
 4446 0004 00AF     	 add r7,sp,#0
 4447              	.LCFI181:
 4448              	 .cfi_def_cfa_register 7
 4449 0006 7860     	 str r0,[r7,#4]
2643:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t ux;
2644:../Dave/Generated/FREERTOS/queue.c **** 	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and singl
 4450              	 .loc 1 2644 0
 4451 0008 0023     	 movs r3,#0
 4452 000a BB60     	 str r3,[r7,#8]
2645:../Dave/Generated/FREERTOS/queue.c **** 
2646:../Dave/Generated/FREERTOS/queue.c **** 		/* Note there is nothing here to protect against another task adding or
2647:../Dave/Generated/FREERTOS/queue.c **** 		removing entries from the registry while it is being searched. */
2648:../Dave/Generated/FREERTOS/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 4453              	 .loc 1 2648 0
 4454 000c 0023     	 movs r3,#0
 4455 000e FB60     	 str r3,[r7,#12]
 4456 0010 10E0     	 b .L311
 4457              	.L314:
2649:../Dave/Generated/FREERTOS/queue.c **** 		{
2650:../Dave/Generated/FREERTOS/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 4458              	 .loc 1 2650 0
 4459 0012 0D4A     	 ldr r2,.L316
 4460 0014 FB68     	 ldr r3,[r7,#12]
 4461 0016 DB00     	 lsls r3,r3,#3
 4462 0018 1344     	 add r3,r3,r2
 4463 001a 5A68     	 ldr r2,[r3,#4]
 4464 001c 7B68     	 ldr r3,[r7,#4]
 4465 001e 9A42     	 cmp r2,r3
 4466 0020 05D1     	 bne .L312
2651:../Dave/Generated/FREERTOS/queue.c **** 			{
2652:../Dave/Generated/FREERTOS/queue.c **** 				pcReturn = xQueueRegistry[ ux ].pcQueueName;
 4467              	 .loc 1 2652 0
 4468 0022 094A     	 ldr r2,.L316
 4469 0024 FB68     	 ldr r3,[r7,#12]
 4470 0026 52F83330 	 ldr r3,[r2,r3,lsl#3]
 4471 002a BB60     	 str r3,[r7,#8]
2653:../Dave/Generated/FREERTOS/queue.c **** 				break;
 4472              	 .loc 1 2653 0
 4473 002c 05E0     	 b .L313
 4474              	.L312:
2648:../Dave/Generated/FREERTOS/queue.c **** 		{
 4475              	 .loc 1 2648 0 discriminator 2
 4476 002e FB68     	 ldr r3,[r7,#12]
 4477 0030 0133     	 adds r3,r3,#1
 4478 0032 FB60     	 str r3,[r7,#12]
 4479              	.L311:
2648:../Dave/Generated/FREERTOS/queue.c **** 		{
 4480              	 .loc 1 2648 0 is_stmt 0 discriminator 1
 4481 0034 FB68     	 ldr r3,[r7,#12]
 4482 0036 072B     	 cmp r3,#7
 4483 0038 EBD9     	 bls .L314
 4484              	.L313:
2654:../Dave/Generated/FREERTOS/queue.c **** 			}
2655:../Dave/Generated/FREERTOS/queue.c **** 			else
2656:../Dave/Generated/FREERTOS/queue.c **** 			{
2657:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2658:../Dave/Generated/FREERTOS/queue.c **** 			}
2659:../Dave/Generated/FREERTOS/queue.c **** 		}
2660:../Dave/Generated/FREERTOS/queue.c **** 
2661:../Dave/Generated/FREERTOS/queue.c **** 		return pcReturn;
 4485              	 .loc 1 2661 0 is_stmt 1
 4486 003a BB68     	 ldr r3,[r7,#8]
2662:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
 4487              	 .loc 1 2662 0
 4488 003c 1846     	 mov r0,r3
 4489 003e 1437     	 adds r7,r7,#20
 4490              	.LCFI182:
 4491              	 .cfi_def_cfa_offset 4
 4492 0040 BD46     	 mov sp,r7
 4493              	.LCFI183:
 4494              	 .cfi_def_cfa_register 13
 4495              	 
 4496 0042 5DF8047B 	 ldr r7,[sp],#4
 4497              	.LCFI184:
 4498              	 .cfi_restore 7
 4499              	 .cfi_def_cfa_offset 0
 4500 0046 7047     	 bx lr
 4501              	.L317:
 4502              	 .align 2
 4503              	.L316:
 4504 0048 00000000 	 .word xQueueRegistry
 4505              	 .cfi_endproc
 4506              	.LFE169:
 4508              	 .section .text.vQueueUnregisterQueue,"ax",%progbits
 4509              	 .align 2
 4510              	 .global vQueueUnregisterQueue
 4511              	 .thumb
 4512              	 .thumb_func
 4514              	vQueueUnregisterQueue:
 4515              	.LFB170:
2663:../Dave/Generated/FREERTOS/queue.c **** 
2664:../Dave/Generated/FREERTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2665:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2666:../Dave/Generated/FREERTOS/queue.c **** 
2667:../Dave/Generated/FREERTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2668:../Dave/Generated/FREERTOS/queue.c **** 
2669:../Dave/Generated/FREERTOS/queue.c **** 	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2670:../Dave/Generated/FREERTOS/queue.c **** 	{
 4516              	 .loc 1 2670 0
 4517              	 .cfi_startproc
 4518              	 
 4519              	 
 4520              	 
 4521 0000 80B4     	 push {r7}
 4522              	.LCFI185:
 4523              	 .cfi_def_cfa_offset 4
 4524              	 .cfi_offset 7,-4
 4525 0002 85B0     	 sub sp,sp,#20
 4526              	.LCFI186:
 4527              	 .cfi_def_cfa_offset 24
 4528 0004 00AF     	 add r7,sp,#0
 4529              	.LCFI187:
 4530              	 .cfi_def_cfa_register 7
 4531 0006 7860     	 str r0,[r7,#4]
2671:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t ux;
2672:../Dave/Generated/FREERTOS/queue.c **** 
2673:../Dave/Generated/FREERTOS/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
2674:../Dave/Generated/FREERTOS/queue.c **** 		registry. */
2675:../Dave/Generated/FREERTOS/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 4532              	 .loc 1 2675 0
 4533 0008 0023     	 movs r3,#0
 4534 000a FB60     	 str r3,[r7,#12]
 4535 000c 16E0     	 b .L319
 4536              	.L322:
2676:../Dave/Generated/FREERTOS/queue.c **** 		{
2677:../Dave/Generated/FREERTOS/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 4537              	 .loc 1 2677 0
 4538 000e 0F4A     	 ldr r2,.L323
 4539 0010 FB68     	 ldr r3,[r7,#12]
 4540 0012 DB00     	 lsls r3,r3,#3
 4541 0014 1344     	 add r3,r3,r2
 4542 0016 5A68     	 ldr r2,[r3,#4]
 4543 0018 7B68     	 ldr r3,[r7,#4]
 4544 001a 9A42     	 cmp r2,r3
 4545 001c 0BD1     	 bne .L320
2678:../Dave/Generated/FREERTOS/queue.c **** 			{
2679:../Dave/Generated/FREERTOS/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
2680:../Dave/Generated/FREERTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 4546              	 .loc 1 2680 0
 4547 001e 0B4A     	 ldr r2,.L323
 4548 0020 FB68     	 ldr r3,[r7,#12]
 4549 0022 0021     	 movs r1,#0
 4550 0024 42F83310 	 str r1,[r2,r3,lsl#3]
2681:../Dave/Generated/FREERTOS/queue.c **** 
2682:../Dave/Generated/FREERTOS/queue.c **** 				/* Set the handle to NULL to ensure the same queue handle cannot
2683:../Dave/Generated/FREERTOS/queue.c **** 				appear in the registry twice if it is added, removed, then
2684:../Dave/Generated/FREERTOS/queue.c **** 				added again. */
2685:../Dave/Generated/FREERTOS/queue.c **** 				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 4551              	 .loc 1 2685 0
 4552 0028 084A     	 ldr r2,.L323
 4553 002a FB68     	 ldr r3,[r7,#12]
 4554 002c DB00     	 lsls r3,r3,#3
 4555 002e 1344     	 add r3,r3,r2
 4556 0030 0022     	 movs r2,#0
 4557 0032 5A60     	 str r2,[r3,#4]
2686:../Dave/Generated/FREERTOS/queue.c **** 				break;
 4558              	 .loc 1 2686 0
 4559 0034 05E0     	 b .L318
 4560              	.L320:
2675:../Dave/Generated/FREERTOS/queue.c **** 		{
 4561              	 .loc 1 2675 0 discriminator 2
 4562 0036 FB68     	 ldr r3,[r7,#12]
 4563 0038 0133     	 adds r3,r3,#1
 4564 003a FB60     	 str r3,[r7,#12]
 4565              	.L319:
2675:../Dave/Generated/FREERTOS/queue.c **** 		{
 4566              	 .loc 1 2675 0 is_stmt 0 discriminator 1
 4567 003c FB68     	 ldr r3,[r7,#12]
 4568 003e 072B     	 cmp r3,#7
 4569 0040 E5D9     	 bls .L322
 4570              	.L318:
2687:../Dave/Generated/FREERTOS/queue.c **** 			}
2688:../Dave/Generated/FREERTOS/queue.c **** 			else
2689:../Dave/Generated/FREERTOS/queue.c **** 			{
2690:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2691:../Dave/Generated/FREERTOS/queue.c **** 			}
2692:../Dave/Generated/FREERTOS/queue.c **** 		}
2693:../Dave/Generated/FREERTOS/queue.c **** 
2694:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 4571              	 .loc 1 2694 0 is_stmt 1
 4572 0042 1437     	 adds r7,r7,#20
 4573              	.LCFI188:
 4574              	 .cfi_def_cfa_offset 4
 4575 0044 BD46     	 mov sp,r7
 4576              	.LCFI189:
 4577              	 .cfi_def_cfa_register 13
 4578              	 
 4579 0046 5DF8047B 	 ldr r7,[sp],#4
 4580              	.LCFI190:
 4581              	 .cfi_restore 7
 4582              	 .cfi_def_cfa_offset 0
 4583 004a 7047     	 bx lr
 4584              	.L324:
 4585              	 .align 2
 4586              	.L323:
 4587 004c 00000000 	 .word xQueueRegistry
 4588              	 .cfi_endproc
 4589              	.LFE170:
 4591              	 .section .text.vQueueWaitForMessageRestricted,"ax",%progbits
 4592              	 .align 2
 4593              	 .global vQueueWaitForMessageRestricted
 4594              	 .thumb
 4595              	 .thumb_func
 4597              	vQueueWaitForMessageRestricted:
 4598              	.LFB171:
2695:../Dave/Generated/FREERTOS/queue.c **** 
2696:../Dave/Generated/FREERTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2697:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2698:../Dave/Generated/FREERTOS/queue.c **** 
2699:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_TIMERS == 1 )
2700:../Dave/Generated/FREERTOS/queue.c **** 
2701:../Dave/Generated/FREERTOS/queue.c **** 	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType
2702:../Dave/Generated/FREERTOS/queue.c **** 	{
 4599              	 .loc 1 2702 0
 4600              	 .cfi_startproc
 4601              	 
 4602              	 
 4603 0000 80B5     	 push {r7,lr}
 4604              	.LCFI191:
 4605              	 .cfi_def_cfa_offset 8
 4606              	 .cfi_offset 7,-8
 4607              	 .cfi_offset 14,-4
 4608 0002 86B0     	 sub sp,sp,#24
 4609              	.LCFI192:
 4610              	 .cfi_def_cfa_offset 32
 4611 0004 00AF     	 add r7,sp,#0
 4612              	.LCFI193:
 4613              	 .cfi_def_cfa_register 7
 4614 0006 F860     	 str r0,[r7,#12]
 4615 0008 B960     	 str r1,[r7,#8]
 4616 000a 7A60     	 str r2,[r7,#4]
2703:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 4617              	 .loc 1 2703 0
 4618 000c FB68     	 ldr r3,[r7,#12]
 4619 000e 7B61     	 str r3,[r7,#20]
2704:../Dave/Generated/FREERTOS/queue.c **** 
2705:../Dave/Generated/FREERTOS/queue.c **** 		/* This function should not be called by application code hence the
2706:../Dave/Generated/FREERTOS/queue.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2707:../Dave/Generated/FREERTOS/queue.c **** 		designed for use by kernel code, and has special calling requirements.
2708:../Dave/Generated/FREERTOS/queue.c **** 		It can result in vListInsert() being called on a list that can only
2709:../Dave/Generated/FREERTOS/queue.c **** 		possibly ever have one item in it, so the list will be fast, but even
2710:../Dave/Generated/FREERTOS/queue.c **** 		so it should be called with the scheduler locked and not from a critical
2711:../Dave/Generated/FREERTOS/queue.c **** 		section. */
2712:../Dave/Generated/FREERTOS/queue.c **** 
2713:../Dave/Generated/FREERTOS/queue.c **** 		/* Only do anything if there are no messages in the queue.  This function
2714:../Dave/Generated/FREERTOS/queue.c **** 		will not actually cause the task to block, just place it on a blocked
2715:../Dave/Generated/FREERTOS/queue.c **** 		list.  It will not block until the scheduler is unlocked - at which
2716:../Dave/Generated/FREERTOS/queue.c **** 		time a yield will be performed.  If an item is added to the queue while
2717:../Dave/Generated/FREERTOS/queue.c **** 		the queue is locked, and the calling task blocks on the queue, then the
2718:../Dave/Generated/FREERTOS/queue.c **** 		calling task will be immediately unblocked when the queue is unlocked. */
2719:../Dave/Generated/FREERTOS/queue.c **** 		prvLockQueue( pxQueue );
 4620              	 .loc 1 2719 0
 4621 0010 FFF7FEFF 	 bl vPortEnterCritical
 4622 0014 7B69     	 ldr r3,[r7,#20]
 4623 0016 93F84430 	 ldrb r3,[r3,#68]
 4624 001a DBB2     	 uxtb r3,r3
 4625 001c 5BB2     	 sxtb r3,r3
 4626 001e B3F1FF3F 	 cmp r3,#-1
 4627 0022 03D1     	 bne .L326
 4628              	 .loc 1 2719 0 is_stmt 0 discriminator 1
 4629 0024 7B69     	 ldr r3,[r7,#20]
 4630 0026 0022     	 movs r2,#0
 4631 0028 83F84420 	 strb r2,[r3,#68]
 4632              	.L326:
 4633              	 .loc 1 2719 0 discriminator 3
 4634 002c 7B69     	 ldr r3,[r7,#20]
 4635 002e 93F84530 	 ldrb r3,[r3,#69]
 4636 0032 DBB2     	 uxtb r3,r3
 4637 0034 5BB2     	 sxtb r3,r3
 4638 0036 B3F1FF3F 	 cmp r3,#-1
 4639 003a 03D1     	 bne .L327
 4640              	 .loc 1 2719 0 discriminator 4
 4641 003c 7B69     	 ldr r3,[r7,#20]
 4642 003e 0022     	 movs r2,#0
 4643 0040 83F84520 	 strb r2,[r3,#69]
 4644              	.L327:
 4645              	 .loc 1 2719 0 discriminator 6
 4646 0044 FFF7FEFF 	 bl vPortExitCritical
2720:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 4647              	 .loc 1 2720 0 is_stmt 1 discriminator 6
 4648 0048 7B69     	 ldr r3,[r7,#20]
 4649 004a 9B6B     	 ldr r3,[r3,#56]
 4650 004c 002B     	 cmp r3,#0
 4651 004e 06D1     	 bne .L328
2721:../Dave/Generated/FREERTOS/queue.c **** 		{
2722:../Dave/Generated/FREERTOS/queue.c **** 			/* There is nothing in the queue, block for the specified period. */
2723:../Dave/Generated/FREERTOS/queue.c **** 			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefi
 4652              	 .loc 1 2723 0
 4653 0050 7B69     	 ldr r3,[r7,#20]
 4654 0052 2433     	 adds r3,r3,#36
 4655 0054 1846     	 mov r0,r3
 4656 0056 B968     	 ldr r1,[r7,#8]
 4657 0058 7A68     	 ldr r2,[r7,#4]
 4658 005a FFF7FEFF 	 bl vTaskPlaceOnEventListRestricted
 4659              	.L328:
2724:../Dave/Generated/FREERTOS/queue.c **** 		}
2725:../Dave/Generated/FREERTOS/queue.c **** 		else
2726:../Dave/Generated/FREERTOS/queue.c **** 		{
2727:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2728:../Dave/Generated/FREERTOS/queue.c **** 		}
2729:../Dave/Generated/FREERTOS/queue.c **** 		prvUnlockQueue( pxQueue );
 4660              	 .loc 1 2729 0
 4661 005e 7869     	 ldr r0,[r7,#20]
 4662 0060 FFF7FEFF 	 bl prvUnlockQueue
2730:../Dave/Generated/FREERTOS/queue.c **** 	}
 4663              	 .loc 1 2730 0
 4664 0064 1837     	 adds r7,r7,#24
 4665              	.LCFI194:
 4666              	 .cfi_def_cfa_offset 8
 4667 0066 BD46     	 mov sp,r7
 4668              	.LCFI195:
 4669              	 .cfi_def_cfa_register 13
 4670              	 
 4671 0068 80BD     	 pop {r7,pc}
 4672              	 .cfi_endproc
 4673              	.LFE171:
 4675 006a 00BF     	 .section .text.xQueueCreateSet,"ax",%progbits
 4676              	 .align 2
 4677              	 .global xQueueCreateSet
 4678              	 .thumb
 4679              	 .thumb_func
 4681              	xQueueCreateSet:
 4682              	.LFB172:
2731:../Dave/Generated/FREERTOS/queue.c **** 
2732:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_TIMERS */
2733:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2734:../Dave/Generated/FREERTOS/queue.c **** 
2735:../Dave/Generated/FREERTOS/queue.c **** #if( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
2736:../Dave/Generated/FREERTOS/queue.c **** 
2737:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
2738:../Dave/Generated/FREERTOS/queue.c **** 	{
 4683              	 .loc 1 2738 0
 4684              	 .cfi_startproc
 4685              	 
 4686              	 
 4687 0000 80B5     	 push {r7,lr}
 4688              	.LCFI196:
 4689              	 .cfi_def_cfa_offset 8
 4690              	 .cfi_offset 7,-8
 4691              	 .cfi_offset 14,-4
 4692 0002 84B0     	 sub sp,sp,#16
 4693              	.LCFI197:
 4694              	 .cfi_def_cfa_offset 24
 4695 0004 00AF     	 add r7,sp,#0
 4696              	.LCFI198:
 4697              	 .cfi_def_cfa_register 7
 4698 0006 7860     	 str r0,[r7,#4]
2739:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetHandle_t pxQueue;
2740:../Dave/Generated/FREERTOS/queue.c **** 
2741:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType_t ) sizeof( Queue_t * ), queueQUEU
 4699              	 .loc 1 2741 0
 4700 0008 7868     	 ldr r0,[r7,#4]
 4701 000a 0421     	 movs r1,#4
 4702 000c 0022     	 movs r2,#0
 4703 000e FFF7FEFF 	 bl xQueueGenericCreate
 4704 0012 F860     	 str r0,[r7,#12]
2742:../Dave/Generated/FREERTOS/queue.c **** 
2743:../Dave/Generated/FREERTOS/queue.c **** 		return pxQueue;
 4705              	 .loc 1 2743 0
 4706 0014 FB68     	 ldr r3,[r7,#12]
2744:../Dave/Generated/FREERTOS/queue.c **** 	}
 4707              	 .loc 1 2744 0
 4708 0016 1846     	 mov r0,r3
 4709 0018 1037     	 adds r7,r7,#16
 4710              	.LCFI199:
 4711              	 .cfi_def_cfa_offset 8
 4712 001a BD46     	 mov sp,r7
 4713              	.LCFI200:
 4714              	 .cfi_def_cfa_register 13
 4715              	 
 4716 001c 80BD     	 pop {r7,pc}
 4717              	 .cfi_endproc
 4718              	.LFE172:
 4720 001e 00BF     	 .section .text.xQueueAddToSet,"ax",%progbits
 4721              	 .align 2
 4722              	 .global xQueueAddToSet
 4723              	 .thumb
 4724              	 .thumb_func
 4726              	xQueueAddToSet:
 4727              	.LFB173:
2745:../Dave/Generated/FREERTOS/queue.c **** 
2746:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_QUEUE_SETS */
2747:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2748:../Dave/Generated/FREERTOS/queue.c **** 
2749:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
2750:../Dave/Generated/FREERTOS/queue.c **** 
2751:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2752:../Dave/Generated/FREERTOS/queue.c **** 	{
 4728              	 .loc 1 2752 0
 4729              	 .cfi_startproc
 4730              	 
 4731              	 
 4732 0000 80B5     	 push {r7,lr}
 4733              	.LCFI201:
 4734              	 .cfi_def_cfa_offset 8
 4735              	 .cfi_offset 7,-8
 4736              	 .cfi_offset 14,-4
 4737 0002 84B0     	 sub sp,sp,#16
 4738              	.LCFI202:
 4739              	 .cfi_def_cfa_offset 24
 4740 0004 00AF     	 add r7,sp,#0
 4741              	.LCFI203:
 4742              	 .cfi_def_cfa_register 7
 4743 0006 7860     	 str r0,[r7,#4]
 4744 0008 3960     	 str r1,[r7]
2753:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
2754:../Dave/Generated/FREERTOS/queue.c **** 
2755:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 4745              	 .loc 1 2755 0
 4746 000a FFF7FEFF 	 bl vPortEnterCritical
2756:../Dave/Generated/FREERTOS/queue.c **** 		{
2757:../Dave/Generated/FREERTOS/queue.c **** 			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
 4747              	 .loc 1 2757 0
 4748 000e 7B68     	 ldr r3,[r7,#4]
 4749 0010 9B6C     	 ldr r3,[r3,#72]
 4750 0012 002B     	 cmp r3,#0
 4751 0014 02D0     	 beq .L332
2758:../Dave/Generated/FREERTOS/queue.c **** 			{
2759:../Dave/Generated/FREERTOS/queue.c **** 				/* Cannot add a queue/semaphore to more than one queue set. */
2760:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdFAIL;
 4752              	 .loc 1 2760 0
 4753 0016 0023     	 movs r3,#0
 4754 0018 FB60     	 str r3,[r7,#12]
 4755 001a 0BE0     	 b .L333
 4756              	.L332:
2761:../Dave/Generated/FREERTOS/queue.c **** 			}
2762:../Dave/Generated/FREERTOS/queue.c **** 			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
 4757              	 .loc 1 2762 0
 4758 001c 7B68     	 ldr r3,[r7,#4]
 4759 001e 9B6B     	 ldr r3,[r3,#56]
 4760 0020 002B     	 cmp r3,#0
 4761 0022 02D0     	 beq .L334
2763:../Dave/Generated/FREERTOS/queue.c **** 			{
2764:../Dave/Generated/FREERTOS/queue.c **** 				/* Cannot add a queue/semaphore to a queue set if there are already
2765:../Dave/Generated/FREERTOS/queue.c **** 				items in the queue/semaphore. */
2766:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdFAIL;
 4762              	 .loc 1 2766 0
 4763 0024 0023     	 movs r3,#0
 4764 0026 FB60     	 str r3,[r7,#12]
 4765 0028 04E0     	 b .L333
 4766              	.L334:
2767:../Dave/Generated/FREERTOS/queue.c **** 			}
2768:../Dave/Generated/FREERTOS/queue.c **** 			else
2769:../Dave/Generated/FREERTOS/queue.c **** 			{
2770:../Dave/Generated/FREERTOS/queue.c **** 				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
 4767              	 .loc 1 2770 0
 4768 002a 7B68     	 ldr r3,[r7,#4]
 4769 002c 3A68     	 ldr r2,[r7]
 4770 002e 9A64     	 str r2,[r3,#72]
2771:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdPASS;
 4771              	 .loc 1 2771 0
 4772 0030 0123     	 movs r3,#1
 4773 0032 FB60     	 str r3,[r7,#12]
 4774              	.L333:
2772:../Dave/Generated/FREERTOS/queue.c **** 			}
2773:../Dave/Generated/FREERTOS/queue.c **** 		}
2774:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 4775              	 .loc 1 2774 0
 4776 0034 FFF7FEFF 	 bl vPortExitCritical
2775:../Dave/Generated/FREERTOS/queue.c **** 
2776:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 4777              	 .loc 1 2776 0
 4778 0038 FB68     	 ldr r3,[r7,#12]
2777:../Dave/Generated/FREERTOS/queue.c **** 	}
 4779              	 .loc 1 2777 0
 4780 003a 1846     	 mov r0,r3
 4781 003c 1037     	 adds r7,r7,#16
 4782              	.LCFI204:
 4783              	 .cfi_def_cfa_offset 8
 4784 003e BD46     	 mov sp,r7
 4785              	.LCFI205:
 4786              	 .cfi_def_cfa_register 13
 4787              	 
 4788 0040 80BD     	 pop {r7,pc}
 4789              	 .cfi_endproc
 4790              	.LFE173:
 4792 0042 00BF     	 .section .text.xQueueRemoveFromSet,"ax",%progbits
 4793              	 .align 2
 4794              	 .global xQueueRemoveFromSet
 4795              	 .thumb
 4796              	 .thumb_func
 4798              	xQueueRemoveFromSet:
 4799              	.LFB174:
2778:../Dave/Generated/FREERTOS/queue.c **** 
2779:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_QUEUE_SETS */
2780:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2781:../Dave/Generated/FREERTOS/queue.c **** 
2782:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
2783:../Dave/Generated/FREERTOS/queue.c **** 
2784:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueS
2785:../Dave/Generated/FREERTOS/queue.c **** 	{
 4800              	 .loc 1 2785 0
 4801              	 .cfi_startproc
 4802              	 
 4803              	 
 4804 0000 80B5     	 push {r7,lr}
 4805              	.LCFI206:
 4806              	 .cfi_def_cfa_offset 8
 4807              	 .cfi_offset 7,-8
 4808              	 .cfi_offset 14,-4
 4809 0002 84B0     	 sub sp,sp,#16
 4810              	.LCFI207:
 4811              	 .cfi_def_cfa_offset 24
 4812 0004 00AF     	 add r7,sp,#0
 4813              	.LCFI208:
 4814              	 .cfi_def_cfa_register 7
 4815 0006 7860     	 str r0,[r7,#4]
 4816 0008 3960     	 str r1,[r7]
2786:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
2787:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
 4817              	 .loc 1 2787 0
 4818 000a 7B68     	 ldr r3,[r7,#4]
 4819 000c BB60     	 str r3,[r7,#8]
2788:../Dave/Generated/FREERTOS/queue.c **** 
2789:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
 4820              	 .loc 1 2789 0
 4821 000e BB68     	 ldr r3,[r7,#8]
 4822 0010 9A6C     	 ldr r2,[r3,#72]
 4823 0012 3B68     	 ldr r3,[r7]
 4824 0014 9A42     	 cmp r2,r3
 4825 0016 02D0     	 beq .L337
2790:../Dave/Generated/FREERTOS/queue.c **** 		{
2791:../Dave/Generated/FREERTOS/queue.c **** 			/* The queue was not a member of the set. */
2792:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
 4826              	 .loc 1 2792 0
 4827 0018 0023     	 movs r3,#0
 4828 001a FB60     	 str r3,[r7,#12]
 4829 001c 0FE0     	 b .L338
 4830              	.L337:
2793:../Dave/Generated/FREERTOS/queue.c **** 		}
2794:../Dave/Generated/FREERTOS/queue.c **** 		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
 4831              	 .loc 1 2794 0
 4832 001e BB68     	 ldr r3,[r7,#8]
 4833 0020 9B6B     	 ldr r3,[r3,#56]
 4834 0022 002B     	 cmp r3,#0
 4835 0024 02D0     	 beq .L339
2795:../Dave/Generated/FREERTOS/queue.c **** 		{
2796:../Dave/Generated/FREERTOS/queue.c **** 			/* It is dangerous to remove a queue from a set when the queue is
2797:../Dave/Generated/FREERTOS/queue.c **** 			not empty because the queue set will still hold pending events for
2798:../Dave/Generated/FREERTOS/queue.c **** 			the queue. */
2799:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
 4836              	 .loc 1 2799 0
 4837 0026 0023     	 movs r3,#0
 4838 0028 FB60     	 str r3,[r7,#12]
 4839 002a 08E0     	 b .L338
 4840              	.L339:
2800:../Dave/Generated/FREERTOS/queue.c **** 		}
2801:../Dave/Generated/FREERTOS/queue.c **** 		else
2802:../Dave/Generated/FREERTOS/queue.c **** 		{
2803:../Dave/Generated/FREERTOS/queue.c **** 			taskENTER_CRITICAL();
 4841              	 .loc 1 2803 0
 4842 002c FFF7FEFF 	 bl vPortEnterCritical
2804:../Dave/Generated/FREERTOS/queue.c **** 			{
2805:../Dave/Generated/FREERTOS/queue.c **** 				/* The queue is no longer contained in the set. */
2806:../Dave/Generated/FREERTOS/queue.c **** 				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
 4843              	 .loc 1 2806 0
 4844 0030 BB68     	 ldr r3,[r7,#8]
 4845 0032 0022     	 movs r2,#0
 4846 0034 9A64     	 str r2,[r3,#72]
2807:../Dave/Generated/FREERTOS/queue.c **** 			}
2808:../Dave/Generated/FREERTOS/queue.c **** 			taskEXIT_CRITICAL();
 4847              	 .loc 1 2808 0
 4848 0036 FFF7FEFF 	 bl vPortExitCritical
2809:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 4849              	 .loc 1 2809 0
 4850 003a 0123     	 movs r3,#1
 4851 003c FB60     	 str r3,[r7,#12]
 4852              	.L338:
2810:../Dave/Generated/FREERTOS/queue.c **** 		}
2811:../Dave/Generated/FREERTOS/queue.c **** 
2812:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 4853              	 .loc 1 2812 0
 4854 003e FB68     	 ldr r3,[r7,#12]
2813:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
 4855              	 .loc 1 2813 0
 4856 0040 1846     	 mov r0,r3
 4857 0042 1037     	 adds r7,r7,#16
 4858              	.LCFI209:
 4859              	 .cfi_def_cfa_offset 8
 4860 0044 BD46     	 mov sp,r7
 4861              	.LCFI210:
 4862              	 .cfi_def_cfa_register 13
 4863              	 
 4864 0046 80BD     	 pop {r7,pc}
 4865              	 .cfi_endproc
 4866              	.LFE174:
 4868              	 .section .text.xQueueSelectFromSet,"ax",%progbits
 4869              	 .align 2
 4870              	 .global xQueueSelectFromSet
 4871              	 .thumb
 4872              	 .thumb_func
 4874              	xQueueSelectFromSet:
 4875              	.LFB175:
2814:../Dave/Generated/FREERTOS/queue.c **** 
2815:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_QUEUE_SETS */
2816:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2817:../Dave/Generated/FREERTOS/queue.c **** 
2818:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
2819:../Dave/Generated/FREERTOS/queue.c **** 
2820:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToW
2821:../Dave/Generated/FREERTOS/queue.c **** 	{
 4876              	 .loc 1 2821 0
 4877              	 .cfi_startproc
 4878              	 
 4879              	 
 4880 0000 80B5     	 push {r7,lr}
 4881              	.LCFI211:
 4882              	 .cfi_def_cfa_offset 8
 4883              	 .cfi_offset 7,-8
 4884              	 .cfi_offset 14,-4
 4885 0002 84B0     	 sub sp,sp,#16
 4886              	.LCFI212:
 4887              	 .cfi_def_cfa_offset 24
 4888 0004 00AF     	 add r7,sp,#0
 4889              	.LCFI213:
 4890              	 .cfi_def_cfa_register 7
 4891 0006 7860     	 str r0,[r7,#4]
 4892 0008 3960     	 str r1,[r7]
2822:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetMemberHandle_t xReturn = NULL;
 4893              	 .loc 1 2822 0
 4894 000a 0023     	 movs r3,#0
 4895 000c FB60     	 str r3,[r7,#12]
2823:../Dave/Generated/FREERTOS/queue.c **** 
2824:../Dave/Generated/FREERTOS/queue.c **** 		( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait ); /*lint !e961 Casti
 4896              	 .loc 1 2824 0
 4897 000e 07F10C03 	 add r3,r7,#12
 4898 0012 7868     	 ldr r0,[r7,#4]
 4899 0014 1946     	 mov r1,r3
 4900 0016 3A68     	 ldr r2,[r7]
 4901 0018 FFF7FEFF 	 bl xQueueReceive
2825:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 4902              	 .loc 1 2825 0
 4903 001c FB68     	 ldr r3,[r7,#12]
2826:../Dave/Generated/FREERTOS/queue.c **** 	}
 4904              	 .loc 1 2826 0
 4905 001e 1846     	 mov r0,r3
 4906 0020 1037     	 adds r7,r7,#16
 4907              	.LCFI214:
 4908              	 .cfi_def_cfa_offset 8
 4909 0022 BD46     	 mov sp,r7
 4910              	.LCFI215:
 4911              	 .cfi_def_cfa_register 13
 4912              	 
 4913 0024 80BD     	 pop {r7,pc}
 4914              	 .cfi_endproc
 4915              	.LFE175:
 4917 0026 00BF     	 .section .text.xQueueSelectFromSetFromISR,"ax",%progbits
 4918              	 .align 2
 4919              	 .global xQueueSelectFromSetFromISR
 4920              	 .thumb
 4921              	 .thumb_func
 4923              	xQueueSelectFromSetFromISR:
 4924              	.LFB176:
2827:../Dave/Generated/FREERTOS/queue.c **** 
2828:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_QUEUE_SETS */
2829:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2830:../Dave/Generated/FREERTOS/queue.c **** 
2831:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
2832:../Dave/Generated/FREERTOS/queue.c **** 
2833:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
2834:../Dave/Generated/FREERTOS/queue.c **** 	{
 4925              	 .loc 1 2834 0
 4926              	 .cfi_startproc
 4927              	 
 4928              	 
 4929 0000 80B5     	 push {r7,lr}
 4930              	.LCFI216:
 4931              	 .cfi_def_cfa_offset 8
 4932              	 .cfi_offset 7,-8
 4933              	 .cfi_offset 14,-4
 4934 0002 84B0     	 sub sp,sp,#16
 4935              	.LCFI217:
 4936              	 .cfi_def_cfa_offset 24
 4937 0004 00AF     	 add r7,sp,#0
 4938              	.LCFI218:
 4939              	 .cfi_def_cfa_register 7
 4940 0006 7860     	 str r0,[r7,#4]
2835:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetMemberHandle_t xReturn = NULL;
 4941              	 .loc 1 2835 0
 4942 0008 0023     	 movs r3,#0
 4943 000a FB60     	 str r3,[r7,#12]
2836:../Dave/Generated/FREERTOS/queue.c **** 
2837:../Dave/Generated/FREERTOS/queue.c **** 		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Castin
 4944              	 .loc 1 2837 0
 4945 000c 07F10C03 	 add r3,r7,#12
 4946 0010 7868     	 ldr r0,[r7,#4]
 4947 0012 1946     	 mov r1,r3
 4948 0014 0022     	 movs r2,#0
 4949 0016 FFF7FEFF 	 bl xQueueReceiveFromISR
2838:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 4950              	 .loc 1 2838 0
 4951 001a FB68     	 ldr r3,[r7,#12]
2839:../Dave/Generated/FREERTOS/queue.c **** 	}
 4952              	 .loc 1 2839 0
 4953 001c 1846     	 mov r0,r3
 4954 001e 1037     	 adds r7,r7,#16
 4955              	.LCFI219:
 4956              	 .cfi_def_cfa_offset 8
 4957 0020 BD46     	 mov sp,r7
 4958              	.LCFI220:
 4959              	 .cfi_def_cfa_register 13
 4960              	 
 4961 0022 80BD     	 pop {r7,pc}
 4962              	 .cfi_endproc
 4963              	.LFE176:
 4965              	 .section .text.prvNotifyQueueSetContainer,"ax",%progbits
 4966              	 .align 2
 4967              	 .thumb
 4968              	 .thumb_func
 4970              	prvNotifyQueueSetContainer:
 4971              	.LFB177:
2840:../Dave/Generated/FREERTOS/queue.c **** 
2841:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_QUEUE_SETS */
2842:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2843:../Dave/Generated/FREERTOS/queue.c **** 
2844:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
2845:../Dave/Generated/FREERTOS/queue.c **** 
2846:../Dave/Generated/FREERTOS/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
2847:../Dave/Generated/FREERTOS/queue.c **** 	{
 4972              	 .loc 1 2847 0
 4973              	 .cfi_startproc
 4974              	 
 4975              	 
 4976 0000 80B5     	 push {r7,lr}
 4977              	.LCFI221:
 4978              	 .cfi_def_cfa_offset 8
 4979              	 .cfi_offset 7,-8
 4980              	 .cfi_offset 14,-4
 4981 0002 88B0     	 sub sp,sp,#32
 4982              	.LCFI222:
 4983              	 .cfi_def_cfa_offset 40
 4984 0004 00AF     	 add r7,sp,#0
 4985              	.LCFI223:
 4986              	 .cfi_def_cfa_register 7
 4987 0006 7860     	 str r0,[r7,#4]
 4988 0008 3960     	 str r1,[r7]
2848:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
 4989              	 .loc 1 2848 0
 4990 000a 7B68     	 ldr r3,[r7,#4]
 4991 000c 9B6C     	 ldr r3,[r3,#72]
 4992 000e BB61     	 str r3,[r7,#24]
2849:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn = pdFALSE;
 4993              	 .loc 1 2849 0
 4994 0010 0023     	 movs r3,#0
 4995 0012 FB61     	 str r3,[r7,#28]
2850:../Dave/Generated/FREERTOS/queue.c **** 
2851:../Dave/Generated/FREERTOS/queue.c **** 		/* This function must be called form a critical section. */
2852:../Dave/Generated/FREERTOS/queue.c **** 
2853:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( pxQueueSetContainer );
 4996              	 .loc 1 2853 0
 4997 0014 BB69     	 ldr r3,[r7,#24]
 4998 0016 002B     	 cmp r3,#0
 4999 0018 09D1     	 bne .L346
 5000              	.LBB211:
 5001              	.LBB212:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 5002              	 .loc 2 195 0 discriminator 1
 5003              	
 5004 001a 4FF0FC03 	 mov r3,#252
 5005 001e 83F31188 	 msr basepri,r3
 5006 0022 BFF36F8F 	 isb 
 5007 0026 BFF34F8F 	 dsb 
 5008              	
 5009              	
 5010              	 .thumb
 5011 002a 3B61     	 str r3,[r7,#16]
 5012              	.L347:
 5013              	.LBE212:
 5014              	.LBE211:
 5015              	 .loc 1 2853 0 discriminator 1
 5016 002c FEE7     	 b .L347
 5017              	.L346:
2854:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
 5018              	 .loc 1 2854 0
 5019 002e BB69     	 ldr r3,[r7,#24]
 5020 0030 9A6B     	 ldr r2,[r3,#56]
 5021 0032 BB69     	 ldr r3,[r7,#24]
 5022 0034 DB6B     	 ldr r3,[r3,#60]
 5023 0036 9A42     	 cmp r2,r3
 5024 0038 09D3     	 bcc .L348
 5025              	.LBB213:
 5026              	.LBB214:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 5027              	 .loc 2 195 0 discriminator 1
 5028              	
 5029 003a 4FF0FC03 	 mov r3,#252
 5030 003e 83F31188 	 msr basepri,r3
 5031 0042 BFF36F8F 	 isb 
 5032 0046 BFF34F8F 	 dsb 
 5033              	
 5034              	
 5035              	 .thumb
 5036 004a FB60     	 str r3,[r7,#12]
 5037              	.L349:
 5038              	.LBE214:
 5039              	.LBE213:
 5040              	 .loc 1 2854 0 discriminator 2
 5041 004c FEE7     	 b .L349
 5042              	.L348:
2855:../Dave/Generated/FREERTOS/queue.c **** 
2856:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
 5043              	 .loc 1 2856 0
 5044 004e BB69     	 ldr r3,[r7,#24]
 5045 0050 9A6B     	 ldr r2,[r3,#56]
 5046 0052 BB69     	 ldr r3,[r7,#24]
 5047 0054 DB6B     	 ldr r3,[r3,#60]
 5048 0056 9A42     	 cmp r2,r3
 5049 0058 26D2     	 bcs .L350
 5050              	.LBB215:
2857:../Dave/Generated/FREERTOS/queue.c **** 		{
2858:../Dave/Generated/FREERTOS/queue.c **** 			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
 5051              	 .loc 1 2858 0
 5052 005a BB69     	 ldr r3,[r7,#24]
 5053 005c 93F84530 	 ldrb r3,[r3,#69]
 5054 0060 FB75     	 strb r3,[r7,#23]
2859:../Dave/Generated/FREERTOS/queue.c **** 
2860:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND( pxQueueSetContainer );
2861:../Dave/Generated/FREERTOS/queue.c **** 
2862:../Dave/Generated/FREERTOS/queue.c **** 			/* The data copied is the handle of the queue that contains data. */
2863:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
 5055              	 .loc 1 2863 0
 5056 0062 3B1D     	 adds r3,r7,#4
 5057 0064 B869     	 ldr r0,[r7,#24]
 5058 0066 1946     	 mov r1,r3
 5059 0068 3A68     	 ldr r2,[r7]
 5060 006a FFF7FEFF 	 bl prvCopyDataToQueue
 5061 006e F861     	 str r0,[r7,#28]
2864:../Dave/Generated/FREERTOS/queue.c **** 
2865:../Dave/Generated/FREERTOS/queue.c **** 			if( cTxLock == queueUNLOCKED )
 5062              	 .loc 1 2865 0
 5063 0070 97F91730 	 ldrsb r3,[r7,#23]
 5064 0074 B3F1FF3F 	 cmp r3,#-1
 5065 0078 0ED1     	 bne .L351
2866:../Dave/Generated/FREERTOS/queue.c **** 			{
2867:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
 5066              	 .loc 1 2867 0
 5067 007a BB69     	 ldr r3,[r7,#24]
 5068 007c 5B6A     	 ldr r3,[r3,#36]
 5069 007e 002B     	 cmp r3,#0
 5070 0080 12D0     	 beq .L352
2868:../Dave/Generated/FREERTOS/queue.c **** 				{
2869:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
 5071              	 .loc 1 2869 0
 5072 0082 BB69     	 ldr r3,[r7,#24]
 5073 0084 2433     	 adds r3,r3,#36
 5074 0086 1846     	 mov r0,r3
 5075 0088 FFF7FEFF 	 bl xTaskRemoveFromEventList
 5076 008c 0346     	 mov r3,r0
 5077 008e 002B     	 cmp r3,#0
 5078 0090 0AD0     	 beq .L352
2870:../Dave/Generated/FREERTOS/queue.c **** 					{
2871:../Dave/Generated/FREERTOS/queue.c **** 						/* The task waiting has a higher priority. */
2872:../Dave/Generated/FREERTOS/queue.c **** 						xReturn = pdTRUE;
 5079              	 .loc 1 2872 0
 5080 0092 0123     	 movs r3,#1
 5081 0094 FB61     	 str r3,[r7,#28]
 5082 0096 07E0     	 b .L352
 5083              	.L351:
2873:../Dave/Generated/FREERTOS/queue.c **** 					}
2874:../Dave/Generated/FREERTOS/queue.c **** 					else
2875:../Dave/Generated/FREERTOS/queue.c **** 					{
2876:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2877:../Dave/Generated/FREERTOS/queue.c **** 					}
2878:../Dave/Generated/FREERTOS/queue.c **** 				}
2879:../Dave/Generated/FREERTOS/queue.c **** 				else
2880:../Dave/Generated/FREERTOS/queue.c **** 				{
2881:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2882:../Dave/Generated/FREERTOS/queue.c **** 				}
2883:../Dave/Generated/FREERTOS/queue.c **** 			}
2884:../Dave/Generated/FREERTOS/queue.c **** 			else
2885:../Dave/Generated/FREERTOS/queue.c **** 			{
2886:../Dave/Generated/FREERTOS/queue.c **** 				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
 5084              	 .loc 1 2886 0
 5085 0098 FB7D     	 ldrb r3,[r7,#23]
 5086 009a 0133     	 adds r3,r3,#1
 5087 009c DBB2     	 uxtb r3,r3
 5088 009e DAB2     	 uxtb r2,r3
 5089 00a0 BB69     	 ldr r3,[r7,#24]
 5090 00a2 83F84520 	 strb r2,[r3,#69]
 5091              	.LBE215:
 5092 00a6 FFE7     	 b .L350
 5093              	.L352:
 5094              	.L350:
2887:../Dave/Generated/FREERTOS/queue.c **** 			}
2888:../Dave/Generated/FREERTOS/queue.c **** 		}
2889:../Dave/Generated/FREERTOS/queue.c **** 		else
2890:../Dave/Generated/FREERTOS/queue.c **** 		{
2891:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2892:../Dave/Generated/FREERTOS/queue.c **** 		}
2893:../Dave/Generated/FREERTOS/queue.c **** 
2894:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 5095              	 .loc 1 2894 0
 5096 00a8 FB69     	 ldr r3,[r7,#28]
2895:../Dave/Generated/FREERTOS/queue.c **** 	}
 5097              	 .loc 1 2895 0
 5098 00aa 1846     	 mov r0,r3
 5099 00ac 2037     	 adds r7,r7,#32
 5100              	.LCFI224:
 5101              	 .cfi_def_cfa_offset 8
 5102 00ae BD46     	 mov sp,r7
 5103              	.LCFI225:
 5104              	 .cfi_def_cfa_register 13
 5105              	 
 5106 00b0 80BD     	 pop {r7,pc}
 5107              	 .cfi_endproc
 5108              	.LFE177:
 5110 00b2 00BF     	 .text
 5111              	.Letext0:
 5112              	 .file 3 "c:\\kits\\dave\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\lib\\gcc\\arm-none-eabi\\4.9.3\\include\\stddef.h"
 5113              	 .file 4 "c:\\kits\\dave\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 5114              	 .file 5 "c:\\kits\\dave\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 5115              	 .file 6 "../Dave/Generated/FREERTOS/list.h"
 5116              	 .file 7 "../Dave/Generated/FREERTOS/task.h"
 5117              	 .file 8 "../Dave/Generated/FREERTOS/queue.h"
 5118              	 .file 9 "C:/Workspaces/DAVE-4.4.2-64Bit/FreeRtos_Led/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
                            *COM*:00000040 xQueueRegistry
    {standard input}:21     .text.xQueueGenericReset:00000000 $t
    {standard input}:26     .text.xQueueGenericReset:00000000 xQueueGenericReset
    {standard input}:172    .text.xQueueGenericReset:000000cc $d
    {standard input}:177    .text.xQueueGenericCreate:00000000 $t
    {standard input}:182    .text.xQueueGenericCreate:00000000 xQueueGenericCreate
    {standard input}:285    .text.prvInitialiseNewQueue:00000000 prvInitialiseNewQueue
    {standard input}:281    .text.prvInitialiseNewQueue:00000000 $t
    {standard input}:354    .text.prvInitialiseMutex:00000000 $t
    {standard input}:358    .text.prvInitialiseMutex:00000000 prvInitialiseMutex
    {standard input}:909    .text.xQueueGenericSend:00000000 xQueueGenericSend
    {standard input}:412    .text.xQueueCreateMutex:00000000 $t
    {standard input}:417    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
    {standard input}:467    .text.xQueueGetMutexHolder:00000000 $t
    {standard input}:472    .text.xQueueGetMutexHolder:00000000 xQueueGetMutexHolder
    {standard input}:525    .text.xQueueGetMutexHolderFromISR:00000000 $t
    {standard input}:530    .text.xQueueGetMutexHolderFromISR:00000000 xQueueGetMutexHolderFromISR
    {standard input}:605    .text.xQueueGiveMutexRecursive:00000000 $t
    {standard input}:610    .text.xQueueGiveMutexRecursive:00000000 xQueueGiveMutexRecursive
    {standard input}:704    .text.xQueueTakeMutexRecursive:00000000 $t
    {standard input}:709    .text.xQueueTakeMutexRecursive:00000000 xQueueTakeMutexRecursive
    {standard input}:2140   .text.xQueueSemaphoreTake:00000000 xQueueSemaphoreTake
    {standard input}:804    .text.xQueueCreateCountingSemaphore:00000000 $t
    {standard input}:809    .text.xQueueCreateCountingSemaphore:00000000 xQueueCreateCountingSemaphore
    {standard input}:904    .text.xQueueGenericSend:00000000 $t
    {standard input}:3700   .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
    {standard input}:4970   .text.prvNotifyQueueSetContainer:00000000 prvNotifyQueueSetContainer
    {standard input}:4211   .text.prvIsQueueFull:00000000 prvIsQueueFull
    {standard input}:3929   .text.prvUnlockQueue:00000000 prvUnlockQueue
    {standard input}:1293   .text.xQueueGenericSend:00000220 $d
    {standard input}:1298   .text.xQueueGenericSendFromISR:00000000 $t
    {standard input}:1303   .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
    {standard input}:1565   .text.xQueueGiveFromISR:00000000 $t
    {standard input}:1570   .text.xQueueGiveFromISR:00000000 xQueueGiveFromISR
    {standard input}:1815   .text.xQueueReceive:00000000 $t
    {standard input}:1820   .text.xQueueReceive:00000000 xQueueReceive
    {standard input}:3857   .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
    {standard input}:4076   .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
    {standard input}:2130   .text.xQueueReceive:000001bc $d
    {standard input}:2135   .text.xQueueSemaphoreTake:00000000 $t
    {standard input}:3641   .text.prvGetDisinheritPriorityAfterTimeout:00000000 prvGetDisinheritPriorityAfterTimeout
    {standard input}:2503   .text.xQueueSemaphoreTake:00000210 $d
    {standard input}:2508   .text.xQueuePeek:00000000 $t
    {standard input}:2513   .text.xQueuePeek:00000000 xQueuePeek
    {standard input}:2826   .text.xQueuePeek:000001c0 $d
    {standard input}:2831   .text.xQueueReceiveFromISR:00000000 $t
    {standard input}:2836   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
    {standard input}:3038   .text.xQueuePeekFromISR:00000000 $t
    {standard input}:3043   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
    {standard input}:3224   .text.uxQueueMessagesWaiting:00000000 $t
    {standard input}:3229   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
    {standard input}:3293   .text.uxQueueSpacesAvailable:00000000 $t
    {standard input}:3298   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
    {standard input}:3368   .text.uxQueueMessagesWaitingFromISR:00000000 $t
    {standard input}:3373   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
    {standard input}:3437   .text.vQueueDelete:00000000 $t
    {standard input}:3442   .text.vQueueDelete:00000000 vQueueDelete
    {standard input}:4514   .text.vQueueUnregisterQueue:00000000 vQueueUnregisterQueue
    {standard input}:3504   .text.uxQueueGetQueueNumber:00000000 $t
    {standard input}:3509   .text.uxQueueGetQueueNumber:00000000 uxQueueGetQueueNumber
    {standard input}:3548   .text.vQueueSetQueueNumber:00000000 $t
    {standard input}:3553   .text.vQueueSetQueueNumber:00000000 vQueueSetQueueNumber
    {standard input}:3593   .text.ucQueueGetQueueType:00000000 $t
    {standard input}:3598   .text.ucQueueGetQueueType:00000000 ucQueueGetQueueType
    {standard input}:3637   .text.prvGetDisinheritPriorityAfterTimeout:00000000 $t
    {standard input}:3696   .text.prvCopyDataToQueue:00000000 $t
    {standard input}:3853   .text.prvCopyDataFromQueue:00000000 $t
    {standard input}:3925   .text.prvUnlockQueue:00000000 $t
    {standard input}:4072   .text.prvIsQueueEmpty:00000000 $t
    {standard input}:4128   .text.xQueueIsQueueEmptyFromISR:00000000 $t
    {standard input}:4133   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
    {standard input}:4207   .text.prvIsQueueFull:00000000 $t
    {standard input}:4265   .text.xQueueIsQueueFullFromISR:00000000 $t
    {standard input}:4270   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
    {standard input}:4346   .text.vQueueAddToRegistry:00000000 $t
    {standard input}:4351   .text.vQueueAddToRegistry:00000000 vQueueAddToRegistry
    {standard input}:4422   .text.vQueueAddToRegistry:0000004c $d
    {standard input}:4427   .text.pcQueueGetName:00000000 $t
    {standard input}:4432   .text.pcQueueGetName:00000000 pcQueueGetName
    {standard input}:4504   .text.pcQueueGetName:00000048 $d
    {standard input}:4509   .text.vQueueUnregisterQueue:00000000 $t
    {standard input}:4587   .text.vQueueUnregisterQueue:0000004c $d
    {standard input}:4592   .text.vQueueWaitForMessageRestricted:00000000 $t
    {standard input}:4597   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
    {standard input}:4676   .text.xQueueCreateSet:00000000 $t
    {standard input}:4681   .text.xQueueCreateSet:00000000 xQueueCreateSet
    {standard input}:4721   .text.xQueueAddToSet:00000000 $t
    {standard input}:4726   .text.xQueueAddToSet:00000000 xQueueAddToSet
    {standard input}:4793   .text.xQueueRemoveFromSet:00000000 $t
    {standard input}:4798   .text.xQueueRemoveFromSet:00000000 xQueueRemoveFromSet
    {standard input}:4869   .text.xQueueSelectFromSet:00000000 $t
    {standard input}:4874   .text.xQueueSelectFromSet:00000000 xQueueSelectFromSet
    {standard input}:4918   .text.xQueueSelectFromSetFromISR:00000000 $t
    {standard input}:4923   .text.xQueueSelectFromSetFromISR:00000000 xQueueSelectFromSetFromISR
    {standard input}:4966   .text.prvNotifyQueueSetContainer:00000000 $t
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vPortEnterCritical
xTaskRemoveFromEventList
vListInitialise
vPortExitCritical
pvPortMalloc
xTaskGetCurrentTaskHandle
xTaskGetSchedulerState
vTaskInternalSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vPortValidateInterruptPriority
pvTaskIncrementMutexHeldCount
xTaskPriorityInherit
vTaskPriorityDisinheritAfterTimeout
vPortFree
xTaskPriorityDisinherit
memcpy
vTaskMissedYield
vTaskPlaceOnEventListRestricted
